
APP_2.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   0000010c  08013800  08013800  00003800  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         000015b4  0801390c  0801390c  0000390c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000014  08014ec0  08014ec0  00004ec0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  08014ed4  08014ed4  00010010  2**0
                  CONTENTS
  4 .ARM          00000000  08014ed4  08014ed4  00010010  2**0
                  CONTENTS
  5 .preinit_array 00000000  08014ed4  08014ed4  00010010  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  08014ed4  08014ed4  00004ed4  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  08014ed8  08014ed8  00004ed8  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         00000010  20000000  08014edc  00010000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          0000002c  20000010  08014eec  00010010  2**2
                  ALLOC
 10 ._user_heap_stack 00000604  2000003c  08014eec  0001003c  2**0
                  ALLOC
 11 .ARM.attributes 00000029  00000000  00000000  00010010  2**0
                  CONTENTS, READONLY
 12 .debug_info   000035cf  00000000  00000000  00010039  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_abbrev 00001011  00000000  00000000  00013608  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_aranges 000003e8  00000000  00000000  00014620  2**3
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_ranges 00000348  00000000  00000000  00014a08  2**3
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_macro  00010e3d  00000000  00000000  00014d50  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_line   0000414a  00000000  00000000  00025b8d  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_str    0007ca07  00000000  00000000  00029cd7  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .comment      0000007b  00000000  00000000  000a66de  2**0
                  CONTENTS, READONLY
 20 .debug_frame  00000cc0  00000000  00000000  000a675c  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

0801390c <__do_global_dtors_aux>:
 801390c:	b510      	push	{r4, lr}
 801390e:	4c05      	ldr	r4, [pc, #20]	; (8013924 <__do_global_dtors_aux+0x18>)
 8013910:	7823      	ldrb	r3, [r4, #0]
 8013912:	b933      	cbnz	r3, 8013922 <__do_global_dtors_aux+0x16>
 8013914:	4b04      	ldr	r3, [pc, #16]	; (8013928 <__do_global_dtors_aux+0x1c>)
 8013916:	b113      	cbz	r3, 801391e <__do_global_dtors_aux+0x12>
 8013918:	4804      	ldr	r0, [pc, #16]	; (801392c <__do_global_dtors_aux+0x20>)
 801391a:	f3af 8000 	nop.w
 801391e:	2301      	movs	r3, #1
 8013920:	7023      	strb	r3, [r4, #0]
 8013922:	bd10      	pop	{r4, pc}
 8013924:	20000010 	.word	0x20000010
 8013928:	00000000 	.word	0x00000000
 801392c:	08014ea8 	.word	0x08014ea8

08013930 <frame_dummy>:
 8013930:	b508      	push	{r3, lr}
 8013932:	4b03      	ldr	r3, [pc, #12]	; (8013940 <frame_dummy+0x10>)
 8013934:	b11b      	cbz	r3, 801393e <frame_dummy+0xe>
 8013936:	4903      	ldr	r1, [pc, #12]	; (8013944 <frame_dummy+0x14>)
 8013938:	4803      	ldr	r0, [pc, #12]	; (8013948 <frame_dummy+0x18>)
 801393a:	f3af 8000 	nop.w
 801393e:	bd08      	pop	{r3, pc}
 8013940:	00000000 	.word	0x00000000
 8013944:	20000014 	.word	0x20000014
 8013948:	08014ea8 	.word	0x08014ea8

0801394c <USB_LP_CAN1_RX0_IRQHandler>:

static void (*callBack)(void) = NULL;


void  USB_LP_CAN1_RX0_IRQHandler(void)
{
 801394c:	b580      	push	{r7, lr}
 801394e:	af00      	add	r7, sp, #0
	if(callBack != NULL)
 8013950:	4b04      	ldr	r3, [pc, #16]	; (8013964 <USB_LP_CAN1_RX0_IRQHandler+0x18>)
 8013952:	681b      	ldr	r3, [r3, #0]
 8013954:	2b00      	cmp	r3, #0
 8013956:	d002      	beq.n	801395e <USB_LP_CAN1_RX0_IRQHandler+0x12>
		callBack();
 8013958:	4b02      	ldr	r3, [pc, #8]	; (8013964 <USB_LP_CAN1_RX0_IRQHandler+0x18>)
 801395a:	681b      	ldr	r3, [r3, #0]
 801395c:	4798      	blx	r3
}
 801395e:	bf00      	nop
 8013960:	bd80      	pop	{r7, pc}
 8013962:	bf00      	nop
 8013964:	2000002c 	.word	0x2000002c

08013968 <CAN_Init>:



void CAN_Init(void (*ptr)(void))
{
 8013968:	b580      	push	{r7, lr}
 801396a:	b086      	sub	sp, #24
 801396c:	af00      	add	r7, sp, #0
 801396e:	6078      	str	r0, [r7, #4]
	callBack = ptr;
 8013970:	4a5f      	ldr	r2, [pc, #380]	; (8013af0 <CAN_Init+0x188>)
 8013972:	687b      	ldr	r3, [r7, #4]
 8013974:	6013      	str	r3, [r2, #0]

	RCC_EnablePeripheralClock(CAN_PERIPHERAL);
 8013976:	2039      	movs	r0, #57	; 0x39
 8013978:	f001 f908 	bl	8014b8c <RCC_EnablePeripheralClock>
//	RCC_EnablePeripheralClock(GPIOA_PERIPHERAL);
	RCC_EnablePeripheralClock(GPIOB_PERIPHERAL);
 801397c:	2043      	movs	r0, #67	; 0x43
 801397e:	f001 f905 	bl	8014b8c <RCC_EnablePeripheralClock>
	RCC_EnablePeripheralClock(AFIO_PERIPHERAL);
 8013982:	2040      	movs	r0, #64	; 0x40
 8013984:	f001 f902 	bl	8014b8c <RCC_EnablePeripheralClock>

	NVIC_EnableInterrupt(USB_LP_CAN1_RX0_IRQn);
 8013988:	2014      	movs	r0, #20
 801398a:	f001 f83f 	bl	8014a0c <NVIC_EnableInterrupt>


	CLR_BIT(CAN1->MCR, 1);		// exit sleep mode
 801398e:	4b59      	ldr	r3, [pc, #356]	; (8013af4 <CAN_Init+0x18c>)
 8013990:	681b      	ldr	r3, [r3, #0]
 8013992:	4a58      	ldr	r2, [pc, #352]	; (8013af4 <CAN_Init+0x18c>)
 8013994:	f023 0302 	bic.w	r3, r3, #2
 8013998:	6013      	str	r3, [r2, #0]
	while(GET_BIT(CAN1->MSR, 0) == 1);		// wait until sleep ack be 0
 801399a:	bf00      	nop
 801399c:	4b55      	ldr	r3, [pc, #340]	; (8013af4 <CAN_Init+0x18c>)
 801399e:	685b      	ldr	r3, [r3, #4]
 80139a0:	f003 0301 	and.w	r3, r3, #1
 80139a4:	2b01      	cmp	r3, #1
 80139a6:	d0f9      	beq.n	801399c <CAN_Init+0x34>


	SET_BIT(CAN1->MCR, 0);		// enter intialization mode
 80139a8:	4b52      	ldr	r3, [pc, #328]	; (8013af4 <CAN_Init+0x18c>)
 80139aa:	681b      	ldr	r3, [r3, #0]
 80139ac:	4a51      	ldr	r2, [pc, #324]	; (8013af4 <CAN_Init+0x18c>)
 80139ae:	f043 0301 	orr.w	r3, r3, #1
 80139b2:	6013      	str	r3, [r2, #0]
	while(GET_BIT(CAN1->MSR, 0) == 0);		// wait until intialization ack be 1
 80139b4:	bf00      	nop
 80139b6:	4b4f      	ldr	r3, [pc, #316]	; (8013af4 <CAN_Init+0x18c>)
 80139b8:	685b      	ldr	r3, [r3, #4]
 80139ba:	f003 0301 	and.w	r3, r3, #1
 80139be:	2b00      	cmp	r3, #0
 80139c0:	d0f9      	beq.n	80139b6 <CAN_Init+0x4e>

	SET_BIT(CAN1->IER, 1);		// FIFI 0 Rx IRQ enable
 80139c2:	4b4c      	ldr	r3, [pc, #304]	; (8013af4 <CAN_Init+0x18c>)
 80139c4:	695b      	ldr	r3, [r3, #20]
 80139c6:	4a4b      	ldr	r2, [pc, #300]	; (8013af4 <CAN_Init+0x18c>)
 80139c8:	f043 0302 	orr.w	r3, r3, #2
 80139cc:	6153      	str	r3, [r2, #20]

//	SET_BIT(CAN1->BTR, 31);		// silent mode
	CLR_BIT(CAN1->BTR, 31);		// not silent mode
 80139ce:	4b49      	ldr	r3, [pc, #292]	; (8013af4 <CAN_Init+0x18c>)
 80139d0:	69db      	ldr	r3, [r3, #28]
 80139d2:	4a48      	ldr	r2, [pc, #288]	; (8013af4 <CAN_Init+0x18c>)
 80139d4:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 80139d8:	61d3      	str	r3, [r2, #28]
//	SET_BIT(CAN1->BTR, 30);		// loopback mode
	CLR_BIT(CAN1->BTR, 30);		// not loopback mode
 80139da:	4b46      	ldr	r3, [pc, #280]	; (8013af4 <CAN_Init+0x18c>)
 80139dc:	69db      	ldr	r3, [r3, #28]
 80139de:	4a45      	ldr	r2, [pc, #276]	; (8013af4 <CAN_Init+0x18c>)
 80139e0:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
 80139e4:	61d3      	str	r3, [r2, #28]

	// lower data rate to be 250 Kbps
	CAN1->BTR &= 0xF0000000;		// clear all register except high ones
 80139e6:	4b43      	ldr	r3, [pc, #268]	; (8013af4 <CAN_Init+0x18c>)
 80139e8:	69db      	ldr	r3, [r3, #28]
 80139ea:	4a42      	ldr	r2, [pc, #264]	; (8013af4 <CAN_Init+0x18c>)
 80139ec:	f003 4370 	and.w	r3, r3, #4026531840	; 0xf0000000
 80139f0:	61d3      	str	r3, [r2, #28]
	SET_BIT(CAN1->BTR, 0);		// BRP bits (9:0) = 1 --> prescaller = 2
 80139f2:	4b40      	ldr	r3, [pc, #256]	; (8013af4 <CAN_Init+0x18c>)
 80139f4:	69db      	ldr	r3, [r3, #28]
 80139f6:	4a3f      	ldr	r2, [pc, #252]	; (8013af4 <CAN_Init+0x18c>)
 80139f8:	f043 0301 	orr.w	r3, r3, #1
 80139fc:	61d3      	str	r3, [r2, #28]
	SET_BIT(CAN1->BTR, 1);		// BRP bits (9:0) = 3 --> prescaller = 4
 80139fe:	4b3d      	ldr	r3, [pc, #244]	; (8013af4 <CAN_Init+0x18c>)
 8013a00:	69db      	ldr	r3, [r3, #28]
 8013a02:	4a3c      	ldr	r2, [pc, #240]	; (8013af4 <CAN_Init+0x18c>)
 8013a04:	f043 0302 	orr.w	r3, r3, #2
 8013a08:	61d3      	str	r3, [r2, #28]
	SET_BIT(CAN1->BTR, 2);		// BRP bits (9:0) = 7 --> prescaller = 8
 8013a0a:	4b3a      	ldr	r3, [pc, #232]	; (8013af4 <CAN_Init+0x18c>)
 8013a0c:	69db      	ldr	r3, [r3, #28]
 8013a0e:	4a39      	ldr	r2, [pc, #228]	; (8013af4 <CAN_Init+0x18c>)
 8013a10:	f043 0304 	orr.w	r3, r3, #4
 8013a14:	61d3      	str	r3, [r2, #28]

	SET_BIT(CAN1->BTR, 17);		// TS1 bits (19:16) = 2  --> t_BS1 = 3  tq
 8013a16:	4b37      	ldr	r3, [pc, #220]	; (8013af4 <CAN_Init+0x18c>)
 8013a18:	69db      	ldr	r3, [r3, #28]
 8013a1a:	4a36      	ldr	r2, [pc, #216]	; (8013af4 <CAN_Init+0x18c>)
 8013a1c:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8013a20:	61d3      	str	r3, [r2, #28]
	SET_BIT(CAN1->BTR, 18);		// TS1 bits (19:16) = 6  --> t_BS1 = 7  tq
 8013a22:	4b34      	ldr	r3, [pc, #208]	; (8013af4 <CAN_Init+0x18c>)
 8013a24:	69db      	ldr	r3, [r3, #28]
 8013a26:	4a33      	ldr	r2, [pc, #204]	; (8013af4 <CAN_Init+0x18c>)
 8013a28:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 8013a2c:	61d3      	str	r3, [r2, #28]
	SET_BIT(CAN1->BTR, 19);		// TS1 bits (19:16) = 14 --> t_BS1 = 15 tq
 8013a2e:	4b31      	ldr	r3, [pc, #196]	; (8013af4 <CAN_Init+0x18c>)
 8013a30:	69db      	ldr	r3, [r3, #28]
 8013a32:	4a30      	ldr	r2, [pc, #192]	; (8013af4 <CAN_Init+0x18c>)
 8013a34:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 8013a38:	61d3      	str	r3, [r2, #28]

	SET_BIT(CAN1->BTR, 20);		// TS2 bits (22:20) = 1 --> t_BS2 = 2 tq
 8013a3a:	4b2e      	ldr	r3, [pc, #184]	; (8013af4 <CAN_Init+0x18c>)
 8013a3c:	69db      	ldr	r3, [r3, #28]
 8013a3e:	4a2d      	ldr	r2, [pc, #180]	; (8013af4 <CAN_Init+0x18c>)
 8013a40:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8013a44:	61d3      	str	r3, [r2, #28]

	SET_BIT(CAN1->BTR, 24);		// SJW bits (25:24) = 1 --> SJW = tq
 8013a46:	4b2b      	ldr	r3, [pc, #172]	; (8013af4 <CAN_Init+0x18c>)
 8013a48:	69db      	ldr	r3, [r3, #28]
 8013a4a:	4a2a      	ldr	r2, [pc, #168]	; (8013af4 <CAN_Init+0x18c>)
 8013a4c:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8013a50:	61d3      	str	r3, [r2, #28]

//	CLR_BIT(CAN1->MCR, 16);	// no debug freeze
//	SET_BIT(CAN1->MCR, 4);	// no automatic retransmission


	CAN1->FMR &= ~(0x3FUL<<8);	// all filters for CAN1
 8013a52:	4b28      	ldr	r3, [pc, #160]	; (8013af4 <CAN_Init+0x18c>)
 8013a54:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
 8013a58:	4a26      	ldr	r2, [pc, #152]	; (8013af4 <CAN_Init+0x18c>)
 8013a5a:	f423 537c 	bic.w	r3, r3, #16128	; 0x3f00
 8013a5e:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
	CAN1->FMR |=  (14UL<<8);		// all filters for CAN1
 8013a62:	4b24      	ldr	r3, [pc, #144]	; (8013af4 <CAN_Init+0x18c>)
 8013a64:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
 8013a68:	4a22      	ldr	r2, [pc, #136]	; (8013af4 <CAN_Init+0x18c>)
 8013a6a:	f443 6360 	orr.w	r3, r3, #3584	; 0xe00
 8013a6e:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

	SET_BIT(CAN1->MCR, 6);		// Bus-Off is left automatically by hardware
 8013a72:	4b20      	ldr	r3, [pc, #128]	; (8013af4 <CAN_Init+0x18c>)
 8013a74:	681b      	ldr	r3, [r3, #0]
 8013a76:	4a1f      	ldr	r2, [pc, #124]	; (8013af4 <CAN_Init+0x18c>)
 8013a78:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8013a7c:	6013      	str	r3, [r2, #0]

	SET_BIT(CAN1->MCR, 2);		// Tx mailbox priority by first requested
 8013a7e:	4b1d      	ldr	r3, [pc, #116]	; (8013af4 <CAN_Init+0x18c>)
 8013a80:	681b      	ldr	r3, [r3, #0]
 8013a82:	4a1c      	ldr	r2, [pc, #112]	; (8013af4 <CAN_Init+0x18c>)
 8013a84:	f043 0304 	orr.w	r3, r3, #4
 8013a88:	6013      	str	r3, [r2, #0]

	CLR_BIT(CAN1->MCR, 0);		// exit intialization mode
 8013a8a:	4b1a      	ldr	r3, [pc, #104]	; (8013af4 <CAN_Init+0x18c>)
 8013a8c:	681b      	ldr	r3, [r3, #0]
 8013a8e:	4a19      	ldr	r2, [pc, #100]	; (8013af4 <CAN_Init+0x18c>)
 8013a90:	f023 0301 	bic.w	r3, r3, #1
 8013a94:	6013      	str	r3, [r2, #0]
	while(GET_BIT(CAN1->MSR, 0) == 1);		// wait until intialization mode ack
 8013a96:	bf00      	nop
 8013a98:	4b16      	ldr	r3, [pc, #88]	; (8013af4 <CAN_Init+0x18c>)
 8013a9a:	685b      	ldr	r3, [r3, #4]
 8013a9c:	f003 0301 	and.w	r3, r3, #1
 8013aa0:	2b01      	cmp	r3, #1
 8013aa2:	d0f9      	beq.n	8013a98 <CAN_Init+0x130>


	// remap CAN pins, CAN_RX mapped to PB8, CAN_TX mapped to PB9
	SET_BIT(AFIO->MAPR, 14);
 8013aa4:	4b14      	ldr	r3, [pc, #80]	; (8013af8 <CAN_Init+0x190>)
 8013aa6:	685b      	ldr	r3, [r3, #4]
 8013aa8:	4a13      	ldr	r2, [pc, #76]	; (8013af8 <CAN_Init+0x190>)
 8013aaa:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8013aae:	6053      	str	r3, [r2, #4]


	// CAN TX --> PA12 --> Alternate function push-pull
	GPIO_Pin_t  CAN_TxPin = {
 8013ab0:	4b12      	ldr	r3, [pc, #72]	; (8013afc <CAN_Init+0x194>)
 8013ab2:	681b      	ldr	r3, [r3, #0]
 8013ab4:	617b      	str	r3, [r7, #20]
		.port       =  GPIO_PORTB,
		.pinNumber  =  GPIO_PIN9
	};

	GPIO_PinConfg_t  CAN_TxPinConfig = {
 8013ab6:	4b12      	ldr	r3, [pc, #72]	; (8013b00 <CAN_Init+0x198>)
 8013ab8:	881b      	ldrh	r3, [r3, #0]
 8013aba:	823b      	strh	r3, [r7, #16]
		.pinMode      =  ALTERNATE_FUNCTION_OUTPUT_PUSH_PULL,
		.outputSpeed  =  OUTPUT_SPEED_50MHz
	};

	GPIO_InitPins(&CAN_TxPin, &CAN_TxPinConfig);
 8013abc:	f107 0210 	add.w	r2, r7, #16
 8013ac0:	f107 0314 	add.w	r3, r7, #20
 8013ac4:	4611      	mov	r1, r2
 8013ac6:	4618      	mov	r0, r3
 8013ac8:	f000 ff3a 	bl	8014940 <GPIO_InitPins>



	// CAN RX --> PA11 --> Input floating / Input pull-up
	GPIO_Pin_t  CAN_RxPin = {
 8013acc:	4b0d      	ldr	r3, [pc, #52]	; (8013b04 <CAN_Init+0x19c>)
 8013ace:	681b      	ldr	r3, [r3, #0]
 8013ad0:	60fb      	str	r3, [r7, #12]
		.port       =  GPIO_PORTB,
		.pinNumber  =  GPIO_PIN8
	};

	GPIO_PinConfg_t  CAN_RxPinConfig = {
 8013ad2:	4b0d      	ldr	r3, [pc, #52]	; (8013b08 <CAN_Init+0x1a0>)
 8013ad4:	881b      	ldrh	r3, [r3, #0]
 8013ad6:	813b      	strh	r3, [r7, #8]
		.pinMode      =  INPUT_PULL_UP,
		.outputSpeed  =  OUTPUT_SPEED_50MHz
	};

	GPIO_InitPins(&CAN_RxPin, &CAN_RxPinConfig);
 8013ad8:	f107 0208 	add.w	r2, r7, #8
 8013adc:	f107 030c 	add.w	r3, r7, #12
 8013ae0:	4611      	mov	r1, r2
 8013ae2:	4618      	mov	r0, r3
 8013ae4:	f000 ff2c 	bl	8014940 <GPIO_InitPins>
}
 8013ae8:	bf00      	nop
 8013aea:	3718      	adds	r7, #24
 8013aec:	46bd      	mov	sp, r7
 8013aee:	bd80      	pop	{r7, pc}
 8013af0:	2000002c 	.word	0x2000002c
 8013af4:	40006400 	.word	0x40006400
 8013af8:	40010000 	.word	0x40010000
 8013afc:	08014ec0 	.word	0x08014ec0
 8013b00:	08014ec4 	.word	0x08014ec4
 8013b04:	08014ec8 	.word	0x08014ec8
 8013b08:	08014ecc 	.word	0x08014ecc

08013b0c <CAN_InitFilterBank>:



void CAN_InitFilterBank(CAN_RxFilterBankConfig_t*  filterConfig)
{
 8013b0c:	b490      	push	{r4, r7}
 8013b0e:	b082      	sub	sp, #8
 8013b10:	af00      	add	r7, sp, #0
 8013b12:	6078      	str	r0, [r7, #4]
	if((filterConfig->filterBankNum) > 13)
 8013b14:	687b      	ldr	r3, [r7, #4]
 8013b16:	781b      	ldrb	r3, [r3, #0]
 8013b18:	2b0d      	cmp	r3, #13
 8013b1a:	f200 8262 	bhi.w	8013fe2 <CAN_InitFilterBank+0x4d6>
		return;


	SET_BIT(CAN1->FMR, 0);	// enter filter initialization mode
 8013b1e:	4ba9      	ldr	r3, [pc, #676]	; (8013dc4 <CAN_InitFilterBank+0x2b8>)
 8013b20:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
 8013b24:	4aa7      	ldr	r2, [pc, #668]	; (8013dc4 <CAN_InitFilterBank+0x2b8>)
 8013b26:	f043 0301 	orr.w	r3, r3, #1
 8013b2a:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
	CLR_BIT(CAN1->FA1R, filterConfig->filterBankNum);		// deactivate filter
 8013b2e:	4ba5      	ldr	r3, [pc, #660]	; (8013dc4 <CAN_InitFilterBank+0x2b8>)
 8013b30:	f8d3 221c 	ldr.w	r2, [r3, #540]	; 0x21c
 8013b34:	687b      	ldr	r3, [r7, #4]
 8013b36:	781b      	ldrb	r3, [r3, #0]
 8013b38:	4619      	mov	r1, r3
 8013b3a:	2301      	movs	r3, #1
 8013b3c:	408b      	lsls	r3, r1
 8013b3e:	43db      	mvns	r3, r3
 8013b40:	49a0      	ldr	r1, [pc, #640]	; (8013dc4 <CAN_InitFilterBank+0x2b8>)
 8013b42:	4013      	ands	r3, r2
 8013b44:	f8c1 321c 	str.w	r3, [r1, #540]	; 0x21c


	switch(filterConfig->desFifo)
 8013b48:	687b      	ldr	r3, [r7, #4]
 8013b4a:	78db      	ldrb	r3, [r3, #3]
 8013b4c:	2b00      	cmp	r3, #0
 8013b4e:	d002      	beq.n	8013b56 <CAN_InitFilterBank+0x4a>
 8013b50:	2b01      	cmp	r3, #1
 8013b52:	d00e      	beq.n	8013b72 <CAN_InitFilterBank+0x66>
 8013b54:	e01a      	b.n	8013b8c <CAN_InitFilterBank+0x80>
	{
		case FIFO_0:
			CLR_BIT(CAN1->FFA1R, filterConfig->filterBankNum);
 8013b56:	4b9b      	ldr	r3, [pc, #620]	; (8013dc4 <CAN_InitFilterBank+0x2b8>)
 8013b58:	f8d3 2214 	ldr.w	r2, [r3, #532]	; 0x214
 8013b5c:	687b      	ldr	r3, [r7, #4]
 8013b5e:	781b      	ldrb	r3, [r3, #0]
 8013b60:	4619      	mov	r1, r3
 8013b62:	2301      	movs	r3, #1
 8013b64:	408b      	lsls	r3, r1
 8013b66:	43db      	mvns	r3, r3
 8013b68:	4996      	ldr	r1, [pc, #600]	; (8013dc4 <CAN_InitFilterBank+0x2b8>)
 8013b6a:	4013      	ands	r3, r2
 8013b6c:	f8c1 3214 	str.w	r3, [r1, #532]	; 0x214
		break;
 8013b70:	e00c      	b.n	8013b8c <CAN_InitFilterBank+0x80>

		case FIFO_1:
			SET_BIT(CAN1->FFA1R, filterConfig->filterBankNum);
 8013b72:	4b94      	ldr	r3, [pc, #592]	; (8013dc4 <CAN_InitFilterBank+0x2b8>)
 8013b74:	f8d3 2214 	ldr.w	r2, [r3, #532]	; 0x214
 8013b78:	687b      	ldr	r3, [r7, #4]
 8013b7a:	781b      	ldrb	r3, [r3, #0]
 8013b7c:	4619      	mov	r1, r3
 8013b7e:	2301      	movs	r3, #1
 8013b80:	408b      	lsls	r3, r1
 8013b82:	4990      	ldr	r1, [pc, #576]	; (8013dc4 <CAN_InitFilterBank+0x2b8>)
 8013b84:	4313      	orrs	r3, r2
 8013b86:	f8c1 3214 	str.w	r3, [r1, #532]	; 0x214
		break;
 8013b8a:	bf00      	nop
	}


	switch(filterConfig->mode)
 8013b8c:	687b      	ldr	r3, [r7, #4]
 8013b8e:	789b      	ldrb	r3, [r3, #2]
 8013b90:	2b00      	cmp	r3, #0
 8013b92:	f000 8104 	beq.w	8013d9e <CAN_InitFilterBank+0x292>
 8013b96:	2b01      	cmp	r3, #1
 8013b98:	f040 820e 	bne.w	8013fb8 <CAN_InitFilterBank+0x4ac>
	{
		case ID_MASK:
			CLR_BIT(CAN1->FM1R, filterConfig->filterBankNum);	// id mask mode
 8013b9c:	4b89      	ldr	r3, [pc, #548]	; (8013dc4 <CAN_InitFilterBank+0x2b8>)
 8013b9e:	f8d3 2204 	ldr.w	r2, [r3, #516]	; 0x204
 8013ba2:	687b      	ldr	r3, [r7, #4]
 8013ba4:	781b      	ldrb	r3, [r3, #0]
 8013ba6:	4619      	mov	r1, r3
 8013ba8:	2301      	movs	r3, #1
 8013baa:	408b      	lsls	r3, r1
 8013bac:	43db      	mvns	r3, r3
 8013bae:	4985      	ldr	r1, [pc, #532]	; (8013dc4 <CAN_InitFilterBank+0x2b8>)
 8013bb0:	4013      	ands	r3, r2
 8013bb2:	f8c1 3204 	str.w	r3, [r1, #516]	; 0x204

			switch(filterConfig->scale)
 8013bb6:	687b      	ldr	r3, [r7, #4]
 8013bb8:	785b      	ldrb	r3, [r3, #1]
 8013bba:	2b00      	cmp	r3, #0
 8013bbc:	d002      	beq.n	8013bc4 <CAN_InitFilterBank+0xb8>
 8013bbe:	2b01      	cmp	r3, #1
 8013bc0:	d057      	beq.n	8013c72 <CAN_InitFilterBank+0x166>
							);
						break;
					}
				break;
			}
		break;
 8013bc2:	e1f9      	b.n	8013fb8 <CAN_InitFilterBank+0x4ac>
					CLR_BIT(CAN1->FS1R, filterConfig->filterBankNum);	// 16bit scale
 8013bc4:	4b7f      	ldr	r3, [pc, #508]	; (8013dc4 <CAN_InitFilterBank+0x2b8>)
 8013bc6:	f8d3 220c 	ldr.w	r2, [r3, #524]	; 0x20c
 8013bca:	687b      	ldr	r3, [r7, #4]
 8013bcc:	781b      	ldrb	r3, [r3, #0]
 8013bce:	4619      	mov	r1, r3
 8013bd0:	2301      	movs	r3, #1
 8013bd2:	408b      	lsls	r3, r1
 8013bd4:	43db      	mvns	r3, r3
 8013bd6:	497b      	ldr	r1, [pc, #492]	; (8013dc4 <CAN_InitFilterBank+0x2b8>)
 8013bd8:	4013      	ands	r3, r2
 8013bda:	f8c1 320c 	str.w	r3, [r1, #524]	; 0x20c
						(((u32)filterConfig->accepted[0].frameType)<<4)   |  // RTR
 8013bde:	687b      	ldr	r3, [r7, #4]
 8013be0:	7b5b      	ldrb	r3, [r3, #13]
						((0UL)<<3)  |  // standard ID
 8013be2:	011a      	lsls	r2, r3, #4
						(((u32)filterConfig->accepted[0].id)<<5)          |  // ID
 8013be4:	687b      	ldr	r3, [r7, #4]
 8013be6:	685b      	ldr	r3, [r3, #4]
 8013be8:	015b      	lsls	r3, r3, #5
						(((u32)filterConfig->accepted[0].frameType)<<4)   |  // RTR
 8013bea:	4313      	orrs	r3, r2
						(((u32)(!filterConfig->accepted[0].maskIdType))<<19) |  // standard ID
 8013bec:	687a      	ldr	r2, [r7, #4]
 8013bee:	7b92      	ldrb	r2, [r2, #14]
 8013bf0:	2a00      	cmp	r2, #0
 8013bf2:	d102      	bne.n	8013bfa <CAN_InitFilterBank+0xee>
 8013bf4:	f44f 2200 	mov.w	r2, #524288	; 0x80000
 8013bf8:	e000      	b.n	8013bfc <CAN_InitFilterBank+0xf0>
 8013bfa:	2200      	movs	r2, #0
						(((u32)filterConfig->accepted[0].id)<<5)          |  // ID
 8013bfc:	4313      	orrs	r3, r2
						(((u32)(!filterConfig->accepted[0].maskFrameType))<<20)  |  // RTR
 8013bfe:	687a      	ldr	r2, [r7, #4]
 8013c00:	7bd2      	ldrb	r2, [r2, #15]
 8013c02:	2a00      	cmp	r2, #0
 8013c04:	d102      	bne.n	8013c0c <CAN_InitFilterBank+0x100>
 8013c06:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
 8013c0a:	e000      	b.n	8013c0e <CAN_InitFilterBank+0x102>
 8013c0c:	2200      	movs	r2, #0
						(((u32)(!filterConfig->accepted[0].maskIdType))<<19) |  // standard ID
 8013c0e:	431a      	orrs	r2, r3
						(((u32)filterConfig->accepted[0].mask)<<21)       // ID mask
 8013c10:	687b      	ldr	r3, [r7, #4]
 8013c12:	689b      	ldr	r3, [r3, #8]
 8013c14:	055b      	lsls	r3, r3, #21
					CAN1->sFilterRegister[filterConfig->filterBankNum].FR1 = (
 8013c16:	486b      	ldr	r0, [pc, #428]	; (8013dc4 <CAN_InitFilterBank+0x2b8>)
 8013c18:	6879      	ldr	r1, [r7, #4]
 8013c1a:	7809      	ldrb	r1, [r1, #0]
						(((u32)(!filterConfig->accepted[0].maskFrameType))<<20)  |  // RTR
 8013c1c:	431a      	orrs	r2, r3
					CAN1->sFilterRegister[filterConfig->filterBankNum].FR1 = (
 8013c1e:	f101 0348 	add.w	r3, r1, #72	; 0x48
 8013c22:	f840 2033 	str.w	r2, [r0, r3, lsl #3]
						(((u32)filterConfig->accepted[1].frameType)<<4)  |  // RTR
 8013c26:	687b      	ldr	r3, [r7, #4]
 8013c28:	7e5b      	ldrb	r3, [r3, #25]
						((0UL)<<3)  |  // standard ID
 8013c2a:	011a      	lsls	r2, r3, #4
						(((u32)filterConfig->accepted[1].id)<<5)    |   // ID
 8013c2c:	687b      	ldr	r3, [r7, #4]
 8013c2e:	691b      	ldr	r3, [r3, #16]
 8013c30:	015b      	lsls	r3, r3, #5
						(((u32)filterConfig->accepted[1].frameType)<<4)  |  // RTR
 8013c32:	4313      	orrs	r3, r2
						(((u32)(!filterConfig->accepted[1].maskIdType))<<19)  |  // standard ID
 8013c34:	687a      	ldr	r2, [r7, #4]
 8013c36:	7e92      	ldrb	r2, [r2, #26]
 8013c38:	2a00      	cmp	r2, #0
 8013c3a:	d102      	bne.n	8013c42 <CAN_InitFilterBank+0x136>
 8013c3c:	f44f 2200 	mov.w	r2, #524288	; 0x80000
 8013c40:	e000      	b.n	8013c44 <CAN_InitFilterBank+0x138>
 8013c42:	2200      	movs	r2, #0
						(((u32)filterConfig->accepted[1].id)<<5)    |   // ID
 8013c44:	4313      	orrs	r3, r2
						(((u32)(!filterConfig->accepted[1].maskFrameType))<<20)  |  // RTR
 8013c46:	687a      	ldr	r2, [r7, #4]
 8013c48:	7ed2      	ldrb	r2, [r2, #27]
 8013c4a:	2a00      	cmp	r2, #0
 8013c4c:	d102      	bne.n	8013c54 <CAN_InitFilterBank+0x148>
 8013c4e:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
 8013c52:	e000      	b.n	8013c56 <CAN_InitFilterBank+0x14a>
 8013c54:	2200      	movs	r2, #0
						(((u32)(!filterConfig->accepted[1].maskIdType))<<19)  |  // standard ID
 8013c56:	431a      	orrs	r2, r3
						(((u32)filterConfig->accepted[1].mask)<<21)       // ID mask
 8013c58:	687b      	ldr	r3, [r7, #4]
 8013c5a:	695b      	ldr	r3, [r3, #20]
 8013c5c:	055b      	lsls	r3, r3, #21
					CAN1->sFilterRegister[filterConfig->filterBankNum].FR2 = (
 8013c5e:	4859      	ldr	r0, [pc, #356]	; (8013dc4 <CAN_InitFilterBank+0x2b8>)
 8013c60:	6879      	ldr	r1, [r7, #4]
 8013c62:	7809      	ldrb	r1, [r1, #0]
						(((u32)(!filterConfig->accepted[1].maskFrameType))<<20)  |  // RTR
 8013c64:	431a      	orrs	r2, r3
					CAN1->sFilterRegister[filterConfig->filterBankNum].FR2 = (
 8013c66:	f101 0348 	add.w	r3, r1, #72	; 0x48
 8013c6a:	00db      	lsls	r3, r3, #3
 8013c6c:	4403      	add	r3, r0
 8013c6e:	605a      	str	r2, [r3, #4]
				break;
 8013c70:	e094      	b.n	8013d9c <CAN_InitFilterBank+0x290>
					SET_BIT(CAN1->FS1R, filterConfig->filterBankNum);	// 32bit scale
 8013c72:	4b54      	ldr	r3, [pc, #336]	; (8013dc4 <CAN_InitFilterBank+0x2b8>)
 8013c74:	f8d3 220c 	ldr.w	r2, [r3, #524]	; 0x20c
 8013c78:	687b      	ldr	r3, [r7, #4]
 8013c7a:	781b      	ldrb	r3, [r3, #0]
 8013c7c:	4619      	mov	r1, r3
 8013c7e:	2301      	movs	r3, #1
 8013c80:	408b      	lsls	r3, r1
 8013c82:	4950      	ldr	r1, [pc, #320]	; (8013dc4 <CAN_InitFilterBank+0x2b8>)
 8013c84:	4313      	orrs	r3, r2
 8013c86:	f8c1 320c 	str.w	r3, [r1, #524]	; 0x20c
						(((u32)filterConfig->accepted[0].frameType)<<1)  |  // RTR
 8013c8a:	687b      	ldr	r3, [r7, #4]
 8013c8c:	7b5b      	ldrb	r3, [r3, #13]
 8013c8e:	005a      	lsls	r2, r3, #1
						(((u32)filterConfig->accepted[0].idType)<<2)     |  // IDE
 8013c90:	687b      	ldr	r3, [r7, #4]
 8013c92:	7b1b      	ldrb	r3, [r3, #12]
 8013c94:	009b      	lsls	r3, r3, #2
						(((u32)filterConfig->accepted[0].frameType)<<1)  |  // RTR
 8013c96:	4313      	orrs	r3, r2
					CAN1->sFilterRegister[filterConfig->filterBankNum].FR1 = (
 8013c98:	494a      	ldr	r1, [pc, #296]	; (8013dc4 <CAN_InitFilterBank+0x2b8>)
 8013c9a:	687a      	ldr	r2, [r7, #4]
 8013c9c:	7812      	ldrb	r2, [r2, #0]
 8013c9e:	4610      	mov	r0, r2
						(((u32)filterConfig->accepted[0].idType)<<2)     |  // IDE
 8013ca0:	f063 023f 	orn	r2, r3, #63	; 0x3f
					CAN1->sFilterRegister[filterConfig->filterBankNum].FR1 = (
 8013ca4:	f100 0348 	add.w	r3, r0, #72	; 0x48
 8013ca8:	f841 2033 	str.w	r2, [r1, r3, lsl #3]
						(((u32)(!filterConfig->accepted[0].maskFrameType))<<1)  |  // RTR
 8013cac:	687b      	ldr	r3, [r7, #4]
 8013cae:	7bdb      	ldrb	r3, [r3, #15]
 8013cb0:	2b00      	cmp	r3, #0
 8013cb2:	d101      	bne.n	8013cb8 <CAN_InitFilterBank+0x1ac>
 8013cb4:	2202      	movs	r2, #2
 8013cb6:	e000      	b.n	8013cba <CAN_InitFilterBank+0x1ae>
 8013cb8:	2200      	movs	r2, #0
						(((u32)(!filterConfig->accepted[0].maskIdType))<<2)     |  // IDE
 8013cba:	687b      	ldr	r3, [r7, #4]
 8013cbc:	7b9b      	ldrb	r3, [r3, #14]
 8013cbe:	2b00      	cmp	r3, #0
 8013cc0:	d101      	bne.n	8013cc6 <CAN_InitFilterBank+0x1ba>
 8013cc2:	2304      	movs	r3, #4
 8013cc4:	e000      	b.n	8013cc8 <CAN_InitFilterBank+0x1bc>
 8013cc6:	2300      	movs	r3, #0
						(((u32)(!filterConfig->accepted[0].maskFrameType))<<1)  |  // RTR
 8013cc8:	4313      	orrs	r3, r2
					CAN1->sFilterRegister[filterConfig->filterBankNum].FR2 = (
 8013cca:	493e      	ldr	r1, [pc, #248]	; (8013dc4 <CAN_InitFilterBank+0x2b8>)
 8013ccc:	687a      	ldr	r2, [r7, #4]
 8013cce:	7812      	ldrb	r2, [r2, #0]
 8013cd0:	4610      	mov	r0, r2
						(((u32)(!filterConfig->accepted[0].maskIdType))<<2)     |  // IDE
 8013cd2:	f063 023f 	orn	r2, r3, #63	; 0x3f
					CAN1->sFilterRegister[filterConfig->filterBankNum].FR2 = (
 8013cd6:	f100 0348 	add.w	r3, r0, #72	; 0x48
 8013cda:	00db      	lsls	r3, r3, #3
 8013cdc:	440b      	add	r3, r1
 8013cde:	605a      	str	r2, [r3, #4]
					switch(filterConfig->accepted[0].idType)
 8013ce0:	687b      	ldr	r3, [r7, #4]
 8013ce2:	7b1b      	ldrb	r3, [r3, #12]
 8013ce4:	2b00      	cmp	r3, #0
 8013ce6:	d002      	beq.n	8013cee <CAN_InitFilterBank+0x1e2>
 8013ce8:	2b01      	cmp	r3, #1
 8013cea:	d02d      	beq.n	8013d48 <CAN_InitFilterBank+0x23c>
				break;
 8013cec:	e055      	b.n	8013d9a <CAN_InitFilterBank+0x28e>
							CAN1->sFilterRegister[filterConfig->filterBankNum].FR1 &= (
 8013cee:	4a35      	ldr	r2, [pc, #212]	; (8013dc4 <CAN_InitFilterBank+0x2b8>)
 8013cf0:	687b      	ldr	r3, [r7, #4]
 8013cf2:	781b      	ldrb	r3, [r3, #0]
 8013cf4:	3348      	adds	r3, #72	; 0x48
 8013cf6:	f852 2033 	ldr.w	r2, [r2, r3, lsl #3]
								((filterConfig->accepted[0].id)<<21)    |  // standard  ID
 8013cfa:	687b      	ldr	r3, [r7, #4]
 8013cfc:	685b      	ldr	r3, [r3, #4]
 8013cfe:	055b      	lsls	r3, r3, #21
 8013d00:	ea6f 5353 	mvn.w	r3, r3, lsr #21
 8013d04:	ea6f 5343 	mvn.w	r3, r3, lsl #21
							CAN1->sFilterRegister[filterConfig->filterBankNum].FR1 &= (
 8013d08:	482e      	ldr	r0, [pc, #184]	; (8013dc4 <CAN_InitFilterBank+0x2b8>)
 8013d0a:	6879      	ldr	r1, [r7, #4]
 8013d0c:	7809      	ldrb	r1, [r1, #0]
 8013d0e:	401a      	ands	r2, r3
 8013d10:	f101 0348 	add.w	r3, r1, #72	; 0x48
 8013d14:	f840 2033 	str.w	r2, [r0, r3, lsl #3]
							CAN1->sFilterRegister[filterConfig->filterBankNum].FR2 &= (
 8013d18:	4a2a      	ldr	r2, [pc, #168]	; (8013dc4 <CAN_InitFilterBank+0x2b8>)
 8013d1a:	687b      	ldr	r3, [r7, #4]
 8013d1c:	781b      	ldrb	r3, [r3, #0]
 8013d1e:	3348      	adds	r3, #72	; 0x48
 8013d20:	00db      	lsls	r3, r3, #3
 8013d22:	4413      	add	r3, r2
 8013d24:	685a      	ldr	r2, [r3, #4]
								((filterConfig->accepted[0].mask)<<21)    |  // standard  ID
 8013d26:	687b      	ldr	r3, [r7, #4]
 8013d28:	689b      	ldr	r3, [r3, #8]
 8013d2a:	055b      	lsls	r3, r3, #21
 8013d2c:	ea6f 5353 	mvn.w	r3, r3, lsr #21
 8013d30:	ea6f 5343 	mvn.w	r3, r3, lsl #21
							CAN1->sFilterRegister[filterConfig->filterBankNum].FR2 &= (
 8013d34:	4823      	ldr	r0, [pc, #140]	; (8013dc4 <CAN_InitFilterBank+0x2b8>)
 8013d36:	6879      	ldr	r1, [r7, #4]
 8013d38:	7809      	ldrb	r1, [r1, #0]
 8013d3a:	401a      	ands	r2, r3
 8013d3c:	f101 0348 	add.w	r3, r1, #72	; 0x48
 8013d40:	00db      	lsls	r3, r3, #3
 8013d42:	4403      	add	r3, r0
 8013d44:	605a      	str	r2, [r3, #4]
						break;
 8013d46:	e028      	b.n	8013d9a <CAN_InitFilterBank+0x28e>
							CAN1->sFilterRegister[filterConfig->filterBankNum].FR1 &= (
 8013d48:	4a1e      	ldr	r2, [pc, #120]	; (8013dc4 <CAN_InitFilterBank+0x2b8>)
 8013d4a:	687b      	ldr	r3, [r7, #4]
 8013d4c:	781b      	ldrb	r3, [r3, #0]
 8013d4e:	3348      	adds	r3, #72	; 0x48
 8013d50:	f852 2033 	ldr.w	r2, [r2, r3, lsl #3]
								(((u32)filterConfig->accepted[0].id)<<3)   |   // extended ID
 8013d54:	687b      	ldr	r3, [r7, #4]
 8013d56:	685b      	ldr	r3, [r3, #4]
 8013d58:	00db      	lsls	r3, r3, #3
 8013d5a:	f043 0307 	orr.w	r3, r3, #7
							CAN1->sFilterRegister[filterConfig->filterBankNum].FR1 &= (
 8013d5e:	4819      	ldr	r0, [pc, #100]	; (8013dc4 <CAN_InitFilterBank+0x2b8>)
 8013d60:	6879      	ldr	r1, [r7, #4]
 8013d62:	7809      	ldrb	r1, [r1, #0]
 8013d64:	401a      	ands	r2, r3
 8013d66:	f101 0348 	add.w	r3, r1, #72	; 0x48
 8013d6a:	f840 2033 	str.w	r2, [r0, r3, lsl #3]
							CAN1->sFilterRegister[filterConfig->filterBankNum].FR2 &= (
 8013d6e:	4a15      	ldr	r2, [pc, #84]	; (8013dc4 <CAN_InitFilterBank+0x2b8>)
 8013d70:	687b      	ldr	r3, [r7, #4]
 8013d72:	781b      	ldrb	r3, [r3, #0]
 8013d74:	3348      	adds	r3, #72	; 0x48
 8013d76:	00db      	lsls	r3, r3, #3
 8013d78:	4413      	add	r3, r2
 8013d7a:	685a      	ldr	r2, [r3, #4]
								(((u32)filterConfig->accepted[0].mask)<<3)     |  // extended ID
 8013d7c:	687b      	ldr	r3, [r7, #4]
 8013d7e:	689b      	ldr	r3, [r3, #8]
 8013d80:	00db      	lsls	r3, r3, #3
 8013d82:	f043 0307 	orr.w	r3, r3, #7
							CAN1->sFilterRegister[filterConfig->filterBankNum].FR2 &= (
 8013d86:	480f      	ldr	r0, [pc, #60]	; (8013dc4 <CAN_InitFilterBank+0x2b8>)
 8013d88:	6879      	ldr	r1, [r7, #4]
 8013d8a:	7809      	ldrb	r1, [r1, #0]
 8013d8c:	401a      	ands	r2, r3
 8013d8e:	f101 0348 	add.w	r3, r1, #72	; 0x48
 8013d92:	00db      	lsls	r3, r3, #3
 8013d94:	4403      	add	r3, r0
 8013d96:	605a      	str	r2, [r3, #4]
						break;
 8013d98:	bf00      	nop
				break;
 8013d9a:	bf00      	nop
		break;
 8013d9c:	e10c      	b.n	8013fb8 <CAN_InitFilterBank+0x4ac>

		case ID_LIST:
			SET_BIT(CAN1->FM1R, filterConfig->filterBankNum);
 8013d9e:	4b09      	ldr	r3, [pc, #36]	; (8013dc4 <CAN_InitFilterBank+0x2b8>)
 8013da0:	f8d3 2204 	ldr.w	r2, [r3, #516]	; 0x204
 8013da4:	687b      	ldr	r3, [r7, #4]
 8013da6:	781b      	ldrb	r3, [r3, #0]
 8013da8:	4619      	mov	r1, r3
 8013daa:	2301      	movs	r3, #1
 8013dac:	408b      	lsls	r3, r1
 8013dae:	4905      	ldr	r1, [pc, #20]	; (8013dc4 <CAN_InitFilterBank+0x2b8>)
 8013db0:	4313      	orrs	r3, r2
 8013db2:	f8c1 3204 	str.w	r3, [r1, #516]	; 0x204

			switch(filterConfig->scale)
 8013db6:	687b      	ldr	r3, [r7, #4]
 8013db8:	785b      	ldrb	r3, [r3, #1]
 8013dba:	2b00      	cmp	r3, #0
 8013dbc:	d004      	beq.n	8013dc8 <CAN_InitFilterBank+0x2bc>
 8013dbe:	2b01      	cmp	r3, #1
 8013dc0:	d075      	beq.n	8013eae <CAN_InitFilterBank+0x3a2>
							);
						break;
					}
				break;
			}
		break;
 8013dc2:	e0f8      	b.n	8013fb6 <CAN_InitFilterBank+0x4aa>
 8013dc4:	40006400 	.word	0x40006400
					CLR_BIT(CAN1->FS1R, filterConfig->filterBankNum);	// 16bit scale
 8013dc8:	4b88      	ldr	r3, [pc, #544]	; (8013fec <CAN_InitFilterBank+0x4e0>)
 8013dca:	f8d3 220c 	ldr.w	r2, [r3, #524]	; 0x20c
 8013dce:	687b      	ldr	r3, [r7, #4]
 8013dd0:	781b      	ldrb	r3, [r3, #0]
 8013dd2:	4619      	mov	r1, r3
 8013dd4:	2301      	movs	r3, #1
 8013dd6:	408b      	lsls	r3, r1
 8013dd8:	43db      	mvns	r3, r3
 8013dda:	4984      	ldr	r1, [pc, #528]	; (8013fec <CAN_InitFilterBank+0x4e0>)
 8013ddc:	4013      	ands	r3, r2
 8013dde:	f8c1 320c 	str.w	r3, [r1, #524]	; 0x20c
						((filterConfig->accepted[0].idType)<<3)  |  // standard ID
 8013de2:	687b      	ldr	r3, [r7, #4]
 8013de4:	7b1b      	ldrb	r3, [r3, #12]
 8013de6:	00da      	lsls	r2, r3, #3
						((filterConfig->accepted[0].frameType)<<4)  |  // RTR
 8013de8:	687b      	ldr	r3, [r7, #4]
 8013dea:	7b5b      	ldrb	r3, [r3, #13]
 8013dec:	011b      	lsls	r3, r3, #4
						((filterConfig->accepted[0].idType)<<3)  |  // standard ID
 8013dee:	4313      	orrs	r3, r2
 8013df0:	461c      	mov	r4, r3
						((filterConfig->accepted[0].id)<<5)    // ID
 8013df2:	687b      	ldr	r3, [r7, #4]
 8013df4:	685b      	ldr	r3, [r3, #4]
 8013df6:	015b      	lsls	r3, r3, #5
					CAN1->sFilterRegister[filterConfig->filterBankNum].FR1 = (
 8013df8:	497c      	ldr	r1, [pc, #496]	; (8013fec <CAN_InitFilterBank+0x4e0>)
 8013dfa:	687a      	ldr	r2, [r7, #4]
 8013dfc:	7812      	ldrb	r2, [r2, #0]
 8013dfe:	4610      	mov	r0, r2
						((filterConfig->accepted[0].frameType)<<4)  |  // RTR
 8013e00:	ea44 0203 	orr.w	r2, r4, r3
					CAN1->sFilterRegister[filterConfig->filterBankNum].FR1 = (
 8013e04:	f100 0348 	add.w	r3, r0, #72	; 0x48
 8013e08:	f841 2033 	str.w	r2, [r1, r3, lsl #3]
					CAN1->sFilterRegister[filterConfig->filterBankNum].FR1 |= (
 8013e0c:	4a77      	ldr	r2, [pc, #476]	; (8013fec <CAN_InitFilterBank+0x4e0>)
 8013e0e:	687b      	ldr	r3, [r7, #4]
 8013e10:	781b      	ldrb	r3, [r3, #0]
 8013e12:	3348      	adds	r3, #72	; 0x48
 8013e14:	f852 2033 	ldr.w	r2, [r2, r3, lsl #3]
						((filterConfig->accepted[1].idType)<<19)  |  // standard ID
 8013e18:	687b      	ldr	r3, [r7, #4]
 8013e1a:	7e1b      	ldrb	r3, [r3, #24]
 8013e1c:	04d9      	lsls	r1, r3, #19
						((filterConfig->accepted[1].frameType)<<20)  |  // RTR
 8013e1e:	687b      	ldr	r3, [r7, #4]
 8013e20:	7e5b      	ldrb	r3, [r3, #25]
 8013e22:	051b      	lsls	r3, r3, #20
						((filterConfig->accepted[1].idType)<<19)  |  // standard ID
 8013e24:	430b      	orrs	r3, r1
 8013e26:	4619      	mov	r1, r3
						((filterConfig->accepted[1].id)<<21)    // ID
 8013e28:	687b      	ldr	r3, [r7, #4]
 8013e2a:	691b      	ldr	r3, [r3, #16]
 8013e2c:	055b      	lsls	r3, r3, #21
						((filterConfig->accepted[1].frameType)<<20)  |  // RTR
 8013e2e:	430b      	orrs	r3, r1
					CAN1->sFilterRegister[filterConfig->filterBankNum].FR1 |= (
 8013e30:	486e      	ldr	r0, [pc, #440]	; (8013fec <CAN_InitFilterBank+0x4e0>)
 8013e32:	6879      	ldr	r1, [r7, #4]
 8013e34:	7809      	ldrb	r1, [r1, #0]
 8013e36:	431a      	orrs	r2, r3
 8013e38:	f101 0348 	add.w	r3, r1, #72	; 0x48
 8013e3c:	f840 2033 	str.w	r2, [r0, r3, lsl #3]
						((filterConfig->accepted[2].idType)<<3)  |  // standard ID
 8013e40:	687b      	ldr	r3, [r7, #4]
 8013e42:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 8013e46:	00da      	lsls	r2, r3, #3
						((filterConfig->accepted[2].frameType)<<4)  |  // RTR
 8013e48:	687b      	ldr	r3, [r7, #4]
 8013e4a:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
 8013e4e:	011b      	lsls	r3, r3, #4
						((filterConfig->accepted[2].idType)<<3)  |  // standard ID
 8013e50:	4313      	orrs	r3, r2
 8013e52:	461c      	mov	r4, r3
						((filterConfig->accepted[2].id)<<5)    // ID
 8013e54:	687b      	ldr	r3, [r7, #4]
 8013e56:	69db      	ldr	r3, [r3, #28]
 8013e58:	015b      	lsls	r3, r3, #5
					CAN1->sFilterRegister[filterConfig->filterBankNum].FR2 = (
 8013e5a:	4964      	ldr	r1, [pc, #400]	; (8013fec <CAN_InitFilterBank+0x4e0>)
 8013e5c:	687a      	ldr	r2, [r7, #4]
 8013e5e:	7812      	ldrb	r2, [r2, #0]
 8013e60:	4610      	mov	r0, r2
						((filterConfig->accepted[2].frameType)<<4)  |  // RTR
 8013e62:	ea44 0203 	orr.w	r2, r4, r3
					CAN1->sFilterRegister[filterConfig->filterBankNum].FR2 = (
 8013e66:	f100 0348 	add.w	r3, r0, #72	; 0x48
 8013e6a:	00db      	lsls	r3, r3, #3
 8013e6c:	440b      	add	r3, r1
 8013e6e:	605a      	str	r2, [r3, #4]
					CAN1->sFilterRegister[filterConfig->filterBankNum].FR2 |= (
 8013e70:	4a5e      	ldr	r2, [pc, #376]	; (8013fec <CAN_InitFilterBank+0x4e0>)
 8013e72:	687b      	ldr	r3, [r7, #4]
 8013e74:	781b      	ldrb	r3, [r3, #0]
 8013e76:	3348      	adds	r3, #72	; 0x48
 8013e78:	00db      	lsls	r3, r3, #3
 8013e7a:	4413      	add	r3, r2
 8013e7c:	685a      	ldr	r2, [r3, #4]
						((filterConfig->accepted[3].idType)<<19)  |  // standard ID
 8013e7e:	687b      	ldr	r3, [r7, #4]
 8013e80:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 8013e84:	04d9      	lsls	r1, r3, #19
						((filterConfig->accepted[3].frameType)<<20)  |  // RTR
 8013e86:	687b      	ldr	r3, [r7, #4]
 8013e88:	f893 3031 	ldrb.w	r3, [r3, #49]	; 0x31
 8013e8c:	051b      	lsls	r3, r3, #20
						((filterConfig->accepted[3].idType)<<19)  |  // standard ID
 8013e8e:	430b      	orrs	r3, r1
 8013e90:	4619      	mov	r1, r3
						((filterConfig->accepted[3].id)<<21)    // ID
 8013e92:	687b      	ldr	r3, [r7, #4]
 8013e94:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8013e96:	055b      	lsls	r3, r3, #21
						((filterConfig->accepted[3].frameType)<<20)  |  // RTR
 8013e98:	430b      	orrs	r3, r1
					CAN1->sFilterRegister[filterConfig->filterBankNum].FR2 |= (
 8013e9a:	4854      	ldr	r0, [pc, #336]	; (8013fec <CAN_InitFilterBank+0x4e0>)
 8013e9c:	6879      	ldr	r1, [r7, #4]
 8013e9e:	7809      	ldrb	r1, [r1, #0]
 8013ea0:	431a      	orrs	r2, r3
 8013ea2:	f101 0348 	add.w	r3, r1, #72	; 0x48
 8013ea6:	00db      	lsls	r3, r3, #3
 8013ea8:	4403      	add	r3, r0
 8013eaa:	605a      	str	r2, [r3, #4]
				break;
 8013eac:	e083      	b.n	8013fb6 <CAN_InitFilterBank+0x4aa>
					SET_BIT(CAN1->FS1R, filterConfig->filterBankNum);	// 32bit scale
 8013eae:	4b4f      	ldr	r3, [pc, #316]	; (8013fec <CAN_InitFilterBank+0x4e0>)
 8013eb0:	f8d3 220c 	ldr.w	r2, [r3, #524]	; 0x20c
 8013eb4:	687b      	ldr	r3, [r7, #4]
 8013eb6:	781b      	ldrb	r3, [r3, #0]
 8013eb8:	4619      	mov	r1, r3
 8013eba:	2301      	movs	r3, #1
 8013ebc:	408b      	lsls	r3, r1
 8013ebe:	494b      	ldr	r1, [pc, #300]	; (8013fec <CAN_InitFilterBank+0x4e0>)
 8013ec0:	4313      	orrs	r3, r2
 8013ec2:	f8c1 320c 	str.w	r3, [r1, #524]	; 0x20c
						((u32)(filterConfig->accepted[0].frameType)<<1)  |  // RTR
 8013ec6:	687b      	ldr	r3, [r7, #4]
 8013ec8:	7b5b      	ldrb	r3, [r3, #13]
 8013eca:	005a      	lsls	r2, r3, #1
						((u32)(filterConfig->accepted[0].idType)<<2)    // IDE
 8013ecc:	687b      	ldr	r3, [r7, #4]
 8013ece:	7b1b      	ldrb	r3, [r3, #12]
 8013ed0:	009b      	lsls	r3, r3, #2
					CAN1->sFilterRegister[filterConfig->filterBankNum].FR1 = (
 8013ed2:	4846      	ldr	r0, [pc, #280]	; (8013fec <CAN_InitFilterBank+0x4e0>)
 8013ed4:	6879      	ldr	r1, [r7, #4]
 8013ed6:	7809      	ldrb	r1, [r1, #0]
						((u32)(filterConfig->accepted[0].frameType)<<1)  |  // RTR
 8013ed8:	431a      	orrs	r2, r3
					CAN1->sFilterRegister[filterConfig->filterBankNum].FR1 = (
 8013eda:	f101 0348 	add.w	r3, r1, #72	; 0x48
 8013ede:	f840 2033 	str.w	r2, [r0, r3, lsl #3]
					switch(filterConfig->accepted[0].idType)
 8013ee2:	687b      	ldr	r3, [r7, #4]
 8013ee4:	7b1b      	ldrb	r3, [r3, #12]
 8013ee6:	2b00      	cmp	r3, #0
 8013ee8:	d002      	beq.n	8013ef0 <CAN_InitFilterBank+0x3e4>
 8013eea:	2b01      	cmp	r3, #1
 8013eec:	d012      	beq.n	8013f14 <CAN_InitFilterBank+0x408>
 8013eee:	e023      	b.n	8013f38 <CAN_InitFilterBank+0x42c>
							CAN1->sFilterRegister[filterConfig->filterBankNum].FR1 |= (
 8013ef0:	4a3e      	ldr	r2, [pc, #248]	; (8013fec <CAN_InitFilterBank+0x4e0>)
 8013ef2:	687b      	ldr	r3, [r7, #4]
 8013ef4:	781b      	ldrb	r3, [r3, #0]
 8013ef6:	3348      	adds	r3, #72	; 0x48
 8013ef8:	f852 2033 	ldr.w	r2, [r2, r3, lsl #3]
								((u32)(filterConfig->accepted[0].id)<<21)    // ID
 8013efc:	687b      	ldr	r3, [r7, #4]
 8013efe:	685b      	ldr	r3, [r3, #4]
 8013f00:	055b      	lsls	r3, r3, #21
							CAN1->sFilterRegister[filterConfig->filterBankNum].FR1 |= (
 8013f02:	483a      	ldr	r0, [pc, #232]	; (8013fec <CAN_InitFilterBank+0x4e0>)
 8013f04:	6879      	ldr	r1, [r7, #4]
 8013f06:	7809      	ldrb	r1, [r1, #0]
 8013f08:	431a      	orrs	r2, r3
 8013f0a:	f101 0348 	add.w	r3, r1, #72	; 0x48
 8013f0e:	f840 2033 	str.w	r2, [r0, r3, lsl #3]
						break;
 8013f12:	e011      	b.n	8013f38 <CAN_InitFilterBank+0x42c>
							CAN1->sFilterRegister[filterConfig->filterBankNum].FR1 |= (
 8013f14:	4a35      	ldr	r2, [pc, #212]	; (8013fec <CAN_InitFilterBank+0x4e0>)
 8013f16:	687b      	ldr	r3, [r7, #4]
 8013f18:	781b      	ldrb	r3, [r3, #0]
 8013f1a:	3348      	adds	r3, #72	; 0x48
 8013f1c:	f852 2033 	ldr.w	r2, [r2, r3, lsl #3]
								((u32)(filterConfig->accepted[0].id)<<3)    // ID
 8013f20:	687b      	ldr	r3, [r7, #4]
 8013f22:	685b      	ldr	r3, [r3, #4]
 8013f24:	00db      	lsls	r3, r3, #3
							CAN1->sFilterRegister[filterConfig->filterBankNum].FR1 |= (
 8013f26:	4831      	ldr	r0, [pc, #196]	; (8013fec <CAN_InitFilterBank+0x4e0>)
 8013f28:	6879      	ldr	r1, [r7, #4]
 8013f2a:	7809      	ldrb	r1, [r1, #0]
 8013f2c:	431a      	orrs	r2, r3
 8013f2e:	f101 0348 	add.w	r3, r1, #72	; 0x48
 8013f32:	f840 2033 	str.w	r2, [r0, r3, lsl #3]
						break;
 8013f36:	bf00      	nop
						((u32)(filterConfig->accepted[1].frameType)<<1)  |  // RTR
 8013f38:	687b      	ldr	r3, [r7, #4]
 8013f3a:	7e5b      	ldrb	r3, [r3, #25]
 8013f3c:	005a      	lsls	r2, r3, #1
						((u32)(filterConfig->accepted[1].idType)<<2)    // IDE
 8013f3e:	687b      	ldr	r3, [r7, #4]
 8013f40:	7e1b      	ldrb	r3, [r3, #24]
 8013f42:	009b      	lsls	r3, r3, #2
					CAN1->sFilterRegister[filterConfig->filterBankNum].FR2 = (
 8013f44:	4829      	ldr	r0, [pc, #164]	; (8013fec <CAN_InitFilterBank+0x4e0>)
 8013f46:	6879      	ldr	r1, [r7, #4]
 8013f48:	7809      	ldrb	r1, [r1, #0]
						((u32)(filterConfig->accepted[1].frameType)<<1)  |  // RTR
 8013f4a:	431a      	orrs	r2, r3
					CAN1->sFilterRegister[filterConfig->filterBankNum].FR2 = (
 8013f4c:	f101 0348 	add.w	r3, r1, #72	; 0x48
 8013f50:	00db      	lsls	r3, r3, #3
 8013f52:	4403      	add	r3, r0
 8013f54:	605a      	str	r2, [r3, #4]
					switch(filterConfig->accepted[1].idType)
 8013f56:	687b      	ldr	r3, [r7, #4]
 8013f58:	7e1b      	ldrb	r3, [r3, #24]
 8013f5a:	2b00      	cmp	r3, #0
 8013f5c:	d002      	beq.n	8013f64 <CAN_InitFilterBank+0x458>
 8013f5e:	2b01      	cmp	r3, #1
 8013f60:	d014      	beq.n	8013f8c <CAN_InitFilterBank+0x480>
				break;
 8013f62:	e027      	b.n	8013fb4 <CAN_InitFilterBank+0x4a8>
							CAN1->sFilterRegister[filterConfig->filterBankNum].FR2 |= (
 8013f64:	4a21      	ldr	r2, [pc, #132]	; (8013fec <CAN_InitFilterBank+0x4e0>)
 8013f66:	687b      	ldr	r3, [r7, #4]
 8013f68:	781b      	ldrb	r3, [r3, #0]
 8013f6a:	3348      	adds	r3, #72	; 0x48
 8013f6c:	00db      	lsls	r3, r3, #3
 8013f6e:	4413      	add	r3, r2
 8013f70:	685a      	ldr	r2, [r3, #4]
								((u32)(filterConfig->accepted[1].id)<<21)    // ID
 8013f72:	687b      	ldr	r3, [r7, #4]
 8013f74:	691b      	ldr	r3, [r3, #16]
 8013f76:	055b      	lsls	r3, r3, #21
							CAN1->sFilterRegister[filterConfig->filterBankNum].FR2 |= (
 8013f78:	481c      	ldr	r0, [pc, #112]	; (8013fec <CAN_InitFilterBank+0x4e0>)
 8013f7a:	6879      	ldr	r1, [r7, #4]
 8013f7c:	7809      	ldrb	r1, [r1, #0]
 8013f7e:	431a      	orrs	r2, r3
 8013f80:	f101 0348 	add.w	r3, r1, #72	; 0x48
 8013f84:	00db      	lsls	r3, r3, #3
 8013f86:	4403      	add	r3, r0
 8013f88:	605a      	str	r2, [r3, #4]
						break;
 8013f8a:	e013      	b.n	8013fb4 <CAN_InitFilterBank+0x4a8>
							CAN1->sFilterRegister[filterConfig->filterBankNum].FR2 |= (
 8013f8c:	4a17      	ldr	r2, [pc, #92]	; (8013fec <CAN_InitFilterBank+0x4e0>)
 8013f8e:	687b      	ldr	r3, [r7, #4]
 8013f90:	781b      	ldrb	r3, [r3, #0]
 8013f92:	3348      	adds	r3, #72	; 0x48
 8013f94:	00db      	lsls	r3, r3, #3
 8013f96:	4413      	add	r3, r2
 8013f98:	685a      	ldr	r2, [r3, #4]
								((u32)(filterConfig->accepted[1].id)<<3)    // ID
 8013f9a:	687b      	ldr	r3, [r7, #4]
 8013f9c:	691b      	ldr	r3, [r3, #16]
 8013f9e:	00db      	lsls	r3, r3, #3
							CAN1->sFilterRegister[filterConfig->filterBankNum].FR2 |= (
 8013fa0:	4812      	ldr	r0, [pc, #72]	; (8013fec <CAN_InitFilterBank+0x4e0>)
 8013fa2:	6879      	ldr	r1, [r7, #4]
 8013fa4:	7809      	ldrb	r1, [r1, #0]
 8013fa6:	431a      	orrs	r2, r3
 8013fa8:	f101 0348 	add.w	r3, r1, #72	; 0x48
 8013fac:	00db      	lsls	r3, r3, #3
 8013fae:	4403      	add	r3, r0
 8013fb0:	605a      	str	r2, [r3, #4]
						break;
 8013fb2:	bf00      	nop
				break;
 8013fb4:	bf00      	nop
		break;
 8013fb6:	bf00      	nop
	}



	SET_BIT(CAN1->FA1R, filterConfig->filterBankNum);		// activate filter
 8013fb8:	4b0c      	ldr	r3, [pc, #48]	; (8013fec <CAN_InitFilterBank+0x4e0>)
 8013fba:	f8d3 221c 	ldr.w	r2, [r3, #540]	; 0x21c
 8013fbe:	687b      	ldr	r3, [r7, #4]
 8013fc0:	781b      	ldrb	r3, [r3, #0]
 8013fc2:	4619      	mov	r1, r3
 8013fc4:	2301      	movs	r3, #1
 8013fc6:	408b      	lsls	r3, r1
 8013fc8:	4908      	ldr	r1, [pc, #32]	; (8013fec <CAN_InitFilterBank+0x4e0>)
 8013fca:	4313      	orrs	r3, r2
 8013fcc:	f8c1 321c 	str.w	r3, [r1, #540]	; 0x21c

	CLR_BIT(CAN1->FMR, 0);	// exit filter initialization mode
 8013fd0:	4b06      	ldr	r3, [pc, #24]	; (8013fec <CAN_InitFilterBank+0x4e0>)
 8013fd2:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
 8013fd6:	4a05      	ldr	r2, [pc, #20]	; (8013fec <CAN_InitFilterBank+0x4e0>)
 8013fd8:	f023 0301 	bic.w	r3, r3, #1
 8013fdc:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
 8013fe0:	e000      	b.n	8013fe4 <CAN_InitFilterBank+0x4d8>
		return;
 8013fe2:	bf00      	nop
}
 8013fe4:	3708      	adds	r7, #8
 8013fe6:	46bd      	mov	sp, r7
 8013fe8:	bc90      	pop	{r4, r7}
 8013fea:	4770      	bx	lr
 8013fec:	40006400 	.word	0x40006400

08013ff0 <CAN_Tx>:




void CAN_Tx(CAN_Frame_t* frame)
{
 8013ff0:	b480      	push	{r7}
 8013ff2:	b085      	sub	sp, #20
 8013ff4:	af00      	add	r7, sp, #0
 8013ff6:	6078      	str	r0, [r7, #4]
	/* wait while all three mailboxes are busy (bits 26, 27, 28 are 0) */
	while((((CAN1->TSR)>>26) & 0x7) == 0);
 8013ff8:	bf00      	nop
 8013ffa:	4b78      	ldr	r3, [pc, #480]	; (80141dc <CAN_Tx+0x1ec>)
 8013ffc:	689b      	ldr	r3, [r3, #8]
 8013ffe:	0e9b      	lsrs	r3, r3, #26
 8014000:	f003 0307 	and.w	r3, r3, #7
 8014004:	2b00      	cmp	r3, #0
 8014006:	d0f8      	beq.n	8013ffa <CAN_Tx+0xa>

	u8 freeMailBox = 0;
 8014008:	2300      	movs	r3, #0
 801400a:	73fb      	strb	r3, [r7, #15]
	for(u8 i = 0; i < 3; i++)
 801400c:	2300      	movs	r3, #0
 801400e:	73bb      	strb	r3, [r7, #14]
 8014010:	e00f      	b.n	8014032 <CAN_Tx+0x42>
	{
		if(GET_BIT(CAN1->TSR, i + 26) == 1)
 8014012:	4b72      	ldr	r3, [pc, #456]	; (80141dc <CAN_Tx+0x1ec>)
 8014014:	689a      	ldr	r2, [r3, #8]
 8014016:	7bbb      	ldrb	r3, [r7, #14]
 8014018:	331a      	adds	r3, #26
 801401a:	fa22 f303 	lsr.w	r3, r2, r3
 801401e:	f003 0301 	and.w	r3, r3, #1
 8014022:	2b01      	cmp	r3, #1
 8014024:	d102      	bne.n	801402c <CAN_Tx+0x3c>
		{
			freeMailBox = i;
 8014026:	7bbb      	ldrb	r3, [r7, #14]
 8014028:	73fb      	strb	r3, [r7, #15]
			break;
 801402a:	e005      	b.n	8014038 <CAN_Tx+0x48>
	for(u8 i = 0; i < 3; i++)
 801402c:	7bbb      	ldrb	r3, [r7, #14]
 801402e:	3301      	adds	r3, #1
 8014030:	73bb      	strb	r3, [r7, #14]
 8014032:	7bbb      	ldrb	r3, [r7, #14]
 8014034:	2b02      	cmp	r3, #2
 8014036:	d9ec      	bls.n	8014012 <CAN_Tx+0x22>
		}
	}

	/* fill lowest 4 bytes of data in TDLR register */
	CAN1->sTxMailBox[freeMailBox].TDLR = 0;
 8014038:	4a68      	ldr	r2, [pc, #416]	; (80141dc <CAN_Tx+0x1ec>)
 801403a:	7bfb      	ldrb	r3, [r7, #15]
 801403c:	011b      	lsls	r3, r3, #4
 801403e:	4413      	add	r3, r2
 8014040:	f503 73c4 	add.w	r3, r3, #392	; 0x188
 8014044:	2200      	movs	r2, #0
 8014046:	601a      	str	r2, [r3, #0]
	for(u8 i = 0; i < 4; i++)
 8014048:	2300      	movs	r3, #0
 801404a:	737b      	strb	r3, [r7, #13]
 801404c:	e01b      	b.n	8014086 <CAN_Tx+0x96>
	{
		CAN1->sTxMailBox[freeMailBox].TDLR |= (frame->data[i])<<(i<<3);
 801404e:	4a63      	ldr	r2, [pc, #396]	; (80141dc <CAN_Tx+0x1ec>)
 8014050:	7bfb      	ldrb	r3, [r7, #15]
 8014052:	011b      	lsls	r3, r3, #4
 8014054:	4413      	add	r3, r2
 8014056:	f503 73c4 	add.w	r3, r3, #392	; 0x188
 801405a:	681a      	ldr	r2, [r3, #0]
 801405c:	7b7b      	ldrb	r3, [r7, #13]
 801405e:	6879      	ldr	r1, [r7, #4]
 8014060:	440b      	add	r3, r1
 8014062:	79db      	ldrb	r3, [r3, #7]
 8014064:	4619      	mov	r1, r3
 8014066:	7b7b      	ldrb	r3, [r7, #13]
 8014068:	00db      	lsls	r3, r3, #3
 801406a:	fa01 f303 	lsl.w	r3, r1, r3
 801406e:	4618      	mov	r0, r3
 8014070:	495a      	ldr	r1, [pc, #360]	; (80141dc <CAN_Tx+0x1ec>)
 8014072:	7bfb      	ldrb	r3, [r7, #15]
 8014074:	4302      	orrs	r2, r0
 8014076:	011b      	lsls	r3, r3, #4
 8014078:	440b      	add	r3, r1
 801407a:	f503 73c4 	add.w	r3, r3, #392	; 0x188
 801407e:	601a      	str	r2, [r3, #0]
	for(u8 i = 0; i < 4; i++)
 8014080:	7b7b      	ldrb	r3, [r7, #13]
 8014082:	3301      	adds	r3, #1
 8014084:	737b      	strb	r3, [r7, #13]
 8014086:	7b7b      	ldrb	r3, [r7, #13]
 8014088:	2b03      	cmp	r3, #3
 801408a:	d9e0      	bls.n	801404e <CAN_Tx+0x5e>
	}

	/* fill highest 4 bytes of data in TDHR register */
	CAN1->sTxMailBox[freeMailBox].TDHR = 0;
 801408c:	4a53      	ldr	r2, [pc, #332]	; (80141dc <CAN_Tx+0x1ec>)
 801408e:	7bfb      	ldrb	r3, [r7, #15]
 8014090:	011b      	lsls	r3, r3, #4
 8014092:	4413      	add	r3, r2
 8014094:	f503 73c6 	add.w	r3, r3, #396	; 0x18c
 8014098:	2200      	movs	r2, #0
 801409a:	601a      	str	r2, [r3, #0]
	for(u8 i = 0; i < 4; i++)
 801409c:	2300      	movs	r3, #0
 801409e:	733b      	strb	r3, [r7, #12]
 80140a0:	e01c      	b.n	80140dc <CAN_Tx+0xec>
	{
		CAN1->sTxMailBox[freeMailBox].TDHR |= (frame->data[i + 4])<<(i<<3);
 80140a2:	4a4e      	ldr	r2, [pc, #312]	; (80141dc <CAN_Tx+0x1ec>)
 80140a4:	7bfb      	ldrb	r3, [r7, #15]
 80140a6:	011b      	lsls	r3, r3, #4
 80140a8:	4413      	add	r3, r2
 80140aa:	f503 73c6 	add.w	r3, r3, #396	; 0x18c
 80140ae:	681a      	ldr	r2, [r3, #0]
 80140b0:	7b3b      	ldrb	r3, [r7, #12]
 80140b2:	3304      	adds	r3, #4
 80140b4:	6879      	ldr	r1, [r7, #4]
 80140b6:	440b      	add	r3, r1
 80140b8:	79db      	ldrb	r3, [r3, #7]
 80140ba:	4619      	mov	r1, r3
 80140bc:	7b3b      	ldrb	r3, [r7, #12]
 80140be:	00db      	lsls	r3, r3, #3
 80140c0:	fa01 f303 	lsl.w	r3, r1, r3
 80140c4:	4618      	mov	r0, r3
 80140c6:	4945      	ldr	r1, [pc, #276]	; (80141dc <CAN_Tx+0x1ec>)
 80140c8:	7bfb      	ldrb	r3, [r7, #15]
 80140ca:	4302      	orrs	r2, r0
 80140cc:	011b      	lsls	r3, r3, #4
 80140ce:	440b      	add	r3, r1
 80140d0:	f503 73c6 	add.w	r3, r3, #396	; 0x18c
 80140d4:	601a      	str	r2, [r3, #0]
	for(u8 i = 0; i < 4; i++)
 80140d6:	7b3b      	ldrb	r3, [r7, #12]
 80140d8:	3301      	adds	r3, #1
 80140da:	733b      	strb	r3, [r7, #12]
 80140dc:	7b3b      	ldrb	r3, [r7, #12]
 80140de:	2b03      	cmp	r3, #3
 80140e0:	d9df      	bls.n	80140a2 <CAN_Tx+0xb2>
	}

	CAN1->sTxMailBox[freeMailBox].TDTR = frame->DLC;			// Data Lenght Code (DLC)
 80140e2:	687b      	ldr	r3, [r7, #4]
 80140e4:	7999      	ldrb	r1, [r3, #6]
 80140e6:	4a3d      	ldr	r2, [pc, #244]	; (80141dc <CAN_Tx+0x1ec>)
 80140e8:	7bfb      	ldrb	r3, [r7, #15]
 80140ea:	3318      	adds	r3, #24
 80140ec:	011b      	lsls	r3, r3, #4
 80140ee:	4413      	add	r3, r2
 80140f0:	3304      	adds	r3, #4
 80140f2:	6019      	str	r1, [r3, #0]


	/* configure IDE & RTR */
	CAN1->sTxMailBox[freeMailBox].TIR = (
		((frame->frameType)<<1)  |   // RTR
 80140f4:	687b      	ldr	r3, [r7, #4]
 80140f6:	795b      	ldrb	r3, [r3, #5]
 80140f8:	005a      	lsls	r2, r3, #1
		((frame->idType)<<2)         // IDE
 80140fa:	687b      	ldr	r3, [r7, #4]
 80140fc:	791b      	ldrb	r3, [r3, #4]
 80140fe:	009b      	lsls	r3, r3, #2
		((frame->frameType)<<1)  |   // RTR
 8014100:	ea42 0103 	orr.w	r1, r2, r3
	CAN1->sTxMailBox[freeMailBox].TIR = (
 8014104:	4a35      	ldr	r2, [pc, #212]	; (80141dc <CAN_Tx+0x1ec>)
 8014106:	7bfb      	ldrb	r3, [r7, #15]
 8014108:	3318      	adds	r3, #24
 801410a:	011b      	lsls	r3, r3, #4
 801410c:	4413      	add	r3, r2
 801410e:	6019      	str	r1, [r3, #0]
	);

	/* configure ID */
	switch(frame->idType)
 8014110:	687b      	ldr	r3, [r7, #4]
 8014112:	791b      	ldrb	r3, [r3, #4]
 8014114:	2b00      	cmp	r3, #0
 8014116:	d002      	beq.n	801411e <CAN_Tx+0x12e>
 8014118:	2b01      	cmp	r3, #1
 801411a:	d011      	beq.n	8014140 <CAN_Tx+0x150>
 801411c:	e021      	b.n	8014162 <CAN_Tx+0x172>
	{
		case STANDARD_ID:
			CAN1->sTxMailBox[freeMailBox].TIR |= (frame->id)<<21;
 801411e:	4a2f      	ldr	r2, [pc, #188]	; (80141dc <CAN_Tx+0x1ec>)
 8014120:	7bfb      	ldrb	r3, [r7, #15]
 8014122:	3318      	adds	r3, #24
 8014124:	011b      	lsls	r3, r3, #4
 8014126:	4413      	add	r3, r2
 8014128:	6819      	ldr	r1, [r3, #0]
 801412a:	687b      	ldr	r3, [r7, #4]
 801412c:	681b      	ldr	r3, [r3, #0]
 801412e:	055a      	lsls	r2, r3, #21
 8014130:	482a      	ldr	r0, [pc, #168]	; (80141dc <CAN_Tx+0x1ec>)
 8014132:	7bfb      	ldrb	r3, [r7, #15]
 8014134:	430a      	orrs	r2, r1
 8014136:	3318      	adds	r3, #24
 8014138:	011b      	lsls	r3, r3, #4
 801413a:	4403      	add	r3, r0
 801413c:	601a      	str	r2, [r3, #0]
		break;
 801413e:	e010      	b.n	8014162 <CAN_Tx+0x172>

		case EXTENDED_ID:
			CAN1->sTxMailBox[freeMailBox].TIR |= (frame->id)<<3;
 8014140:	4a26      	ldr	r2, [pc, #152]	; (80141dc <CAN_Tx+0x1ec>)
 8014142:	7bfb      	ldrb	r3, [r7, #15]
 8014144:	3318      	adds	r3, #24
 8014146:	011b      	lsls	r3, r3, #4
 8014148:	4413      	add	r3, r2
 801414a:	6819      	ldr	r1, [r3, #0]
 801414c:	687b      	ldr	r3, [r7, #4]
 801414e:	681b      	ldr	r3, [r3, #0]
 8014150:	00da      	lsls	r2, r3, #3
 8014152:	4822      	ldr	r0, [pc, #136]	; (80141dc <CAN_Tx+0x1ec>)
 8014154:	7bfb      	ldrb	r3, [r7, #15]
 8014156:	430a      	orrs	r2, r1
 8014158:	3318      	adds	r3, #24
 801415a:	011b      	lsls	r3, r3, #4
 801415c:	4403      	add	r3, r0
 801415e:	601a      	str	r2, [r3, #0]
		break;
 8014160:	bf00      	nop
	}


	switch(frame->frameType)
 8014162:	687b      	ldr	r3, [r7, #4]
 8014164:	795b      	ldrb	r3, [r3, #5]
 8014166:	2b00      	cmp	r3, #0
 8014168:	d002      	beq.n	8014170 <CAN_Tx+0x180>
 801416a:	2b01      	cmp	r3, #1
 801416c:	d011      	beq.n	8014192 <CAN_Tx+0x1a2>
 801416e:	e021      	b.n	80141b4 <CAN_Tx+0x1c4>
	{
		case DATA_FRAME:
			CAN1->sTxMailBox[freeMailBox].TIR |= (frame->id)<<21;
 8014170:	4a1a      	ldr	r2, [pc, #104]	; (80141dc <CAN_Tx+0x1ec>)
 8014172:	7bfb      	ldrb	r3, [r7, #15]
 8014174:	3318      	adds	r3, #24
 8014176:	011b      	lsls	r3, r3, #4
 8014178:	4413      	add	r3, r2
 801417a:	6819      	ldr	r1, [r3, #0]
 801417c:	687b      	ldr	r3, [r7, #4]
 801417e:	681b      	ldr	r3, [r3, #0]
 8014180:	055a      	lsls	r2, r3, #21
 8014182:	4816      	ldr	r0, [pc, #88]	; (80141dc <CAN_Tx+0x1ec>)
 8014184:	7bfb      	ldrb	r3, [r7, #15]
 8014186:	430a      	orrs	r2, r1
 8014188:	3318      	adds	r3, #24
 801418a:	011b      	lsls	r3, r3, #4
 801418c:	4403      	add	r3, r0
 801418e:	601a      	str	r2, [r3, #0]
		break;
 8014190:	e010      	b.n	80141b4 <CAN_Tx+0x1c4>

		case REMOTE_FRAME:
			CAN1->sTxMailBox[freeMailBox].TIR |= (frame->id)<<3;
 8014192:	4a12      	ldr	r2, [pc, #72]	; (80141dc <CAN_Tx+0x1ec>)
 8014194:	7bfb      	ldrb	r3, [r7, #15]
 8014196:	3318      	adds	r3, #24
 8014198:	011b      	lsls	r3, r3, #4
 801419a:	4413      	add	r3, r2
 801419c:	6819      	ldr	r1, [r3, #0]
 801419e:	687b      	ldr	r3, [r7, #4]
 80141a0:	681b      	ldr	r3, [r3, #0]
 80141a2:	00da      	lsls	r2, r3, #3
 80141a4:	480d      	ldr	r0, [pc, #52]	; (80141dc <CAN_Tx+0x1ec>)
 80141a6:	7bfb      	ldrb	r3, [r7, #15]
 80141a8:	430a      	orrs	r2, r1
 80141aa:	3318      	adds	r3, #24
 80141ac:	011b      	lsls	r3, r3, #4
 80141ae:	4403      	add	r3, r0
 80141b0:	601a      	str	r2, [r3, #0]
		break;
 80141b2:	bf00      	nop
	}


	SET_BIT(CAN1->sTxMailBox[freeMailBox].TIR, 0);	// Tx request
 80141b4:	4a09      	ldr	r2, [pc, #36]	; (80141dc <CAN_Tx+0x1ec>)
 80141b6:	7bfb      	ldrb	r3, [r7, #15]
 80141b8:	3318      	adds	r3, #24
 80141ba:	011b      	lsls	r3, r3, #4
 80141bc:	4413      	add	r3, r2
 80141be:	681a      	ldr	r2, [r3, #0]
 80141c0:	4906      	ldr	r1, [pc, #24]	; (80141dc <CAN_Tx+0x1ec>)
 80141c2:	7bfb      	ldrb	r3, [r7, #15]
 80141c4:	f042 0201 	orr.w	r2, r2, #1
 80141c8:	3318      	adds	r3, #24
 80141ca:	011b      	lsls	r3, r3, #4
 80141cc:	440b      	add	r3, r1
 80141ce:	601a      	str	r2, [r3, #0]
}
 80141d0:	bf00      	nop
 80141d2:	3714      	adds	r7, #20
 80141d4:	46bd      	mov	sp, r7
 80141d6:	bc80      	pop	{r7}
 80141d8:	4770      	bx	lr
 80141da:	bf00      	nop
 80141dc:	40006400 	.word	0x40006400

080141e0 <CAN_Rx>:


void CAN_Rx(CAN_Frame_t* frame, CAN_RxFifo_t fifo)
{
 80141e0:	b480      	push	{r7}
 80141e2:	b085      	sub	sp, #20
 80141e4:	af00      	add	r7, sp, #0
 80141e6:	6078      	str	r0, [r7, #4]
 80141e8:	460b      	mov	r3, r1
 80141ea:	70fb      	strb	r3, [r7, #3]
	// wait until there's received data in FIFO
	switch(fifo)
 80141ec:	78fb      	ldrb	r3, [r7, #3]
 80141ee:	2b00      	cmp	r3, #0
 80141f0:	d002      	beq.n	80141f8 <CAN_Rx+0x18>
 80141f2:	2b01      	cmp	r3, #1
 80141f4:	d008      	beq.n	8014208 <CAN_Rx+0x28>
 80141f6:	e00f      	b.n	8014218 <CAN_Rx+0x38>
	{
		case FIFO_0:
			while((CAN1->RF0R & 0x3) == 0);
 80141f8:	bf00      	nop
 80141fa:	4b57      	ldr	r3, [pc, #348]	; (8014358 <CAN_Rx+0x178>)
 80141fc:	68db      	ldr	r3, [r3, #12]
 80141fe:	f003 0303 	and.w	r3, r3, #3
 8014202:	2b00      	cmp	r3, #0
 8014204:	d0f9      	beq.n	80141fa <CAN_Rx+0x1a>
		break;
 8014206:	e007      	b.n	8014218 <CAN_Rx+0x38>

		case FIFO_1:
			while((CAN1->RF1R & 0x3) == 0);
 8014208:	bf00      	nop
 801420a:	4b53      	ldr	r3, [pc, #332]	; (8014358 <CAN_Rx+0x178>)
 801420c:	691b      	ldr	r3, [r3, #16]
 801420e:	f003 0303 	and.w	r3, r3, #3
 8014212:	2b00      	cmp	r3, #0
 8014214:	d0f9      	beq.n	801420a <CAN_Rx+0x2a>
		break;
 8014216:	bf00      	nop
	}


	/* read frame type (RTR) */
	switch(GET_BIT(CAN1->sFIFOMailBox[fifo].RIR, 1))
 8014218:	4a4f      	ldr	r2, [pc, #316]	; (8014358 <CAN_Rx+0x178>)
 801421a:	78fb      	ldrb	r3, [r7, #3]
 801421c:	331b      	adds	r3, #27
 801421e:	011b      	lsls	r3, r3, #4
 8014220:	4413      	add	r3, r2
 8014222:	681b      	ldr	r3, [r3, #0]
 8014224:	085b      	lsrs	r3, r3, #1
 8014226:	f003 0301 	and.w	r3, r3, #1
 801422a:	2b00      	cmp	r3, #0
 801422c:	d002      	beq.n	8014234 <CAN_Rx+0x54>
 801422e:	2b01      	cmp	r3, #1
 8014230:	d004      	beq.n	801423c <CAN_Rx+0x5c>
 8014232:	e007      	b.n	8014244 <CAN_Rx+0x64>
	{
		case 0:
			frame->frameType = DATA_FRAME;
 8014234:	687b      	ldr	r3, [r7, #4]
 8014236:	2200      	movs	r2, #0
 8014238:	715a      	strb	r2, [r3, #5]
		break;
 801423a:	e003      	b.n	8014244 <CAN_Rx+0x64>

		case 1:
			frame->frameType = REMOTE_FRAME;
 801423c:	687b      	ldr	r3, [r7, #4]
 801423e:	2201      	movs	r2, #1
 8014240:	715a      	strb	r2, [r3, #5]
		break;
 8014242:	bf00      	nop
	}


	/* read ID type (IDE) */
	switch(GET_BIT(CAN1->sFIFOMailBox[fifo].RIR, 2))
 8014244:	4a44      	ldr	r2, [pc, #272]	; (8014358 <CAN_Rx+0x178>)
 8014246:	78fb      	ldrb	r3, [r7, #3]
 8014248:	331b      	adds	r3, #27
 801424a:	011b      	lsls	r3, r3, #4
 801424c:	4413      	add	r3, r2
 801424e:	681b      	ldr	r3, [r3, #0]
 8014250:	089b      	lsrs	r3, r3, #2
 8014252:	f003 0301 	and.w	r3, r3, #1
 8014256:	2b00      	cmp	r3, #0
 8014258:	d002      	beq.n	8014260 <CAN_Rx+0x80>
 801425a:	2b01      	cmp	r3, #1
 801425c:	d004      	beq.n	8014268 <CAN_Rx+0x88>
 801425e:	e007      	b.n	8014270 <CAN_Rx+0x90>
	{
		case 0:
			frame->idType = STANDARD_ID;
 8014260:	687b      	ldr	r3, [r7, #4]
 8014262:	2200      	movs	r2, #0
 8014264:	711a      	strb	r2, [r3, #4]
		break;
 8014266:	e003      	b.n	8014270 <CAN_Rx+0x90>

		case 1:
			frame->idType = EXTENDED_ID;
 8014268:	687b      	ldr	r3, [r7, #4]
 801426a:	2201      	movs	r2, #1
 801426c:	711a      	strb	r2, [r3, #4]
		break;
 801426e:	bf00      	nop
	}


	/* read ID */
	switch(frame->idType)
 8014270:	687b      	ldr	r3, [r7, #4]
 8014272:	791b      	ldrb	r3, [r3, #4]
 8014274:	2b00      	cmp	r3, #0
 8014276:	d002      	beq.n	801427e <CAN_Rx+0x9e>
 8014278:	2b01      	cmp	r3, #1
 801427a:	d00a      	beq.n	8014292 <CAN_Rx+0xb2>
 801427c:	e013      	b.n	80142a6 <CAN_Rx+0xc6>
	{
		case STANDARD_ID:
			frame->id = (CAN1->sFIFOMailBox[fifo].RIR)>>21;
 801427e:	4a36      	ldr	r2, [pc, #216]	; (8014358 <CAN_Rx+0x178>)
 8014280:	78fb      	ldrb	r3, [r7, #3]
 8014282:	331b      	adds	r3, #27
 8014284:	011b      	lsls	r3, r3, #4
 8014286:	4413      	add	r3, r2
 8014288:	681b      	ldr	r3, [r3, #0]
 801428a:	0d5a      	lsrs	r2, r3, #21
 801428c:	687b      	ldr	r3, [r7, #4]
 801428e:	601a      	str	r2, [r3, #0]
		break;
 8014290:	e009      	b.n	80142a6 <CAN_Rx+0xc6>

		case 1:
			frame->id = (CAN1->sFIFOMailBox[fifo].RIR)>>3;
 8014292:	4a31      	ldr	r2, [pc, #196]	; (8014358 <CAN_Rx+0x178>)
 8014294:	78fb      	ldrb	r3, [r7, #3]
 8014296:	331b      	adds	r3, #27
 8014298:	011b      	lsls	r3, r3, #4
 801429a:	4413      	add	r3, r2
 801429c:	681b      	ldr	r3, [r3, #0]
 801429e:	08da      	lsrs	r2, r3, #3
 80142a0:	687b      	ldr	r3, [r7, #4]
 80142a2:	601a      	str	r2, [r3, #0]
		break;
 80142a4:	bf00      	nop
	}


	/* read DLC */
	frame->DLC = (CAN1->sFIFOMailBox[fifo].RDTR) & 0xF;
 80142a6:	4a2c      	ldr	r2, [pc, #176]	; (8014358 <CAN_Rx+0x178>)
 80142a8:	78fb      	ldrb	r3, [r7, #3]
 80142aa:	331b      	adds	r3, #27
 80142ac:	011b      	lsls	r3, r3, #4
 80142ae:	4413      	add	r3, r2
 80142b0:	3304      	adds	r3, #4
 80142b2:	681b      	ldr	r3, [r3, #0]
 80142b4:	b2db      	uxtb	r3, r3
 80142b6:	f003 030f 	and.w	r3, r3, #15
 80142ba:	b2da      	uxtb	r2, r3
 80142bc:	687b      	ldr	r3, [r7, #4]
 80142be:	719a      	strb	r2, [r3, #6]



	/* read lower 4 bytes of data from RDLR register */
	for(u8 i = 0; i < 4; i++)
 80142c0:	2300      	movs	r3, #0
 80142c2:	73fb      	strb	r3, [r7, #15]
 80142c4:	e012      	b.n	80142ec <CAN_Rx+0x10c>
	{
		frame->data[i] = (CAN1->sFIFOMailBox[fifo].RDLR)>>(i<<3);
 80142c6:	4a24      	ldr	r2, [pc, #144]	; (8014358 <CAN_Rx+0x178>)
 80142c8:	78fb      	ldrb	r3, [r7, #3]
 80142ca:	011b      	lsls	r3, r3, #4
 80142cc:	4413      	add	r3, r2
 80142ce:	f503 73dc 	add.w	r3, r3, #440	; 0x1b8
 80142d2:	681a      	ldr	r2, [r3, #0]
 80142d4:	7bfb      	ldrb	r3, [r7, #15]
 80142d6:	00db      	lsls	r3, r3, #3
 80142d8:	40da      	lsrs	r2, r3
 80142da:	7bfb      	ldrb	r3, [r7, #15]
 80142dc:	b2d1      	uxtb	r1, r2
 80142de:	687a      	ldr	r2, [r7, #4]
 80142e0:	4413      	add	r3, r2
 80142e2:	460a      	mov	r2, r1
 80142e4:	71da      	strb	r2, [r3, #7]
	for(u8 i = 0; i < 4; i++)
 80142e6:	7bfb      	ldrb	r3, [r7, #15]
 80142e8:	3301      	adds	r3, #1
 80142ea:	73fb      	strb	r3, [r7, #15]
 80142ec:	7bfb      	ldrb	r3, [r7, #15]
 80142ee:	2b03      	cmp	r3, #3
 80142f0:	d9e9      	bls.n	80142c6 <CAN_Rx+0xe6>
	}

	/* read higher 4 bytes of data from RDHR register */
	for(u8 i = 0; i < 4; i++)
 80142f2:	2300      	movs	r3, #0
 80142f4:	73bb      	strb	r3, [r7, #14]
 80142f6:	e013      	b.n	8014320 <CAN_Rx+0x140>
	{
		frame->data[i + 4] = (CAN1->sFIFOMailBox[fifo].RDHR)>>(i<<3);
 80142f8:	4a17      	ldr	r2, [pc, #92]	; (8014358 <CAN_Rx+0x178>)
 80142fa:	78fb      	ldrb	r3, [r7, #3]
 80142fc:	011b      	lsls	r3, r3, #4
 80142fe:	4413      	add	r3, r2
 8014300:	f503 73de 	add.w	r3, r3, #444	; 0x1bc
 8014304:	681a      	ldr	r2, [r3, #0]
 8014306:	7bbb      	ldrb	r3, [r7, #14]
 8014308:	00db      	lsls	r3, r3, #3
 801430a:	40da      	lsrs	r2, r3
 801430c:	7bbb      	ldrb	r3, [r7, #14]
 801430e:	3304      	adds	r3, #4
 8014310:	b2d1      	uxtb	r1, r2
 8014312:	687a      	ldr	r2, [r7, #4]
 8014314:	4413      	add	r3, r2
 8014316:	460a      	mov	r2, r1
 8014318:	71da      	strb	r2, [r3, #7]
	for(u8 i = 0; i < 4; i++)
 801431a:	7bbb      	ldrb	r3, [r7, #14]
 801431c:	3301      	adds	r3, #1
 801431e:	73bb      	strb	r3, [r7, #14]
 8014320:	7bbb      	ldrb	r3, [r7, #14]
 8014322:	2b03      	cmp	r3, #3
 8014324:	d9e8      	bls.n	80142f8 <CAN_Rx+0x118>
	}


	/* release FIFO (pop first message) */
	switch(fifo)
 8014326:	78fb      	ldrb	r3, [r7, #3]
 8014328:	2b00      	cmp	r3, #0
 801432a:	d002      	beq.n	8014332 <CAN_Rx+0x152>
 801432c:	2b01      	cmp	r3, #1
 801432e:	d007      	beq.n	8014340 <CAN_Rx+0x160>

		case FIFO_1:
			SET_BIT(CAN1->RF1R, 5);
		break;
	}
}
 8014330:	e00d      	b.n	801434e <CAN_Rx+0x16e>
			SET_BIT(CAN1->RF0R, 5);
 8014332:	4b09      	ldr	r3, [pc, #36]	; (8014358 <CAN_Rx+0x178>)
 8014334:	68db      	ldr	r3, [r3, #12]
 8014336:	4a08      	ldr	r2, [pc, #32]	; (8014358 <CAN_Rx+0x178>)
 8014338:	f043 0320 	orr.w	r3, r3, #32
 801433c:	60d3      	str	r3, [r2, #12]
		break;
 801433e:	e006      	b.n	801434e <CAN_Rx+0x16e>
			SET_BIT(CAN1->RF1R, 5);
 8014340:	4b05      	ldr	r3, [pc, #20]	; (8014358 <CAN_Rx+0x178>)
 8014342:	691b      	ldr	r3, [r3, #16]
 8014344:	4a04      	ldr	r2, [pc, #16]	; (8014358 <CAN_Rx+0x178>)
 8014346:	f043 0320 	orr.w	r3, r3, #32
 801434a:	6113      	str	r3, [r2, #16]
		break;
 801434c:	bf00      	nop
}
 801434e:	bf00      	nop
 8014350:	3714      	adds	r7, #20
 8014352:	46bd      	mov	sp, r7
 8014354:	bc80      	pop	{r7}
 8014356:	4770      	bx	lr
 8014358:	40006400 	.word	0x40006400

0801435c <ECU_ConfigActivateBoot>:
#include "ECU_Config.h"


void  ECU_ConfigActivateBoot(void)
{
 801435c:	b580      	push	{r7, lr}
 801435e:	af00      	add	r7, sp, #0
	FPEC_InitFlash();
 8014360:	f000 f8a6 	bl	80144b0 <FPEC_InitFlash>
	FPEC_WriteByte(BRANCHING_PAGE_NUMBER, BRANCHING_BYTE_OFFSET, BOOTLOADER);
 8014364:	2242      	movs	r2, #66	; 0x42
 8014366:	2100      	movs	r1, #0
 8014368:	2005      	movs	r0, #5
 801436a:	f000 f985 	bl	8014678 <FPEC_WriteByte>
}
 801436e:	bf00      	nop
 8014370:	bd80      	pop	{r7, pc}
	...

08014374 <FPEC_UnlockFlash>:
  * @brief  Unlock the Embedded Flash.
  * @param  None.
  * @retval None.
  */
static void  FPEC_UnlockFlash(void)
{
 8014374:	b480      	push	{r7}
 8014376:	af00      	add	r7, sp, #0
	FLASH->KEYR = KEY1;  //write KEY1
 8014378:	4b04      	ldr	r3, [pc, #16]	; (801438c <FPEC_UnlockFlash+0x18>)
 801437a:	4a05      	ldr	r2, [pc, #20]	; (8014390 <FPEC_UnlockFlash+0x1c>)
 801437c:	605a      	str	r2, [r3, #4]
	FLASH->KEYR = KEY2;  //write KEY2
 801437e:	4b03      	ldr	r3, [pc, #12]	; (801438c <FPEC_UnlockFlash+0x18>)
 8014380:	4a04      	ldr	r2, [pc, #16]	; (8014394 <FPEC_UnlockFlash+0x20>)
 8014382:	605a      	str	r2, [r3, #4]
}
 8014384:	bf00      	nop
 8014386:	46bd      	mov	sp, r7
 8014388:	bc80      	pop	{r7}
 801438a:	4770      	bx	lr
 801438c:	40022000 	.word	0x40022000
 8014390:	45670123 	.word	0x45670123
 8014394:	cdef89ab 	.word	0xcdef89ab

08014398 <FPEC_LockFlash>:
  * @brief  Lock the Embedded Flash.
  * @param  None.
  * @retval None.
  */
static void  FPEC_LockFlash(void)
{
 8014398:	b480      	push	{r7}
 801439a:	af00      	add	r7, sp, #0
	SET_BIT(FLASH->CR, 7);
 801439c:	4b04      	ldr	r3, [pc, #16]	; (80143b0 <FPEC_LockFlash+0x18>)
 801439e:	691b      	ldr	r3, [r3, #16]
 80143a0:	4a03      	ldr	r2, [pc, #12]	; (80143b0 <FPEC_LockFlash+0x18>)
 80143a2:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80143a6:	6113      	str	r3, [r2, #16]
}
 80143a8:	bf00      	nop
 80143aa:	46bd      	mov	sp, r7
 80143ac:	bc80      	pop	{r7}
 80143ae:	4770      	bx	lr
 80143b0:	40022000 	.word	0x40022000

080143b4 <FPEC_CheckErrors>:
  * @brief  Check if any errors occurred while programming/erasing flash
  * @param  None
  * @retval Flash error
  */
static FPEC_Error_t  FPEC_CheckErrors(void)
{
 80143b4:	b480      	push	{r7}
 80143b6:	af00      	add	r7, sp, #0
	if(GET_BIT(FLASH->SR, 4) == 1)
 80143b8:	4b11      	ldr	r3, [pc, #68]	; (8014400 <FPEC_CheckErrors+0x4c>)
 80143ba:	68db      	ldr	r3, [r3, #12]
 80143bc:	091b      	lsrs	r3, r3, #4
 80143be:	f003 0301 	and.w	r3, r3, #1
 80143c2:	2b01      	cmp	r3, #1
 80143c4:	d107      	bne.n	80143d6 <FPEC_CheckErrors+0x22>
	{
		SET_BIT(FLASH->SR, 4);  //clear flag
 80143c6:	4b0e      	ldr	r3, [pc, #56]	; (8014400 <FPEC_CheckErrors+0x4c>)
 80143c8:	68db      	ldr	r3, [r3, #12]
 80143ca:	4a0d      	ldr	r2, [pc, #52]	; (8014400 <FPEC_CheckErrors+0x4c>)
 80143cc:	f043 0310 	orr.w	r3, r3, #16
 80143d0:	60d3      	str	r3, [r2, #12]
		return  FPEC_WRITE_PROTECTION_ERROR;
 80143d2:	2301      	movs	r3, #1
 80143d4:	e00f      	b.n	80143f6 <FPEC_CheckErrors+0x42>
	}
	if(GET_BIT(FLASH->SR, 2) == 1)
 80143d6:	4b0a      	ldr	r3, [pc, #40]	; (8014400 <FPEC_CheckErrors+0x4c>)
 80143d8:	68db      	ldr	r3, [r3, #12]
 80143da:	089b      	lsrs	r3, r3, #2
 80143dc:	f003 0301 	and.w	r3, r3, #1
 80143e0:	2b01      	cmp	r3, #1
 80143e2:	d107      	bne.n	80143f4 <FPEC_CheckErrors+0x40>
	{
		SET_BIT(FLASH->SR, 2);  //clear flag
 80143e4:	4b06      	ldr	r3, [pc, #24]	; (8014400 <FPEC_CheckErrors+0x4c>)
 80143e6:	68db      	ldr	r3, [r3, #12]
 80143e8:	4a05      	ldr	r2, [pc, #20]	; (8014400 <FPEC_CheckErrors+0x4c>)
 80143ea:	f043 0304 	orr.w	r3, r3, #4
 80143ee:	60d3      	str	r3, [r2, #12]
		return  FPEC_PROGRAMMING_ERROR;
 80143f0:	2300      	movs	r3, #0
 80143f2:	e000      	b.n	80143f6 <FPEC_CheckErrors+0x42>
	}
	return FPEC_NO_ERRORS;
 80143f4:	2302      	movs	r3, #2
}
 80143f6:	4618      	mov	r0, r3
 80143f8:	46bd      	mov	sp, r7
 80143fa:	bc80      	pop	{r7}
 80143fc:	4770      	bx	lr
 80143fe:	bf00      	nop
 8014400:	40022000 	.word	0x40022000

08014404 <FPEC_DirectWriteHalfWord>:
  * @note   offsetAddress must be even number
  * @param  data: actual data you want to write.
  * @retval Flash error
  */
FPEC_Error_t  FPEC_DirectWriteHalfWord(u8 pageNumber, u16 offsetAddress, u16 data)
{
 8014404:	b580      	push	{r7, lr}
 8014406:	b084      	sub	sp, #16
 8014408:	af00      	add	r7, sp, #0
 801440a:	4603      	mov	r3, r0
 801440c:	71fb      	strb	r3, [r7, #7]
 801440e:	460b      	mov	r3, r1
 8014410:	80bb      	strh	r3, [r7, #4]
 8014412:	4613      	mov	r3, r2
 8014414:	807b      	strh	r3, [r7, #2]
	if(offsetAddress % 2 == 1)	return FPEC_PROGRAMMING_ERROR;
 8014416:	88bb      	ldrh	r3, [r7, #4]
 8014418:	f003 0301 	and.w	r3, r3, #1
 801441c:	b29b      	uxth	r3, r3
 801441e:	2b00      	cmp	r3, #0
 8014420:	d001      	beq.n	8014426 <FPEC_DirectWriteHalfWord+0x22>
 8014422:	2300      	movs	r3, #0
 8014424:	e03d      	b.n	80144a2 <FPEC_DirectWriteHalfWord+0x9e>

	FPEC_Error_t writeStatus = FPEC_NO_ERRORS;
 8014426:	2302      	movs	r3, #2
 8014428:	73fb      	strb	r3, [r7, #15]

	FPEC_UnlockFlash();
 801442a:	f7ff ffa3 	bl	8014374 <FPEC_UnlockFlash>

	/* Wait if the flash is busy */
	while(GET_BIT(FLASH->SR, 0) == 1) {}
 801442e:	bf00      	nop
 8014430:	4b1e      	ldr	r3, [pc, #120]	; (80144ac <FPEC_DirectWriteHalfWord+0xa8>)
 8014432:	68db      	ldr	r3, [r3, #12]
 8014434:	f003 0301 	and.w	r3, r3, #1
 8014438:	2b01      	cmp	r3, #1
 801443a:	d0f9      	beq.n	8014430 <FPEC_DirectWriteHalfWord+0x2c>

	SET_BIT(FLASH->CR, 0);   //Set bit 0 to select flash programming
 801443c:	4b1b      	ldr	r3, [pc, #108]	; (80144ac <FPEC_DirectWriteHalfWord+0xa8>)
 801443e:	691b      	ldr	r3, [r3, #16]
 8014440:	4a1a      	ldr	r2, [pc, #104]	; (80144ac <FPEC_DirectWriteHalfWord+0xa8>)
 8014442:	f043 0301 	orr.w	r3, r3, #1
 8014446:	6113      	str	r3, [r2, #16]

	/* Get physical address of the desired half word */
	volatile u16* physicalAddress = (volatile u16*)(FLASH_BASE_ADDRESS + pageNumber * PAGE_SIZE_BYTES + offsetAddress);
 8014448:	79fb      	ldrb	r3, [r7, #7]
 801444a:	029b      	lsls	r3, r3, #10
 801444c:	461a      	mov	r2, r3
 801444e:	88bb      	ldrh	r3, [r7, #4]
 8014450:	4413      	add	r3, r2
 8014452:	f103 6300 	add.w	r3, r3, #134217728	; 0x8000000
 8014456:	60bb      	str	r3, [r7, #8]
	*physicalAddress = data;
 8014458:	68bb      	ldr	r3, [r7, #8]
 801445a:	887a      	ldrh	r2, [r7, #2]
 801445c:	801a      	strh	r2, [r3, #0]

	/* Wait until writing is completed */
	while(GET_BIT(FLASH->SR, 0) == 1) {}
 801445e:	bf00      	nop
 8014460:	4b12      	ldr	r3, [pc, #72]	; (80144ac <FPEC_DirectWriteHalfWord+0xa8>)
 8014462:	68db      	ldr	r3, [r3, #12]
 8014464:	f003 0301 	and.w	r3, r3, #1
 8014468:	2b01      	cmp	r3, #1
 801446a:	d0f9      	beq.n	8014460 <FPEC_DirectWriteHalfWord+0x5c>

	CLR_BIT(FLASH->CR, 0);   //clear bit 0 to unselect flash programming
 801446c:	4b0f      	ldr	r3, [pc, #60]	; (80144ac <FPEC_DirectWriteHalfWord+0xa8>)
 801446e:	691b      	ldr	r3, [r3, #16]
 8014470:	4a0e      	ldr	r2, [pc, #56]	; (80144ac <FPEC_DirectWriteHalfWord+0xa8>)
 8014472:	f023 0301 	bic.w	r3, r3, #1
 8014476:	6113      	str	r3, [r2, #16]

	/* Read the written half word to make sure it's written successfully */
	if(FPEC_ReadHalfWord(pageNumber, offsetAddress) == data)
 8014478:	88ba      	ldrh	r2, [r7, #4]
 801447a:	79fb      	ldrb	r3, [r7, #7]
 801447c:	4611      	mov	r1, r2
 801447e:	4618      	mov	r0, r3
 8014480:	f000 f8d8 	bl	8014634 <FPEC_ReadHalfWord>
 8014484:	4603      	mov	r3, r0
 8014486:	461a      	mov	r2, r3
 8014488:	887b      	ldrh	r3, [r7, #2]
 801448a:	4293      	cmp	r3, r2
 801448c:	d102      	bne.n	8014494 <FPEC_DirectWriteHalfWord+0x90>
	{
		writeStatus = FPEC_NO_ERRORS;
 801448e:	2302      	movs	r3, #2
 8014490:	73fb      	strb	r3, [r7, #15]
 8014492:	e003      	b.n	801449c <FPEC_DirectWriteHalfWord+0x98>
	}
	else
	{
		writeStatus =  FPEC_CheckErrors();
 8014494:	f7ff ff8e 	bl	80143b4 <FPEC_CheckErrors>
 8014498:	4603      	mov	r3, r0
 801449a:	73fb      	strb	r3, [r7, #15]
	}

	FPEC_LockFlash();
 801449c:	f7ff ff7c 	bl	8014398 <FPEC_LockFlash>

	return writeStatus;
 80144a0:	7bfb      	ldrb	r3, [r7, #15]
}
 80144a2:	4618      	mov	r0, r3
 80144a4:	3710      	adds	r7, #16
 80144a6:	46bd      	mov	sp, r7
 80144a8:	bd80      	pop	{r7, pc}
 80144aa:	bf00      	nop
 80144ac:	40022000 	.word	0x40022000

080144b0 <FPEC_InitFlash>:
  * @note   This function must be called once before any reading, writing or erasing.
  * @param  None.
  * @retval Flash error.
  */
void  FPEC_InitFlash(void)
{
 80144b0:	b580      	push	{r7, lr}
 80144b2:	af00      	add	r7, sp, #0
	RCC_EnablePeripheralClock(FLITF_PERIPHERAL);
 80144b4:	2004      	movs	r0, #4
 80144b6:	f000 fb69 	bl	8014b8c <RCC_EnablePeripheralClock>
	FPEC_UnlockFlash();
 80144ba:	f7ff ff5b 	bl	8014374 <FPEC_UnlockFlash>
#elif  SYSTEM_CLK  <=  48000000
	SET_BIT(FLASH->ACR, 0);
	CLR_BIT(FLASH->ACR, 1);
	CLR_BIT(FLASH->ACR, 2);
#elif  SYSTEM_CLK  <=  72000000
	CLR_BIT(FLASH->ACR, 0);
 80144be:	4b0b      	ldr	r3, [pc, #44]	; (80144ec <FPEC_InitFlash+0x3c>)
 80144c0:	681b      	ldr	r3, [r3, #0]
 80144c2:	4a0a      	ldr	r2, [pc, #40]	; (80144ec <FPEC_InitFlash+0x3c>)
 80144c4:	f023 0301 	bic.w	r3, r3, #1
 80144c8:	6013      	str	r3, [r2, #0]
	SET_BIT(FLASH->ACR, 1);
 80144ca:	4b08      	ldr	r3, [pc, #32]	; (80144ec <FPEC_InitFlash+0x3c>)
 80144cc:	681b      	ldr	r3, [r3, #0]
 80144ce:	4a07      	ldr	r2, [pc, #28]	; (80144ec <FPEC_InitFlash+0x3c>)
 80144d0:	f043 0302 	orr.w	r3, r3, #2
 80144d4:	6013      	str	r3, [r2, #0]
	CLR_BIT(FLASH->ACR, 2);
 80144d6:	4b05      	ldr	r3, [pc, #20]	; (80144ec <FPEC_InitFlash+0x3c>)
 80144d8:	681b      	ldr	r3, [r3, #0]
 80144da:	4a04      	ldr	r2, [pc, #16]	; (80144ec <FPEC_InitFlash+0x3c>)
 80144dc:	f023 0304 	bic.w	r3, r3, #4
 80144e0:	6013      	str	r3, [r2, #0]
#endif

	FPEC_LockFlash();
 80144e2:	f7ff ff59 	bl	8014398 <FPEC_LockFlash>
}
 80144e6:	bf00      	nop
 80144e8:	bd80      	pop	{r7, pc}
 80144ea:	bf00      	nop
 80144ec:	40022000 	.word	0x40022000

080144f0 <FPEC_ErasePage>:
  * @param  pageNumber: number of the page to be erased.
  * @note   There are 128 pages in the flash memory (from page 0 to page 127)
  * @retval Flash error
  */
FPEC_Error_t  FPEC_ErasePage(u8 pageNumber)
{
 80144f0:	b580      	push	{r7, lr}
 80144f2:	b084      	sub	sp, #16
 80144f4:	af00      	add	r7, sp, #0
 80144f6:	4603      	mov	r3, r0
 80144f8:	71fb      	strb	r3, [r7, #7]
	FPEC_Error_t  eraseStatus;

	FPEC_UnlockFlash();
 80144fa:	f7ff ff3b 	bl	8014374 <FPEC_UnlockFlash>

	/* Wait if the flash is busy */
	while(GET_BIT(FLASH->SR, 0) == 1) {}
 80144fe:	bf00      	nop
 8014500:	4b1f      	ldr	r3, [pc, #124]	; (8014580 <FPEC_ErasePage+0x90>)
 8014502:	68db      	ldr	r3, [r3, #12]
 8014504:	f003 0301 	and.w	r3, r3, #1
 8014508:	2b01      	cmp	r3, #1
 801450a:	d0f9      	beq.n	8014500 <FPEC_ErasePage+0x10>

	SET_BIT(FLASH->CR, 1);   //Set bit 1 to select page erase
 801450c:	4b1c      	ldr	r3, [pc, #112]	; (8014580 <FPEC_ErasePage+0x90>)
 801450e:	691b      	ldr	r3, [r3, #16]
 8014510:	4a1b      	ldr	r2, [pc, #108]	; (8014580 <FPEC_ErasePage+0x90>)
 8014512:	f043 0302 	orr.w	r3, r3, #2
 8014516:	6113      	str	r3, [r2, #16]

	/* Get address of first byte in the desired page to be erased */
	u32 pagePhysicalAddress = FLASH_BASE_ADDRESS + pageNumber * PAGE_SIZE_BYTES;
 8014518:	79fb      	ldrb	r3, [r7, #7]
 801451a:	029b      	lsls	r3, r3, #10
 801451c:	f103 6300 	add.w	r3, r3, #134217728	; 0x8000000
 8014520:	60bb      	str	r3, [r7, #8]
	FLASH->AR = pagePhysicalAddress;
 8014522:	4a17      	ldr	r2, [pc, #92]	; (8014580 <FPEC_ErasePage+0x90>)
 8014524:	68bb      	ldr	r3, [r7, #8]
 8014526:	6153      	str	r3, [r2, #20]

	SET_BIT(FLASH->CR, 6);   //Start erasing the page
 8014528:	4b15      	ldr	r3, [pc, #84]	; (8014580 <FPEC_ErasePage+0x90>)
 801452a:	691b      	ldr	r3, [r3, #16]
 801452c:	4a14      	ldr	r2, [pc, #80]	; (8014580 <FPEC_ErasePage+0x90>)
 801452e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8014532:	6113      	str	r3, [r2, #16]

	/* wait until page erasing is completed */
	while(GET_BIT(FLASH->SR, 0) == 1) {}
 8014534:	bf00      	nop
 8014536:	4b12      	ldr	r3, [pc, #72]	; (8014580 <FPEC_ErasePage+0x90>)
 8014538:	68db      	ldr	r3, [r3, #12]
 801453a:	f003 0301 	and.w	r3, r3, #1
 801453e:	2b01      	cmp	r3, #1
 8014540:	d0f9      	beq.n	8014536 <FPEC_ErasePage+0x46>

	CLR_BIT(FLASH->CR, 1);   //Clear bit 1 to unselect page erase
 8014542:	4b0f      	ldr	r3, [pc, #60]	; (8014580 <FPEC_ErasePage+0x90>)
 8014544:	691b      	ldr	r3, [r3, #16]
 8014546:	4a0e      	ldr	r2, [pc, #56]	; (8014580 <FPEC_ErasePage+0x90>)
 8014548:	f023 0302 	bic.w	r3, r3, #2
 801454c:	6113      	str	r3, [r2, #16]

	/* read first half word of this page to make sure it's erased successfully */
	if(FPEC_ReadHalfWord(pageNumber, 0) == 0xFFFF)
 801454e:	79fb      	ldrb	r3, [r7, #7]
 8014550:	2100      	movs	r1, #0
 8014552:	4618      	mov	r0, r3
 8014554:	f000 f86e 	bl	8014634 <FPEC_ReadHalfWord>
 8014558:	4603      	mov	r3, r0
 801455a:	461a      	mov	r2, r3
 801455c:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8014560:	429a      	cmp	r2, r3
 8014562:	d102      	bne.n	801456a <FPEC_ErasePage+0x7a>
	{
		eraseStatus = FPEC_NO_ERRORS;
 8014564:	2302      	movs	r3, #2
 8014566:	73fb      	strb	r3, [r7, #15]
 8014568:	e003      	b.n	8014572 <FPEC_ErasePage+0x82>
	}
	else
	{
		eraseStatus = FPEC_CheckErrors();
 801456a:	f7ff ff23 	bl	80143b4 <FPEC_CheckErrors>
 801456e:	4603      	mov	r3, r0
 8014570:	73fb      	strb	r3, [r7, #15]
	}

	FPEC_LockFlash();
 8014572:	f7ff ff11 	bl	8014398 <FPEC_LockFlash>

	return eraseStatus;
 8014576:	7bfb      	ldrb	r3, [r7, #15]
}
 8014578:	4618      	mov	r0, r3
 801457a:	3710      	adds	r7, #16
 801457c:	46bd      	mov	sp, r7
 801457e:	bd80      	pop	{r7, pc}
 8014580:	40022000 	.word	0x40022000

08014584 <FPEC_WritePage>:
  * @param  pageNumber: number of the page where you want to write.
  * @param  data: array that contains actual data you want to write.
  * @retval Flash error.
  */
FPEC_Error_t  FPEC_WritePage(u8 pageNumber, u16* data)
{
 8014584:	b580      	push	{r7, lr}
 8014586:	b084      	sub	sp, #16
 8014588:	af00      	add	r7, sp, #0
 801458a:	4603      	mov	r3, r0
 801458c:	6039      	str	r1, [r7, #0]
 801458e:	71fb      	strb	r3, [r7, #7]
	FPEC_Error_t writeStatus = FPEC_NO_ERRORS;
 8014590:	2302      	movs	r3, #2
 8014592:	73fb      	strb	r3, [r7, #15]

	FPEC_UnlockFlash();
 8014594:	f7ff feee 	bl	8014374 <FPEC_UnlockFlash>

	/* To write on a page, it must be erased first */
	writeStatus = FPEC_ErasePage(pageNumber);
 8014598:	79fb      	ldrb	r3, [r7, #7]
 801459a:	4618      	mov	r0, r3
 801459c:	f7ff ffa8 	bl	80144f0 <FPEC_ErasePage>
 80145a0:	4603      	mov	r3, r0
 80145a2:	73fb      	strb	r3, [r7, #15]

	/* Write the data on the page by half word at a time */
	for(u16 i=0; i<PAGE_SIZE_HALF_WORDS; i++)
 80145a4:	2300      	movs	r3, #0
 80145a6:	81bb      	strh	r3, [r7, #12]
 80145a8:	e014      	b.n	80145d4 <FPEC_WritePage+0x50>
	{
		u16 offsetAddress = i * HALF_WORD_SIZE;
 80145aa:	89bb      	ldrh	r3, [r7, #12]
 80145ac:	005b      	lsls	r3, r3, #1
 80145ae:	817b      	strh	r3, [r7, #10]
		writeStatus = FPEC_DirectWriteHalfWord(pageNumber, offsetAddress, data[i]);
 80145b0:	89bb      	ldrh	r3, [r7, #12]
 80145b2:	005b      	lsls	r3, r3, #1
 80145b4:	683a      	ldr	r2, [r7, #0]
 80145b6:	4413      	add	r3, r2
 80145b8:	881a      	ldrh	r2, [r3, #0]
 80145ba:	8979      	ldrh	r1, [r7, #10]
 80145bc:	79fb      	ldrb	r3, [r7, #7]
 80145be:	4618      	mov	r0, r3
 80145c0:	f7ff ff20 	bl	8014404 <FPEC_DirectWriteHalfWord>
 80145c4:	4603      	mov	r3, r0
 80145c6:	73fb      	strb	r3, [r7, #15]

		/* If there were errors while writing, don't continue writing */
		if(writeStatus != FPEC_NO_ERRORS)		break;
 80145c8:	7bfb      	ldrb	r3, [r7, #15]
 80145ca:	2b02      	cmp	r3, #2
 80145cc:	d107      	bne.n	80145de <FPEC_WritePage+0x5a>
	for(u16 i=0; i<PAGE_SIZE_HALF_WORDS; i++)
 80145ce:	89bb      	ldrh	r3, [r7, #12]
 80145d0:	3301      	adds	r3, #1
 80145d2:	81bb      	strh	r3, [r7, #12]
 80145d4:	89bb      	ldrh	r3, [r7, #12]
 80145d6:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 80145da:	d3e6      	bcc.n	80145aa <FPEC_WritePage+0x26>
 80145dc:	e000      	b.n	80145e0 <FPEC_WritePage+0x5c>
		if(writeStatus != FPEC_NO_ERRORS)		break;
 80145de:	bf00      	nop
	}

	FPEC_LockFlash();
 80145e0:	f7ff feda 	bl	8014398 <FPEC_LockFlash>

	return writeStatus;
 80145e4:	7bfb      	ldrb	r3, [r7, #15]
}
 80145e6:	4618      	mov	r0, r3
 80145e8:	3710      	adds	r7, #16
 80145ea:	46bd      	mov	sp, r7
 80145ec:	bd80      	pop	{r7, pc}

080145ee <FPEC_ReadPage>:
  * @param  pageNumber: number of the page you want to read.
  * @param  data: the function will fill this array with the data stored in the desired page.
  * @retval Flash error.
  */
void  FPEC_ReadPage(u8 pageNumber, u16* data)
{
 80145ee:	b590      	push	{r4, r7, lr}
 80145f0:	b085      	sub	sp, #20
 80145f2:	af00      	add	r7, sp, #0
 80145f4:	4603      	mov	r3, r0
 80145f6:	6039      	str	r1, [r7, #0]
 80145f8:	71fb      	strb	r3, [r7, #7]
	/* Read the whole page by reading half word at a time */
	for(u16 i=0; i<PAGE_SIZE_HALF_WORDS; i++)
 80145fa:	2300      	movs	r3, #0
 80145fc:	81fb      	strh	r3, [r7, #14]
 80145fe:	e011      	b.n	8014624 <FPEC_ReadPage+0x36>
	{
		u16 offsetAddress = i * HALF_WORD_SIZE;
 8014600:	89fb      	ldrh	r3, [r7, #14]
 8014602:	005b      	lsls	r3, r3, #1
 8014604:	81bb      	strh	r3, [r7, #12]
		data[i] = FPEC_ReadHalfWord(pageNumber, offsetAddress);
 8014606:	89fb      	ldrh	r3, [r7, #14]
 8014608:	005b      	lsls	r3, r3, #1
 801460a:	683a      	ldr	r2, [r7, #0]
 801460c:	18d4      	adds	r4, r2, r3
 801460e:	89ba      	ldrh	r2, [r7, #12]
 8014610:	79fb      	ldrb	r3, [r7, #7]
 8014612:	4611      	mov	r1, r2
 8014614:	4618      	mov	r0, r3
 8014616:	f000 f80d 	bl	8014634 <FPEC_ReadHalfWord>
 801461a:	4603      	mov	r3, r0
 801461c:	8023      	strh	r3, [r4, #0]
	for(u16 i=0; i<PAGE_SIZE_HALF_WORDS; i++)
 801461e:	89fb      	ldrh	r3, [r7, #14]
 8014620:	3301      	adds	r3, #1
 8014622:	81fb      	strh	r3, [r7, #14]
 8014624:	89fb      	ldrh	r3, [r7, #14]
 8014626:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 801462a:	d3e9      	bcc.n	8014600 <FPEC_ReadPage+0x12>
	}
}
 801462c:	bf00      	nop
 801462e:	3714      	adds	r7, #20
 8014630:	46bd      	mov	sp, r7
 8014632:	bd90      	pop	{r4, r7, pc}

08014634 <FPEC_ReadHalfWord>:
  * @param  offsetAddress: offset address of the half word you want to read.
  * @param  data: the function will fill this array with the data stored in the desired page.
  * @retval data stored in the desired half word.
  */
u16  FPEC_ReadHalfWord(u8 pageNumber, u16 offsetAddress)
{
 8014634:	b480      	push	{r7}
 8014636:	b085      	sub	sp, #20
 8014638:	af00      	add	r7, sp, #0
 801463a:	4603      	mov	r3, r0
 801463c:	460a      	mov	r2, r1
 801463e:	71fb      	strb	r3, [r7, #7]
 8014640:	4613      	mov	r3, r2
 8014642:	80bb      	strh	r3, [r7, #4]
	/* Wait if the flash is busy */
	while(GET_BIT(FLASH->SR, 0) == 1) {}
 8014644:	bf00      	nop
 8014646:	4b0b      	ldr	r3, [pc, #44]	; (8014674 <FPEC_ReadHalfWord+0x40>)
 8014648:	68db      	ldr	r3, [r3, #12]
 801464a:	f003 0301 	and.w	r3, r3, #1
 801464e:	2b01      	cmp	r3, #1
 8014650:	d0f9      	beq.n	8014646 <FPEC_ReadHalfWord+0x12>

	/* Get physical address of the desired half word */
	volatile u16* physicalAddress = (volatile u16*)(FLASH_BASE_ADDRESS + pageNumber * PAGE_SIZE_BYTES + offsetAddress);
 8014652:	79fb      	ldrb	r3, [r7, #7]
 8014654:	029b      	lsls	r3, r3, #10
 8014656:	461a      	mov	r2, r3
 8014658:	88bb      	ldrh	r3, [r7, #4]
 801465a:	4413      	add	r3, r2
 801465c:	f103 6300 	add.w	r3, r3, #134217728	; 0x8000000
 8014660:	60fb      	str	r3, [r7, #12]

	/* Read data from this physical address */
	return *physicalAddress;
 8014662:	68fb      	ldr	r3, [r7, #12]
 8014664:	881b      	ldrh	r3, [r3, #0]
 8014666:	b29b      	uxth	r3, r3
}
 8014668:	4618      	mov	r0, r3
 801466a:	3714      	adds	r7, #20
 801466c:	46bd      	mov	sp, r7
 801466e:	bc80      	pop	{r7}
 8014670:	4770      	bx	lr
 8014672:	bf00      	nop
 8014674:	40022000 	.word	0x40022000

08014678 <FPEC_WriteByte>:
  * @param  offsetAddress: offset address of the half word you want to write.
  * @param  data: actual data you want to write.
  * @retval Flash error.
  */
FPEC_Error_t  FPEC_WriteByte(u8 pageNumber, u16 offsetAddress, u8 data)
{
 8014678:	b590      	push	{r4, r7, lr}
 801467a:	f2ad 4d14 	subw	sp, sp, #1044	; 0x414
 801467e:	af00      	add	r7, sp, #0
 8014680:	4604      	mov	r4, r0
 8014682:	4608      	mov	r0, r1
 8014684:	4611      	mov	r1, r2
 8014686:	1dfb      	adds	r3, r7, #7
 8014688:	4622      	mov	r2, r4
 801468a:	701a      	strb	r2, [r3, #0]
 801468c:	1d3b      	adds	r3, r7, #4
 801468e:	4602      	mov	r2, r0
 8014690:	801a      	strh	r2, [r3, #0]
 8014692:	1dbb      	adds	r3, r7, #6
 8014694:	460a      	mov	r2, r1
 8014696:	701a      	strb	r2, [r3, #0]
	/* Read the content of the desired page */
	u16 pageData[PAGE_SIZE_HALF_WORDS];
	FPEC_ReadPage(pageNumber, pageData);
 8014698:	f107 020c 	add.w	r2, r7, #12
 801469c:	1dfb      	adds	r3, r7, #7
 801469e:	781b      	ldrb	r3, [r3, #0]
 80146a0:	4611      	mov	r1, r2
 80146a2:	4618      	mov	r0, r3
 80146a4:	f7ff ffa3 	bl	80145ee <FPEC_ReadPage>

	/* modify the desired byte */
	u16 originalhalfWord = pageData[offsetAddress/2];
 80146a8:	1d3b      	adds	r3, r7, #4
 80146aa:	881b      	ldrh	r3, [r3, #0]
 80146ac:	085b      	lsrs	r3, r3, #1
 80146ae:	b29b      	uxth	r3, r3
 80146b0:	461a      	mov	r2, r3
 80146b2:	f107 030c 	add.w	r3, r7, #12
 80146b6:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
 80146ba:	f8a7 340e 	strh.w	r3, [r7, #1038]	; 0x40e
	if(offsetAddress % 2 == 0)
 80146be:	1d3b      	adds	r3, r7, #4
 80146c0:	881b      	ldrh	r3, [r3, #0]
 80146c2:	f003 0301 	and.w	r3, r3, #1
 80146c6:	b29b      	uxth	r3, r3
 80146c8:	2b00      	cmp	r3, #0
 80146ca:	d10e      	bne.n	80146ea <FPEC_WriteByte+0x72>
	{
		originalhalfWord &= 0xFF00;
 80146cc:	f8b7 340e 	ldrh.w	r3, [r7, #1038]	; 0x40e
 80146d0:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
 80146d4:	f8a7 340e 	strh.w	r3, [r7, #1038]	; 0x40e
		originalhalfWord |= data;
 80146d8:	1dbb      	adds	r3, r7, #6
 80146da:	781b      	ldrb	r3, [r3, #0]
 80146dc:	b29a      	uxth	r2, r3
 80146de:	f8b7 340e 	ldrh.w	r3, [r7, #1038]	; 0x40e
 80146e2:	4313      	orrs	r3, r2
 80146e4:	f8a7 340e 	strh.w	r3, [r7, #1038]	; 0x40e
 80146e8:	e00e      	b.n	8014708 <FPEC_WriteByte+0x90>
	}
	else
	{
		originalhalfWord &= 0x00FF;
 80146ea:	f8b7 340e 	ldrh.w	r3, [r7, #1038]	; 0x40e
 80146ee:	b2db      	uxtb	r3, r3
 80146f0:	f8a7 340e 	strh.w	r3, [r7, #1038]	; 0x40e
		originalhalfWord |= (((u16)data)<<8);
 80146f4:	1dbb      	adds	r3, r7, #6
 80146f6:	781b      	ldrb	r3, [r3, #0]
 80146f8:	021b      	lsls	r3, r3, #8
 80146fa:	b21a      	sxth	r2, r3
 80146fc:	f9b7 340e 	ldrsh.w	r3, [r7, #1038]	; 0x40e
 8014700:	4313      	orrs	r3, r2
 8014702:	b21b      	sxth	r3, r3
 8014704:	f8a7 340e 	strh.w	r3, [r7, #1038]	; 0x40e
	}
	pageData[offsetAddress/2] = originalhalfWord;
 8014708:	1d3b      	adds	r3, r7, #4
 801470a:	881b      	ldrh	r3, [r3, #0]
 801470c:	085b      	lsrs	r3, r3, #1
 801470e:	b29b      	uxth	r3, r3
 8014710:	4619      	mov	r1, r3
 8014712:	f107 030c 	add.w	r3, r7, #12
 8014716:	f8b7 240e 	ldrh.w	r2, [r7, #1038]	; 0x40e
 801471a:	f823 2011 	strh.w	r2, [r3, r1, lsl #1]

	/* Erase page */
	FPEC_Error_t eraseStatus = FPEC_ErasePage(pageNumber);
 801471e:	1dfb      	adds	r3, r7, #7
 8014720:	781b      	ldrb	r3, [r3, #0]
 8014722:	4618      	mov	r0, r3
 8014724:	f7ff fee4 	bl	80144f0 <FPEC_ErasePage>
 8014728:	4603      	mov	r3, r0
 801472a:	f887 340d 	strb.w	r3, [r7, #1037]	; 0x40d
	if(eraseStatus != FPEC_NO_ERRORS)
 801472e:	f897 340d 	ldrb.w	r3, [r7, #1037]	; 0x40d
 8014732:	2b02      	cmp	r3, #2
 8014734:	d002      	beq.n	801473c <FPEC_WriteByte+0xc4>
	{
		return eraseStatus;
 8014736:	f897 340d 	ldrb.w	r3, [r7, #1037]	; 0x40d
 801473a:	e012      	b.n	8014762 <FPEC_WriteByte+0xea>
	}

	/* Rewrite the page again after modifications */
	FPEC_Error_t writeStatus = FPEC_WritePage(pageNumber, pageData);
 801473c:	f107 020c 	add.w	r2, r7, #12
 8014740:	1dfb      	adds	r3, r7, #7
 8014742:	781b      	ldrb	r3, [r3, #0]
 8014744:	4611      	mov	r1, r2
 8014746:	4618      	mov	r0, r3
 8014748:	f7ff ff1c 	bl	8014584 <FPEC_WritePage>
 801474c:	4603      	mov	r3, r0
 801474e:	f887 340c 	strb.w	r3, [r7, #1036]	; 0x40c
	if(writeStatus != FPEC_NO_ERRORS)
 8014752:	f897 340c 	ldrb.w	r3, [r7, #1036]	; 0x40c
 8014756:	2b02      	cmp	r3, #2
 8014758:	d002      	beq.n	8014760 <FPEC_WriteByte+0xe8>
	{
		return writeStatus;
 801475a:	f897 340c 	ldrb.w	r3, [r7, #1036]	; 0x40c
 801475e:	e000      	b.n	8014762 <FPEC_WriteByte+0xea>
	}

	return FPEC_NO_ERRORS;
 8014760:	2302      	movs	r3, #2
}
 8014762:	4618      	mov	r0, r3
 8014764:	f207 4714 	addw	r7, r7, #1044	; 0x414
 8014768:	46bd      	mov	sp, r7
 801476a:	bd90      	pop	{r4, r7, pc}

0801476c <GPIO_InitPin>:




static void  GPIO_InitPin(GPIO_Pin_t* pin, const GPIO_PinConfg_t* pinConfg)
{
 801476c:	b590      	push	{r4, r7, lr}
 801476e:	b083      	sub	sp, #12
 8014770:	af00      	add	r7, sp, #0
 8014772:	6078      	str	r0, [r7, #4]
 8014774:	6039      	str	r1, [r7, #0]
	if(pin->pinNumber < 8)
 8014776:	687b      	ldr	r3, [r7, #4]
 8014778:	885b      	ldrh	r3, [r3, #2]
 801477a:	2b07      	cmp	r3, #7
 801477c:	d813      	bhi.n	80147a6 <GPIO_InitPin+0x3a>
	{
		GPIO[pin->port]->CRL = GPIO_GetNewValueOfCR(pin, pinConfg, GPIO[pin->port]->CRL);
 801477e:	687b      	ldr	r3, [r7, #4]
 8014780:	781b      	ldrb	r3, [r3, #0]
 8014782:	461a      	mov	r2, r3
 8014784:	4b2d      	ldr	r3, [pc, #180]	; (801483c <GPIO_InitPin+0xd0>)
 8014786:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 801478a:	681a      	ldr	r2, [r3, #0]
 801478c:	687b      	ldr	r3, [r7, #4]
 801478e:	781b      	ldrb	r3, [r3, #0]
 8014790:	4619      	mov	r1, r3
 8014792:	4b2a      	ldr	r3, [pc, #168]	; (801483c <GPIO_InitPin+0xd0>)
 8014794:	f853 4021 	ldr.w	r4, [r3, r1, lsl #2]
 8014798:	6839      	ldr	r1, [r7, #0]
 801479a:	6878      	ldr	r0, [r7, #4]
 801479c:	f000 f850 	bl	8014840 <GPIO_GetNewValueOfCR>
 80147a0:	4603      	mov	r3, r0
 80147a2:	6023      	str	r3, [r4, #0]
 80147a4:	e022      	b.n	80147ec <GPIO_InitPin+0x80>
	}
	else if(pin->pinNumber < 16)
 80147a6:	687b      	ldr	r3, [r7, #4]
 80147a8:	885b      	ldrh	r3, [r3, #2]
 80147aa:	2b0f      	cmp	r3, #15
 80147ac:	d81e      	bhi.n	80147ec <GPIO_InitPin+0x80>
	{
		pin->pinNumber -= 8;
 80147ae:	687b      	ldr	r3, [r7, #4]
 80147b0:	885b      	ldrh	r3, [r3, #2]
 80147b2:	3b08      	subs	r3, #8
 80147b4:	b29a      	uxth	r2, r3
 80147b6:	687b      	ldr	r3, [r7, #4]
 80147b8:	805a      	strh	r2, [r3, #2]
		GPIO[pin->port]->CRH = GPIO_GetNewValueOfCR(pin, pinConfg, GPIO[pin->port]->CRH);
 80147ba:	687b      	ldr	r3, [r7, #4]
 80147bc:	781b      	ldrb	r3, [r3, #0]
 80147be:	461a      	mov	r2, r3
 80147c0:	4b1e      	ldr	r3, [pc, #120]	; (801483c <GPIO_InitPin+0xd0>)
 80147c2:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80147c6:	685a      	ldr	r2, [r3, #4]
 80147c8:	687b      	ldr	r3, [r7, #4]
 80147ca:	781b      	ldrb	r3, [r3, #0]
 80147cc:	4619      	mov	r1, r3
 80147ce:	4b1b      	ldr	r3, [pc, #108]	; (801483c <GPIO_InitPin+0xd0>)
 80147d0:	f853 4021 	ldr.w	r4, [r3, r1, lsl #2]
 80147d4:	6839      	ldr	r1, [r7, #0]
 80147d6:	6878      	ldr	r0, [r7, #4]
 80147d8:	f000 f832 	bl	8014840 <GPIO_GetNewValueOfCR>
 80147dc:	4603      	mov	r3, r0
 80147de:	6063      	str	r3, [r4, #4]
		pin->pinNumber += 8;
 80147e0:	687b      	ldr	r3, [r7, #4]
 80147e2:	885b      	ldrh	r3, [r3, #2]
 80147e4:	3308      	adds	r3, #8
 80147e6:	b29a      	uxth	r2, r3
 80147e8:	687b      	ldr	r3, [r7, #4]
 80147ea:	805a      	strh	r2, [r3, #2]
	}

	switch(pinConfg->pinMode)
 80147ec:	683b      	ldr	r3, [r7, #0]
 80147ee:	781b      	ldrb	r3, [r3, #0]
 80147f0:	2b02      	cmp	r3, #2
 80147f2:	d002      	beq.n	80147fa <GPIO_InitPin+0x8e>
 80147f4:	2b03      	cmp	r3, #3
 80147f6:	d00e      	beq.n	8014816 <GPIO_InitPin+0xaa>
			break;
		case INPUT_PULL_DOWN:
			GPIO[pin->port]->BRR  = 1<<(pin->pinNumber);
			break;
		default:
			break;
 80147f8:	e01b      	b.n	8014832 <GPIO_InitPin+0xc6>
			GPIO[pin->port]->BSRR = 1<<(pin->pinNumber);
 80147fa:	687b      	ldr	r3, [r7, #4]
 80147fc:	885b      	ldrh	r3, [r3, #2]
 80147fe:	461a      	mov	r2, r3
 8014800:	2301      	movs	r3, #1
 8014802:	fa03 f202 	lsl.w	r2, r3, r2
 8014806:	687b      	ldr	r3, [r7, #4]
 8014808:	781b      	ldrb	r3, [r3, #0]
 801480a:	4619      	mov	r1, r3
 801480c:	4b0b      	ldr	r3, [pc, #44]	; (801483c <GPIO_InitPin+0xd0>)
 801480e:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 8014812:	611a      	str	r2, [r3, #16]
			break;
 8014814:	e00d      	b.n	8014832 <GPIO_InitPin+0xc6>
			GPIO[pin->port]->BRR  = 1<<(pin->pinNumber);
 8014816:	687b      	ldr	r3, [r7, #4]
 8014818:	885b      	ldrh	r3, [r3, #2]
 801481a:	461a      	mov	r2, r3
 801481c:	2301      	movs	r3, #1
 801481e:	fa03 f202 	lsl.w	r2, r3, r2
 8014822:	687b      	ldr	r3, [r7, #4]
 8014824:	781b      	ldrb	r3, [r3, #0]
 8014826:	4619      	mov	r1, r3
 8014828:	4b04      	ldr	r3, [pc, #16]	; (801483c <GPIO_InitPin+0xd0>)
 801482a:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 801482e:	615a      	str	r2, [r3, #20]
			break;
 8014830:	bf00      	nop
	}
}
 8014832:	bf00      	nop
 8014834:	370c      	adds	r7, #12
 8014836:	46bd      	mov	sp, r7
 8014838:	bd90      	pop	{r4, r7, pc}
 801483a:	bf00      	nop
 801483c:	20000000 	.word	0x20000000

08014840 <GPIO_GetNewValueOfCR>:




static u32   GPIO_GetNewValueOfCR(GPIO_Pin_t* pin, const GPIO_PinConfg_t* pinConfg, u32 oldValueOfCR)
{
 8014840:	b480      	push	{r7}
 8014842:	b087      	sub	sp, #28
 8014844:	af00      	add	r7, sp, #0
 8014846:	60f8      	str	r0, [r7, #12]
 8014848:	60b9      	str	r1, [r7, #8]
 801484a:	607a      	str	r2, [r7, #4]
	u32 CRValue = oldValueOfCR;
 801484c:	687b      	ldr	r3, [r7, #4]
 801484e:	617b      	str	r3, [r7, #20]

	/* Clear corresponding two MODE bits and two CNF bits */
	CRValue &= ~(0xFUL<<(4*(pin->pinNumber))) ;
 8014850:	68fb      	ldr	r3, [r7, #12]
 8014852:	885b      	ldrh	r3, [r3, #2]
 8014854:	009b      	lsls	r3, r3, #2
 8014856:	220f      	movs	r2, #15
 8014858:	fa02 f303 	lsl.w	r3, r2, r3
 801485c:	43db      	mvns	r3, r3
 801485e:	697a      	ldr	r2, [r7, #20]
 8014860:	4013      	ands	r3, r2
 8014862:	617b      	str	r3, [r7, #20]


	switch (pinConfg->pinMode)
 8014864:	68bb      	ldr	r3, [r7, #8]
 8014866:	781b      	ldrb	r3, [r3, #0]
 8014868:	2b07      	cmp	r3, #7
 801486a:	d833      	bhi.n	80148d4 <GPIO_GetNewValueOfCR+0x94>
 801486c:	a201      	add	r2, pc, #4	; (adr r2, 8014874 <GPIO_GetNewValueOfCR+0x34>)
 801486e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8014872:	bf00      	nop
 8014874:	080148d5 	.word	0x080148d5
 8014878:	08014895 	.word	0x08014895
 801487c:	080148bf 	.word	0x080148bf
 8014880:	080148bf 	.word	0x080148bf
 8014884:	08014895 	.word	0x08014895
 8014888:	080148d5 	.word	0x080148d5
 801488c:	080148bf 	.word	0x080148bf
 8014890:	080148ab 	.word	0x080148ab
			/* Nothing to do here */
			break;

		case INPUT_FLOATING:
		case GENERAL_PURPOSE_OUTPUT_OPEN_DRAIN:
			SET_BIT(CRValue, 4*(pin->pinNumber)+2);
 8014894:	68fb      	ldr	r3, [r7, #12]
 8014896:	885b      	ldrh	r3, [r3, #2]
 8014898:	009b      	lsls	r3, r3, #2
 801489a:	3302      	adds	r3, #2
 801489c:	2201      	movs	r2, #1
 801489e:	fa02 f303 	lsl.w	r3, r2, r3
 80148a2:	697a      	ldr	r2, [r7, #20]
 80148a4:	4313      	orrs	r3, r2
 80148a6:	617b      	str	r3, [r7, #20]
			break;
 80148a8:	e015      	b.n	80148d6 <GPIO_GetNewValueOfCR+0x96>

		case ALTERNATE_FUNCTION_OUTPUT_OPEN_DRAIN:
			SET_BIT(CRValue, 4*(pin->pinNumber)+2);
 80148aa:	68fb      	ldr	r3, [r7, #12]
 80148ac:	885b      	ldrh	r3, [r3, #2]
 80148ae:	009b      	lsls	r3, r3, #2
 80148b0:	3302      	adds	r3, #2
 80148b2:	2201      	movs	r2, #1
 80148b4:	fa02 f303 	lsl.w	r3, r2, r3
 80148b8:	697a      	ldr	r2, [r7, #20]
 80148ba:	4313      	orrs	r3, r2
 80148bc:	617b      	str	r3, [r7, #20]

		case INPUT_PULL_UP:
		case INPUT_PULL_DOWN:
		case ALTERNATE_FUNCTION_OUTPUT_PUSH_PULL:
			SET_BIT(CRValue, 4*(pin->pinNumber)+3);
 80148be:	68fb      	ldr	r3, [r7, #12]
 80148c0:	885b      	ldrh	r3, [r3, #2]
 80148c2:	009b      	lsls	r3, r3, #2
 80148c4:	3303      	adds	r3, #3
 80148c6:	2201      	movs	r2, #1
 80148c8:	fa02 f303 	lsl.w	r3, r2, r3
 80148cc:	697a      	ldr	r2, [r7, #20]
 80148ce:	4313      	orrs	r3, r2
 80148d0:	617b      	str	r3, [r7, #20]
			break;
 80148d2:	e000      	b.n	80148d6 <GPIO_GetNewValueOfCR+0x96>

		default:
			break;
 80148d4:	bf00      	nop
	}

	switch(pinConfg->pinMode)
 80148d6:	68bb      	ldr	r3, [r7, #8]
 80148d8:	781b      	ldrb	r3, [r3, #0]
 80148da:	3b04      	subs	r3, #4
 80148dc:	2b03      	cmp	r3, #3
 80148de:	d827      	bhi.n	8014930 <GPIO_GetNewValueOfCR+0xf0>
	{
		case GENERAL_PURPOSE_OUTPUT_OPEN_DRAIN ... ALTERNATE_FUNCTION_OUTPUT_OPEN_DRAIN:
			switch (pinConfg->outputSpeed)
 80148e0:	68bb      	ldr	r3, [r7, #8]
 80148e2:	785b      	ldrb	r3, [r3, #1]
 80148e4:	2b01      	cmp	r3, #1
 80148e6:	d017      	beq.n	8014918 <GPIO_GetNewValueOfCR+0xd8>
 80148e8:	2b02      	cmp	r3, #2
 80148ea:	d00c      	beq.n	8014906 <GPIO_GetNewValueOfCR+0xc6>
 80148ec:	2b00      	cmp	r3, #0
 80148ee:	d000      	beq.n	80148f2 <GPIO_GetNewValueOfCR+0xb2>
				case OUTPUT_SPEED_2MHz:
					SET_BIT(CRValue, 4*(pin->pinNumber)+1);
					break;

				default:
					break;
 80148f0:	e01d      	b.n	801492e <GPIO_GetNewValueOfCR+0xee>
					SET_BIT(CRValue, 4*(pin->pinNumber));
 80148f2:	68fb      	ldr	r3, [r7, #12]
 80148f4:	885b      	ldrh	r3, [r3, #2]
 80148f6:	009b      	lsls	r3, r3, #2
 80148f8:	2201      	movs	r2, #1
 80148fa:	fa02 f303 	lsl.w	r3, r2, r3
 80148fe:	697a      	ldr	r2, [r7, #20]
 8014900:	4313      	orrs	r3, r2
 8014902:	617b      	str	r3, [r7, #20]
					break;
 8014904:	e013      	b.n	801492e <GPIO_GetNewValueOfCR+0xee>
					SET_BIT(CRValue, 4*(pin->pinNumber));
 8014906:	68fb      	ldr	r3, [r7, #12]
 8014908:	885b      	ldrh	r3, [r3, #2]
 801490a:	009b      	lsls	r3, r3, #2
 801490c:	2201      	movs	r2, #1
 801490e:	fa02 f303 	lsl.w	r3, r2, r3
 8014912:	697a      	ldr	r2, [r7, #20]
 8014914:	4313      	orrs	r3, r2
 8014916:	617b      	str	r3, [r7, #20]
					SET_BIT(CRValue, 4*(pin->pinNumber)+1);
 8014918:	68fb      	ldr	r3, [r7, #12]
 801491a:	885b      	ldrh	r3, [r3, #2]
 801491c:	009b      	lsls	r3, r3, #2
 801491e:	3301      	adds	r3, #1
 8014920:	2201      	movs	r2, #1
 8014922:	fa02 f303 	lsl.w	r3, r2, r3
 8014926:	697a      	ldr	r2, [r7, #20]
 8014928:	4313      	orrs	r3, r2
 801492a:	617b      	str	r3, [r7, #20]
					break;
 801492c:	bf00      	nop
			}
			break;
 801492e:	e000      	b.n	8014932 <GPIO_GetNewValueOfCR+0xf2>

		default:
			break;
 8014930:	bf00      	nop
	}

	return CRValue;
 8014932:	697b      	ldr	r3, [r7, #20]
}
 8014934:	4618      	mov	r0, r3
 8014936:	371c      	adds	r7, #28
 8014938:	46bd      	mov	sp, r7
 801493a:	bc80      	pop	{r7}
 801493c:	4770      	bx	lr
 801493e:	bf00      	nop

08014940 <GPIO_InitPins>:




void  GPIO_InitPins(const GPIO_Pin_t* groupOfPins, const GPIO_PinConfg_t* pinConfg)
{
 8014940:	b580      	push	{r7, lr}
 8014942:	b084      	sub	sp, #16
 8014944:	af00      	add	r7, sp, #0
 8014946:	6078      	str	r0, [r7, #4]
 8014948:	6039      	str	r1, [r7, #0]
	GPIO_Pin_t pin;
	pin.port = groupOfPins->port;
 801494a:	687b      	ldr	r3, [r7, #4]
 801494c:	781b      	ldrb	r3, [r3, #0]
 801494e:	723b      	strb	r3, [r7, #8]

	switch(pin.port)
 8014950:	7a3b      	ldrb	r3, [r7, #8]
 8014952:	2b01      	cmp	r3, #1
 8014954:	d007      	beq.n	8014966 <GPIO_InitPins+0x26>
 8014956:	2b02      	cmp	r3, #2
 8014958:	d009      	beq.n	801496e <GPIO_InitPins+0x2e>
 801495a:	2b00      	cmp	r3, #0
 801495c:	d10b      	bne.n	8014976 <GPIO_InitPins+0x36>
	{
		case GPIO_PORTA:
			RCC_EnablePeripheralClock(GPIOA_PERIPHERAL);
 801495e:	2042      	movs	r0, #66	; 0x42
 8014960:	f000 f914 	bl	8014b8c <RCC_EnablePeripheralClock>
			break;
 8014964:	e007      	b.n	8014976 <GPIO_InitPins+0x36>

		case GPIO_PORTB:
			RCC_EnablePeripheralClock(GPIOB_PERIPHERAL);
 8014966:	2043      	movs	r0, #67	; 0x43
 8014968:	f000 f910 	bl	8014b8c <RCC_EnablePeripheralClock>
			break;
 801496c:	e003      	b.n	8014976 <GPIO_InitPins+0x36>

		case GPIO_PORTC:
			RCC_EnablePeripheralClock(GPIOC_PERIPHERAL);
 801496e:	2044      	movs	r0, #68	; 0x44
 8014970:	f000 f90c 	bl	8014b8c <RCC_EnablePeripheralClock>
			break;
 8014974:	bf00      	nop
	}


	for(u8 pinNumCounter = 0; pinNumCounter < 16; pinNumCounter++)
 8014976:	2300      	movs	r3, #0
 8014978:	73fb      	strb	r3, [r7, #15]
 801497a:	e015      	b.n	80149a8 <GPIO_InitPins+0x68>
	{
		if(GET_BIT(groupOfPins->pinNumber, pinNumCounter) == 0)
 801497c:	687b      	ldr	r3, [r7, #4]
 801497e:	885b      	ldrh	r3, [r3, #2]
 8014980:	461a      	mov	r2, r3
 8014982:	7bfb      	ldrb	r3, [r7, #15]
 8014984:	fa42 f303 	asr.w	r3, r2, r3
 8014988:	f003 0301 	and.w	r3, r3, #1
 801498c:	2b00      	cmp	r3, #0
 801498e:	d108      	bne.n	80149a2 <GPIO_InitPins+0x62>
		{
			pin.pinNumber = pinNumCounter;
 8014990:	7bfb      	ldrb	r3, [r7, #15]
 8014992:	b29b      	uxth	r3, r3
 8014994:	817b      	strh	r3, [r7, #10]
			GPIO_InitPin(&pin, pinConfg);
 8014996:	f107 0308 	add.w	r3, r7, #8
 801499a:	6839      	ldr	r1, [r7, #0]
 801499c:	4618      	mov	r0, r3
 801499e:	f7ff fee5 	bl	801476c <GPIO_InitPin>
	for(u8 pinNumCounter = 0; pinNumCounter < 16; pinNumCounter++)
 80149a2:	7bfb      	ldrb	r3, [r7, #15]
 80149a4:	3301      	adds	r3, #1
 80149a6:	73fb      	strb	r3, [r7, #15]
 80149a8:	7bfb      	ldrb	r3, [r7, #15]
 80149aa:	2b0f      	cmp	r3, #15
 80149ac:	d9e6      	bls.n	801497c <GPIO_InitPins+0x3c>
		}
	}
}
 80149ae:	bf00      	nop
 80149b0:	3710      	adds	r7, #16
 80149b2:	46bd      	mov	sp, r7
 80149b4:	bd80      	pop	{r7, pc}
	...

080149b8 <GPIO_SetPinsOutputVoltage>:




void  GPIO_SetPinsOutputVoltage(const GPIO_Pin_t* groupOfPins, GPIO_PinLevel_t pinLevel)
{
 80149b8:	b480      	push	{r7}
 80149ba:	b083      	sub	sp, #12
 80149bc:	af00      	add	r7, sp, #0
 80149be:	6078      	str	r0, [r7, #4]
 80149c0:	460b      	mov	r3, r1
 80149c2:	70fb      	strb	r3, [r7, #3]
	switch(pinLevel)
 80149c4:	78fb      	ldrb	r3, [r7, #3]
 80149c6:	2b00      	cmp	r3, #0
 80149c8:	d002      	beq.n	80149d0 <GPIO_SetPinsOutputVoltage+0x18>
 80149ca:	2b01      	cmp	r3, #1
 80149cc:	d00b      	beq.n	80149e6 <GPIO_SetPinsOutputVoltage+0x2e>
			break;
		case GPIO_HIGH:
			GPIO[groupOfPins->port]->BRR  = ~(groupOfPins->pinNumber);
			break;
		default:
			break;
 80149ce:	e015      	b.n	80149fc <GPIO_SetPinsOutputVoltage+0x44>
			GPIO[groupOfPins->port]->BSRR = ~(groupOfPins->pinNumber);
 80149d0:	687b      	ldr	r3, [r7, #4]
 80149d2:	885b      	ldrh	r3, [r3, #2]
 80149d4:	43da      	mvns	r2, r3
 80149d6:	687b      	ldr	r3, [r7, #4]
 80149d8:	781b      	ldrb	r3, [r3, #0]
 80149da:	4619      	mov	r1, r3
 80149dc:	4b0a      	ldr	r3, [pc, #40]	; (8014a08 <GPIO_SetPinsOutputVoltage+0x50>)
 80149de:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 80149e2:	611a      	str	r2, [r3, #16]
			break;
 80149e4:	e00a      	b.n	80149fc <GPIO_SetPinsOutputVoltage+0x44>
			GPIO[groupOfPins->port]->BRR  = ~(groupOfPins->pinNumber);
 80149e6:	687b      	ldr	r3, [r7, #4]
 80149e8:	885b      	ldrh	r3, [r3, #2]
 80149ea:	43da      	mvns	r2, r3
 80149ec:	687b      	ldr	r3, [r7, #4]
 80149ee:	781b      	ldrb	r3, [r3, #0]
 80149f0:	4619      	mov	r1, r3
 80149f2:	4b05      	ldr	r3, [pc, #20]	; (8014a08 <GPIO_SetPinsOutputVoltage+0x50>)
 80149f4:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 80149f8:	615a      	str	r2, [r3, #20]
			break;
 80149fa:	bf00      	nop
	}
}
 80149fc:	bf00      	nop
 80149fe:	370c      	adds	r7, #12
 8014a00:	46bd      	mov	sp, r7
 8014a02:	bc80      	pop	{r7}
 8014a04:	4770      	bx	lr
 8014a06:	bf00      	nop
 8014a08:	20000000 	.word	0x20000000

08014a0c <NVIC_EnableInterrupt>:

#include  "NVIC.h"


void  NVIC_EnableInterrupt(IRQn_Type IRQnID)
{
 8014a0c:	b480      	push	{r7}
 8014a0e:	b083      	sub	sp, #12
 8014a10:	af00      	add	r7, sp, #0
 8014a12:	4603      	mov	r3, r0
 8014a14:	71fb      	strb	r3, [r7, #7]
	if(IRQnID >= 0)   //if IRQnID is an ID of Peripheral Interrupt not system exception
 8014a16:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8014a1a:	2b00      	cmp	r3, #0
 8014a1c:	db0d      	blt.n	8014a3a <NVIC_EnableInterrupt+0x2e>
	{
		NVIC->ISER[IRQnID>>5] = 1<<(IRQnID & 0x1F);
 8014a1e:	79fb      	ldrb	r3, [r7, #7]
 8014a20:	f003 031f 	and.w	r3, r3, #31
 8014a24:	2201      	movs	r2, #1
 8014a26:	fa02 f103 	lsl.w	r1, r2, r3
 8014a2a:	4a13      	ldr	r2, [pc, #76]	; (8014a78 <NVIC_EnableInterrupt+0x6c>)
 8014a2c:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8014a30:	115b      	asrs	r3, r3, #5
 8014a32:	b25b      	sxtb	r3, r3
 8014a34:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
	}
	else if(IRQnID == MemoryManagement_IRQn || IRQnID == BusFault_IRQn || IRQnID == UsageFault_IRQn)
	{
		SET_BIT(SCB->SHCSR, IRQnID + 28);
	}
}
 8014a38:	e019      	b.n	8014a6e <NVIC_EnableInterrupt+0x62>
	else if(IRQnID == MemoryManagement_IRQn || IRQnID == BusFault_IRQn || IRQnID == UsageFault_IRQn)
 8014a3a:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8014a3e:	f113 0f0c 	cmn.w	r3, #12
 8014a42:	d009      	beq.n	8014a58 <NVIC_EnableInterrupt+0x4c>
 8014a44:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8014a48:	f113 0f0b 	cmn.w	r3, #11
 8014a4c:	d004      	beq.n	8014a58 <NVIC_EnableInterrupt+0x4c>
 8014a4e:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8014a52:	f113 0f0a 	cmn.w	r3, #10
 8014a56:	d10a      	bne.n	8014a6e <NVIC_EnableInterrupt+0x62>
		SET_BIT(SCB->SHCSR, IRQnID + 28);
 8014a58:	4b08      	ldr	r3, [pc, #32]	; (8014a7c <NVIC_EnableInterrupt+0x70>)
 8014a5a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8014a5c:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8014a60:	331c      	adds	r3, #28
 8014a62:	2101      	movs	r1, #1
 8014a64:	fa01 f303 	lsl.w	r3, r1, r3
 8014a68:	4904      	ldr	r1, [pc, #16]	; (8014a7c <NVIC_EnableInterrupt+0x70>)
 8014a6a:	4313      	orrs	r3, r2
 8014a6c:	624b      	str	r3, [r1, #36]	; 0x24
}
 8014a6e:	bf00      	nop
 8014a70:	370c      	adds	r7, #12
 8014a72:	46bd      	mov	sp, r7
 8014a74:	bc80      	pop	{r7}
 8014a76:	4770      	bx	lr
 8014a78:	e000e100 	.word	0xe000e100
 8014a7c:	e000ed00 	.word	0xe000ed00

08014a80 <NVIC_ResetSystem>:




void  NVIC_ResetSystem(void)
{
 8014a80:	b480      	push	{r7}
 8014a82:	af00      	add	r7, sp, #0
	SCB->AIRCR = 0x05FA0004;
 8014a84:	4b03      	ldr	r3, [pc, #12]	; (8014a94 <NVIC_ResetSystem+0x14>)
 8014a86:	4a04      	ldr	r2, [pc, #16]	; (8014a98 <NVIC_ResetSystem+0x18>)
 8014a88:	60da      	str	r2, [r3, #12]
}
 8014a8a:	bf00      	nop
 8014a8c:	46bd      	mov	sp, r7
 8014a8e:	bc80      	pop	{r7}
 8014a90:	4770      	bx	lr
 8014a92:	bf00      	nop
 8014a94:	e000ed00 	.word	0xe000ed00
 8014a98:	05fa0004 	.word	0x05fa0004

08014a9c <NVIC_MaskIRQs>:
	}
}


void  NVIC_MaskIRQs(u8 thresholdPriority)
{
 8014a9c:	b480      	push	{r7}
 8014a9e:	b085      	sub	sp, #20
 8014aa0:	af00      	add	r7, sp, #0
 8014aa2:	4603      	mov	r3, r0
 8014aa4:	71fb      	strb	r3, [r7, #7]
	__set_BASEPRI(thresholdPriority);
 8014aa6:	79fb      	ldrb	r3, [r7, #7]
 8014aa8:	60bb      	str	r3, [r7, #8]
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__STATIC_FORCEINLINE void __set_BASEPRI(uint32_t basePri)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8014aaa:	68bb      	ldr	r3, [r7, #8]
 8014aac:	f383 8811 	msr	BASEPRI, r3
 8014ab0:	2301      	movs	r3, #1
 8014ab2:	60fb      	str	r3, [r7, #12]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8014ab4:	68fb      	ldr	r3, [r7, #12]
 8014ab6:	f383 8810 	msr	PRIMASK, r3
	__set_PRIMASK(1);
}
 8014aba:	bf00      	nop
 8014abc:	3714      	adds	r7, #20
 8014abe:	46bd      	mov	sp, r7
 8014ac0:	bc80      	pop	{r7}
 8014ac2:	4770      	bx	lr

08014ac4 <NVIC_UnMaskIRQs>:


void  NVIC_UnMaskIRQs(void)
{
 8014ac4:	b480      	push	{r7}
 8014ac6:	b083      	sub	sp, #12
 8014ac8:	af00      	add	r7, sp, #0
 8014aca:	2300      	movs	r3, #0
 8014acc:	607b      	str	r3, [r7, #4]
 8014ace:	687b      	ldr	r3, [r7, #4]
 8014ad0:	f383 8810 	msr	PRIMASK, r3
	__set_PRIMASK(0);
}
 8014ad4:	bf00      	nop
 8014ad6:	370c      	adds	r7, #12
 8014ad8:	46bd      	mov	sp, r7
 8014ada:	bc80      	pop	{r7}
 8014adc:	4770      	bx	lr
	...

08014ae0 <RCC_InitClock>:
#include "RCC.h"

void  RCC_InitClock(void)
{
 8014ae0:	b580      	push	{r7, lr}
 8014ae2:	af00      	add	r7, sp, #0
	RCC->CR = 0x1;   //enable HSI
 8014ae4:	4b28      	ldr	r3, [pc, #160]	; (8014b88 <RCC_InitClock+0xa8>)
 8014ae6:	2201      	movs	r2, #1
 8014ae8:	601a      	str	r2, [r3, #0]
	RCC->CFGR = 0;   //select HSI as system clock
 8014aea:	4b27      	ldr	r3, [pc, #156]	; (8014b88 <RCC_InitClock+0xa8>)
 8014aec:	2200      	movs	r2, #0
 8014aee:	605a      	str	r2, [r3, #4]
	RCC->CIR  = 0x9F0000;   //disable all RCC interrupts , clear all flags
 8014af0:	4b25      	ldr	r3, [pc, #148]	; (8014b88 <RCC_InitClock+0xa8>)
 8014af2:	f44f 021f 	mov.w	r2, #10420224	; 0x9f0000
 8014af6:	609a      	str	r2, [r3, #8]
	
	RCC_EnablePeripheralClock(FLITF_PERIPHERAL);
 8014af8:	2004      	movs	r0, #4
 8014afa:	f000 f847 	bl	8014b8c <RCC_EnablePeripheralClock>
	FPEC_InitFlash();
 8014afe:	f7ff fcd7 	bl	80144b0 <FPEC_InitFlash>
	
	
	#if  APB1_DIVISION_FACTOR == 1
		/* do nothing, AHB division factor is already 1 */
	#elif  APB1_DIVISION_FACTOR == 2
		RCC->CFGR |= 0x400;
 8014b02:	4b21      	ldr	r3, [pc, #132]	; (8014b88 <RCC_InitClock+0xa8>)
 8014b04:	685b      	ldr	r3, [r3, #4]
 8014b06:	4a20      	ldr	r2, [pc, #128]	; (8014b88 <RCC_InitClock+0xa8>)
 8014b08:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8014b0c:	6053      	str	r3, [r2, #4]
	#endif
	
	

	#if  CLK_SECURITY_SYSTEM_STATE == ENABLED
		SET_BIT(RCC->CR, 19);
 8014b0e:	4b1e      	ldr	r3, [pc, #120]	; (8014b88 <RCC_InitClock+0xa8>)
 8014b10:	681b      	ldr	r3, [r3, #0]
 8014b12:	4a1d      	ldr	r2, [pc, #116]	; (8014b88 <RCC_InitClock+0xa8>)
 8014b14:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 8014b18:	6013      	str	r3, [r2, #0]
	#if  HSE_STATE == ENABLED
		#if  HSE_SRC == HSE_RC
			SET_BIT(RCC->CR, 18);  //select RC as HSE
		#endif
		
		SET_BIT(RCC->CR, 16);   //enable HSE
 8014b1a:	4b1b      	ldr	r3, [pc, #108]	; (8014b88 <RCC_InitClock+0xa8>)
 8014b1c:	681b      	ldr	r3, [r3, #0]
 8014b1e:	4a1a      	ldr	r2, [pc, #104]	; (8014b88 <RCC_InitClock+0xa8>)
 8014b20:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8014b24:	6013      	str	r3, [r2, #0]
		while(GET_BIT(RCC->CR, 17) == 0);   //wait until HSE is ready
 8014b26:	bf00      	nop
 8014b28:	4b17      	ldr	r3, [pc, #92]	; (8014b88 <RCC_InitClock+0xa8>)
 8014b2a:	681b      	ldr	r3, [r3, #0]
 8014b2c:	0c5b      	lsrs	r3, r3, #17
 8014b2e:	f003 0301 	and.w	r3, r3, #1
 8014b32:	2b00      	cmp	r3, #0
 8014b34:	d0f8      	beq.n	8014b28 <RCC_InitClock+0x48>
	
	
	
	#if  PLL_STATE == ENABLED
		#if  PLL_SRC == HSE
			SET_BIT(RCC->CFGR, 16);   //select HSE as PLL input clock 
 8014b36:	4b14      	ldr	r3, [pc, #80]	; (8014b88 <RCC_InitClock+0xa8>)
 8014b38:	685b      	ldr	r3, [r3, #4]
 8014b3a:	4a13      	ldr	r2, [pc, #76]	; (8014b88 <RCC_InitClock+0xa8>)
 8014b3c:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8014b40:	6053      	str	r3, [r2, #4]
			SET_BIT(RCC->CFGR, 16);   //select HSE/2 as PLL input clock 
		#elif  PLL_SRC == HSI_DIVIDED_BY_2
			/* do nothing, HSI/2 is already selected as PLL input clock */
		#endif
		
		RCC->CFGR |= ((PLL_FACTOR-2)<<18);   //select PLL multiplication factor
 8014b42:	4b11      	ldr	r3, [pc, #68]	; (8014b88 <RCC_InitClock+0xa8>)
 8014b44:	685b      	ldr	r3, [r3, #4]
 8014b46:	4a10      	ldr	r2, [pc, #64]	; (8014b88 <RCC_InitClock+0xa8>)
 8014b48:	f443 13e0 	orr.w	r3, r3, #1835008	; 0x1c0000
 8014b4c:	6053      	str	r3, [r2, #4]
		SET_BIT(RCC->CR, 24);                //enable PLL
 8014b4e:	4b0e      	ldr	r3, [pc, #56]	; (8014b88 <RCC_InitClock+0xa8>)
 8014b50:	681b      	ldr	r3, [r3, #0]
 8014b52:	4a0d      	ldr	r2, [pc, #52]	; (8014b88 <RCC_InitClock+0xa8>)
 8014b54:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8014b58:	6013      	str	r3, [r2, #0]
		while(GET_BIT(RCC->CR, 25) == 0);    //wait until PLL is ready
 8014b5a:	bf00      	nop
 8014b5c:	4b0a      	ldr	r3, [pc, #40]	; (8014b88 <RCC_InitClock+0xa8>)
 8014b5e:	681b      	ldr	r3, [r3, #0]
 8014b60:	0e5b      	lsrs	r3, r3, #25
 8014b62:	f003 0301 	and.w	r3, r3, #1
 8014b66:	2b00      	cmp	r3, #0
 8014b68:	d0f8      	beq.n	8014b5c <RCC_InitClock+0x7c>
		
		#if  CLK_TYPE == PLL
			SET_BIT(RCC->CFGR, 1);   //select PLL as system clock
 8014b6a:	4b07      	ldr	r3, [pc, #28]	; (8014b88 <RCC_InitClock+0xa8>)
 8014b6c:	685b      	ldr	r3, [r3, #4]
 8014b6e:	4a06      	ldr	r2, [pc, #24]	; (8014b88 <RCC_InitClock+0xa8>)
 8014b70:	f043 0302 	orr.w	r3, r3, #2
 8014b74:	6053      	str	r3, [r2, #4]
			while( (RCC->CFGR & 0xC) != 0x8);   //wait until PLL is used as system clock
 8014b76:	bf00      	nop
 8014b78:	4b03      	ldr	r3, [pc, #12]	; (8014b88 <RCC_InitClock+0xa8>)
 8014b7a:	685b      	ldr	r3, [r3, #4]
 8014b7c:	f003 030c 	and.w	r3, r3, #12
 8014b80:	2b08      	cmp	r3, #8
 8014b82:	d1f9      	bne.n	8014b78 <RCC_InitClock+0x98>
	
	#if  HSI_STATE == DISABLED
		CLR_BIT(RCC->CR, 0);
	#endif
	
}
 8014b84:	bf00      	nop
 8014b86:	bd80      	pop	{r7, pc}
 8014b88:	40021000 	.word	0x40021000

08014b8c <RCC_EnablePeripheralClock>:


void  RCC_EnablePeripheralClock (uint8_t peripheral)
{
 8014b8c:	b480      	push	{r7}
 8014b8e:	b083      	sub	sp, #12
 8014b90:	af00      	add	r7, sp, #0
 8014b92:	4603      	mov	r3, r0
 8014b94:	71fb      	strb	r3, [r7, #7]
	if(peripheral < 32)    //if peripheral is connected to AHB
 8014b96:	79fb      	ldrb	r3, [r7, #7]
 8014b98:	2b1f      	cmp	r3, #31
 8014b9a:	d809      	bhi.n	8014bb0 <RCC_EnablePeripheralClock+0x24>
	{
		SET_BIT(RCC->AHBENR, peripheral);
 8014b9c:	4b14      	ldr	r3, [pc, #80]	; (8014bf0 <RCC_EnablePeripheralClock+0x64>)
 8014b9e:	695a      	ldr	r2, [r3, #20]
 8014ba0:	79fb      	ldrb	r3, [r7, #7]
 8014ba2:	2101      	movs	r1, #1
 8014ba4:	fa01 f303 	lsl.w	r3, r1, r3
 8014ba8:	4911      	ldr	r1, [pc, #68]	; (8014bf0 <RCC_EnablePeripheralClock+0x64>)
 8014baa:	4313      	orrs	r3, r2
 8014bac:	614b      	str	r3, [r1, #20]
	}
	else if(peripheral < 96)    //if peripheral is connected to APB2
	{
		SET_BIT(RCC->APB2ENR, peripheral-64);
	}
}
 8014bae:	e01a      	b.n	8014be6 <RCC_EnablePeripheralClock+0x5a>
	else if(peripheral < 64)    //if peripheral is connected to APB1
 8014bb0:	79fb      	ldrb	r3, [r7, #7]
 8014bb2:	2b3f      	cmp	r3, #63	; 0x3f
 8014bb4:	d80a      	bhi.n	8014bcc <RCC_EnablePeripheralClock+0x40>
		SET_BIT(RCC->APB1ENR, peripheral-32);
 8014bb6:	4b0e      	ldr	r3, [pc, #56]	; (8014bf0 <RCC_EnablePeripheralClock+0x64>)
 8014bb8:	69da      	ldr	r2, [r3, #28]
 8014bba:	79fb      	ldrb	r3, [r7, #7]
 8014bbc:	3b20      	subs	r3, #32
 8014bbe:	2101      	movs	r1, #1
 8014bc0:	fa01 f303 	lsl.w	r3, r1, r3
 8014bc4:	490a      	ldr	r1, [pc, #40]	; (8014bf0 <RCC_EnablePeripheralClock+0x64>)
 8014bc6:	4313      	orrs	r3, r2
 8014bc8:	61cb      	str	r3, [r1, #28]
}
 8014bca:	e00c      	b.n	8014be6 <RCC_EnablePeripheralClock+0x5a>
	else if(peripheral < 96)    //if peripheral is connected to APB2
 8014bcc:	79fb      	ldrb	r3, [r7, #7]
 8014bce:	2b5f      	cmp	r3, #95	; 0x5f
 8014bd0:	d809      	bhi.n	8014be6 <RCC_EnablePeripheralClock+0x5a>
		SET_BIT(RCC->APB2ENR, peripheral-64);
 8014bd2:	4b07      	ldr	r3, [pc, #28]	; (8014bf0 <RCC_EnablePeripheralClock+0x64>)
 8014bd4:	699a      	ldr	r2, [r3, #24]
 8014bd6:	79fb      	ldrb	r3, [r7, #7]
 8014bd8:	3b40      	subs	r3, #64	; 0x40
 8014bda:	2101      	movs	r1, #1
 8014bdc:	fa01 f303 	lsl.w	r3, r1, r3
 8014be0:	4903      	ldr	r1, [pc, #12]	; (8014bf0 <RCC_EnablePeripheralClock+0x64>)
 8014be2:	4313      	orrs	r3, r2
 8014be4:	618b      	str	r3, [r1, #24]
}
 8014be6:	bf00      	nop
 8014be8:	370c      	adds	r7, #12
 8014bea:	46bd      	mov	sp, r7
 8014bec:	bc80      	pop	{r7}
 8014bee:	4770      	bx	lr
 8014bf0:	40021000 	.word	0x40021000

08014bf4 <main>:
void ledToggle(u32 delayTime);
void jumpToBoot(void);


int main(void)
{
 8014bf4:	b580      	push	{r7, lr}
 8014bf6:	af00      	add	r7, sp, #0
	RCC_InitClock();
 8014bf8:	f7ff ff72 	bl	8014ae0 <RCC_InitClock>

	updatesInit();
 8014bfc:	f000 f8b8 	bl	8014d70 <updatesInit>
	updatesSetState(READY_FOR_UPDATES, jumpToBoot);
 8014c00:	4906      	ldr	r1, [pc, #24]	; (8014c1c <main+0x28>)
 8014c02:	2000      	movs	r0, #0
 8014c04:	f000 f8d6 	bl	8014db4 <updatesSetState>
	ledInit();
 8014c08:	f000 f822 	bl	8014c50 <ledInit>
	NVIC_UnMaskIRQs();
 8014c0c:	f7ff ff5a 	bl	8014ac4 <NVIC_UnMaskIRQs>

	while (1)
	{
		ledToggle(5000);
 8014c10:	f241 3088 	movw	r0, #5000	; 0x1388
 8014c14:	f000 f832 	bl	8014c7c <ledToggle>
 8014c18:	e7fa      	b.n	8014c10 <main+0x1c>
 8014c1a:	bf00      	nop
 8014c1c:	08014cbd 	.word	0x08014cbd

08014c20 <delay>:




void delay(u32 time_ms)
{
 8014c20:	b480      	push	{r7}
 8014c22:	b085      	sub	sp, #20
 8014c24:	af00      	add	r7, sp, #0
 8014c26:	6078      	str	r0, [r7, #4]
	for(volatile u32 i = 0; i < 1130UL * (time_ms<<2); i++);
 8014c28:	2300      	movs	r3, #0
 8014c2a:	60fb      	str	r3, [r7, #12]
 8014c2c:	e002      	b.n	8014c34 <delay+0x14>
 8014c2e:	68fb      	ldr	r3, [r7, #12]
 8014c30:	3301      	adds	r3, #1
 8014c32:	60fb      	str	r3, [r7, #12]
 8014c34:	687b      	ldr	r3, [r7, #4]
 8014c36:	f241 12a8 	movw	r2, #4520	; 0x11a8
 8014c3a:	fb02 f203 	mul.w	r2, r2, r3
 8014c3e:	68fb      	ldr	r3, [r7, #12]
 8014c40:	429a      	cmp	r2, r3
 8014c42:	d8f4      	bhi.n	8014c2e <delay+0xe>
}
 8014c44:	bf00      	nop
 8014c46:	3714      	adds	r7, #20
 8014c48:	46bd      	mov	sp, r7
 8014c4a:	bc80      	pop	{r7}
 8014c4c:	4770      	bx	lr
	...

08014c50 <ledInit>:


void ledInit(void)
{
 8014c50:	b580      	push	{r7, lr}
 8014c52:	b082      	sub	sp, #8
 8014c54:	af00      	add	r7, sp, #0
	GPIO_Pin_t  ledPin = {
 8014c56:	4b08      	ldr	r3, [pc, #32]	; (8014c78 <ledInit+0x28>)
 8014c58:	681b      	ldr	r3, [r3, #0]
 8014c5a:	607b      	str	r3, [r7, #4]
		.port       =  GPIO_PORTC,
		.pinNumber  =  GPIO_PIN13
	};

	GPIO_PinConfg_t  ledPinConfig = {
 8014c5c:	2305      	movs	r3, #5
 8014c5e:	703b      	strb	r3, [r7, #0]
 8014c60:	2300      	movs	r3, #0
 8014c62:	707b      	strb	r3, [r7, #1]
		.pinMode      =  GENERAL_PURPOSE_OUTPUT_PUSH_PULL,
		.outputSpeed  =  OUTPUT_SPEED_10MHz
	};

	GPIO_InitPins(&ledPin, &ledPinConfig);
 8014c64:	463a      	mov	r2, r7
 8014c66:	1d3b      	adds	r3, r7, #4
 8014c68:	4611      	mov	r1, r2
 8014c6a:	4618      	mov	r0, r3
 8014c6c:	f7ff fe68 	bl	8014940 <GPIO_InitPins>
}
 8014c70:	bf00      	nop
 8014c72:	3708      	adds	r7, #8
 8014c74:	46bd      	mov	sp, r7
 8014c76:	bd80      	pop	{r7, pc}
 8014c78:	08014ed0 	.word	0x08014ed0

08014c7c <ledToggle>:


void ledToggle(u32 delayTime)
{
 8014c7c:	b580      	push	{r7, lr}
 8014c7e:	b084      	sub	sp, #16
 8014c80:	af00      	add	r7, sp, #0
 8014c82:	6078      	str	r0, [r7, #4]
	GPIO_Pin_t  ledPin = {
 8014c84:	4b0c      	ldr	r3, [pc, #48]	; (8014cb8 <ledToggle+0x3c>)
 8014c86:	681b      	ldr	r3, [r3, #0]
 8014c88:	60fb      	str	r3, [r7, #12]
		.port       =  GPIO_PORTC,
		.pinNumber  =  GPIO_PIN13
	};

	GPIO_SetPinsOutputVoltage(&ledPin, GPIO_HIGH);
 8014c8a:	f107 030c 	add.w	r3, r7, #12
 8014c8e:	2101      	movs	r1, #1
 8014c90:	4618      	mov	r0, r3
 8014c92:	f7ff fe91 	bl	80149b8 <GPIO_SetPinsOutputVoltage>
	delay(delayTime);
 8014c96:	6878      	ldr	r0, [r7, #4]
 8014c98:	f7ff ffc2 	bl	8014c20 <delay>
	GPIO_SetPinsOutputVoltage(&ledPin, GPIO_LOW);
 8014c9c:	f107 030c 	add.w	r3, r7, #12
 8014ca0:	2100      	movs	r1, #0
 8014ca2:	4618      	mov	r0, r3
 8014ca4:	f7ff fe88 	bl	80149b8 <GPIO_SetPinsOutputVoltage>
	delay(delayTime);
 8014ca8:	6878      	ldr	r0, [r7, #4]
 8014caa:	f7ff ffb9 	bl	8014c20 <delay>
}
 8014cae:	bf00      	nop
 8014cb0:	3710      	adds	r7, #16
 8014cb2:	46bd      	mov	sp, r7
 8014cb4:	bd80      	pop	{r7, pc}
 8014cb6:	bf00      	nop
 8014cb8:	08014ed0 	.word	0x08014ed0

08014cbc <jumpToBoot>:



void jumpToBoot(void)
{
 8014cbc:	b580      	push	{r7, lr}
 8014cbe:	af00      	add	r7, sp, #0
	ECU_ConfigActivateBoot();
 8014cc0:	f7ff fb4c 	bl	801435c <ECU_ConfigActivateBoot>
	NVIC_MaskIRQs(0);
 8014cc4:	2000      	movs	r0, #0
 8014cc6:	f7ff fee9 	bl	8014a9c <NVIC_MaskIRQs>
	NVIC_ResetSystem();
 8014cca:	f7ff fed9 	bl	8014a80 <NVIC_ResetSystem>
}
 8014cce:	bf00      	nop
 8014cd0:	bd80      	pop	{r7, pc}

08014cd2 <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
 8014cd2:	b480      	push	{r7}
 8014cd4:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
  while (1)
 8014cd6:	e7fe      	b.n	8014cd6 <NMI_Handler+0x4>

08014cd8 <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
 8014cd8:	b480      	push	{r7}
 8014cda:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 8014cdc:	e7fe      	b.n	8014cdc <HardFault_Handler+0x4>

08014cde <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
 8014cde:	b480      	push	{r7}
 8014ce0:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
 8014ce2:	e7fe      	b.n	8014ce2 <MemManage_Handler+0x4>

08014ce4 <BusFault_Handler>:

/**
  * @brief This function handles Prefetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
 8014ce4:	b480      	push	{r7}
 8014ce6:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
 8014ce8:	e7fe      	b.n	8014ce8 <BusFault_Handler+0x4>

08014cea <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
 8014cea:	b480      	push	{r7}
 8014cec:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
 8014cee:	e7fe      	b.n	8014cee <UsageFault_Handler+0x4>

08014cf0 <SVC_Handler>:

/**
  * @brief This function handles System service call via SWI instruction.
  */
void SVC_Handler(void)
{
 8014cf0:	b480      	push	{r7}
 8014cf2:	af00      	add	r7, sp, #0

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
 8014cf4:	bf00      	nop
 8014cf6:	46bd      	mov	sp, r7
 8014cf8:	bc80      	pop	{r7}
 8014cfa:	4770      	bx	lr

08014cfc <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
{
 8014cfc:	b480      	push	{r7}
 8014cfe:	af00      	add	r7, sp, #0

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
 8014d00:	bf00      	nop
 8014d02:	46bd      	mov	sp, r7
 8014d04:	bc80      	pop	{r7}
 8014d06:	4770      	bx	lr

08014d08 <PendSV_Handler>:

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
{
 8014d08:	b480      	push	{r7}
 8014d0a:	af00      	add	r7, sp, #0

  /* USER CODE END PendSV_IRQn 0 */
  /* USER CODE BEGIN PendSV_IRQn 1 */

  /* USER CODE END PendSV_IRQn 1 */
}
 8014d0c:	bf00      	nop
 8014d0e:	46bd      	mov	sp, r7
 8014d10:	bc80      	pop	{r7}
 8014d12:	4770      	bx	lr

08014d14 <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
 8014d14:	b580      	push	{r7, lr}
 8014d16:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 8014d18:	f000 f888 	bl	8014e2c <HAL_IncTick>
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
 8014d1c:	bf00      	nop
 8014d1e:	bd80      	pop	{r7, pc}

08014d20 <SystemInit>:
  * @note   This function should be used only after reset.
  * @param  None
  * @retval None
  */
void SystemInit (void)
{
 8014d20:	b480      	push	{r7}
 8014d22:	af00      	add	r7, sp, #0

  /* Configure the Vector Table location -------------------------------------*/
#if defined(USER_VECT_TAB_ADDRESS)
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM. */
#endif /* USER_VECT_TAB_ADDRESS */
}
 8014d24:	bf00      	nop
 8014d26:	46bd      	mov	sp, r7
 8014d28:	bc80      	pop	{r7}
 8014d2a:	4770      	bx	lr

08014d2c <CAN_CallBackFun>:
static const u8  ECU_ACK   =  'A';
static const u8  ECU_NAK   =  'N';


static void CAN_CallBackFun(void)
{
 8014d2c:	b580      	push	{r7, lr}
 8014d2e:	b088      	sub	sp, #32
 8014d30:	af00      	add	r7, sp, #0
	CAN_Frame_t  rxFrame;
	CAN_Rx(&rxFrame, 0);
 8014d32:	f107 0310 	add.w	r3, r7, #16
 8014d36:	2100      	movs	r1, #0
 8014d38:	4618      	mov	r0, r3
 8014d3a:	f7ff fa51 	bl	80141e0 <CAN_Rx>


	CAN_Frame_t  txFrame = {
 8014d3e:	463b      	mov	r3, r7
 8014d40:	2200      	movs	r2, #0
 8014d42:	601a      	str	r2, [r3, #0]
 8014d44:	605a      	str	r2, [r3, #4]
 8014d46:	609a      	str	r2, [r3, #8]
 8014d48:	60da      	str	r2, [r3, #12]
 8014d4a:	2351      	movs	r3, #81	; 0x51
 8014d4c:	603b      	str	r3, [r7, #0]
 8014d4e:	2301      	movs	r3, #1
 8014d50:	71bb      	strb	r3, [r7, #6]
 8014d52:	2341      	movs	r3, #65	; 0x41
 8014d54:	71fb      	strb	r3, [r7, #7]
		.frameType    =   DATA_FRAME,
		.DLC          =   1,
		.data         =   {'A'}
	};

	CAN_Tx(&txFrame);
 8014d56:	463b      	mov	r3, r7
 8014d58:	4618      	mov	r0, r3
 8014d5a:	f7ff f949 	bl	8013ff0 <CAN_Tx>

	updatesAvailableCallBack();
 8014d5e:	4b03      	ldr	r3, [pc, #12]	; (8014d6c <CAN_CallBackFun+0x40>)
 8014d60:	681b      	ldr	r3, [r3, #0]
 8014d62:	4798      	blx	r3
}
 8014d64:	bf00      	nop
 8014d66:	3720      	adds	r7, #32
 8014d68:	46bd      	mov	sp, r7
 8014d6a:	bd80      	pop	{r7, pc}
 8014d6c:	20000034 	.word	0x20000034

08014d70 <updatesInit>:



void  updatesInit(void)
{
 8014d70:	b580      	push	{r7, lr}
 8014d72:	b08e      	sub	sp, #56	; 0x38
 8014d74:	af00      	add	r7, sp, #0
	RCC_EnablePeripheralClock(CAN_PERIPHERAL);
 8014d76:	2039      	movs	r0, #57	; 0x39
 8014d78:	f7ff ff08 	bl	8014b8c <RCC_EnablePeripheralClock>
	CAN_Init(CAN_CallBackFun);
 8014d7c:	480c      	ldr	r0, [pc, #48]	; (8014db0 <updatesInit+0x40>)
 8014d7e:	f7fe fdf3 	bl	8013968 <CAN_Init>

	/* config filters */
	CAN_RxFilterBankConfig_t filterConfig = {
 8014d82:	1d3b      	adds	r3, r7, #4
 8014d84:	2234      	movs	r2, #52	; 0x34
 8014d86:	2100      	movs	r1, #0
 8014d88:	4618      	mov	r0, r3
 8014d8a:	f000 f885 	bl	8014e98 <memset>
 8014d8e:	2351      	movs	r3, #81	; 0x51
 8014d90:	60bb      	str	r3, [r7, #8]
 8014d92:	2351      	movs	r3, #81	; 0x51
 8014d94:	617b      	str	r3, [r7, #20]
 8014d96:	2351      	movs	r3, #81	; 0x51
 8014d98:	623b      	str	r3, [r7, #32]
 8014d9a:	2351      	movs	r3, #81	; 0x51
 8014d9c:	62fb      	str	r3, [r7, #44]	; 0x2c
				.frameType        =  DATA_FRAME
			}
		}
	};

	CAN_InitFilterBank(&filterConfig);
 8014d9e:	1d3b      	adds	r3, r7, #4
 8014da0:	4618      	mov	r0, r3
 8014da2:	f7fe feb3 	bl	8013b0c <CAN_InitFilterBank>
}
 8014da6:	bf00      	nop
 8014da8:	3738      	adds	r7, #56	; 0x38
 8014daa:	46bd      	mov	sp, r7
 8014dac:	bd80      	pop	{r7, pc}
 8014dae:	bf00      	nop
 8014db0:	08014d2d 	.word	0x08014d2d

08014db4 <updatesSetState>:


void  updatesSetState(ECU_UpdatesState_t  state, void (*updatesAvailableCallBackFun)(void))
{
 8014db4:	b480      	push	{r7}
 8014db6:	b083      	sub	sp, #12
 8014db8:	af00      	add	r7, sp, #0
 8014dba:	4603      	mov	r3, r0
 8014dbc:	6039      	str	r1, [r7, #0]
 8014dbe:	71fb      	strb	r3, [r7, #7]
	updatesState = state;
 8014dc0:	4a05      	ldr	r2, [pc, #20]	; (8014dd8 <updatesSetState+0x24>)
 8014dc2:	79fb      	ldrb	r3, [r7, #7]
 8014dc4:	7013      	strb	r3, [r2, #0]
	updatesAvailableCallBack = updatesAvailableCallBackFun;
 8014dc6:	4a05      	ldr	r2, [pc, #20]	; (8014ddc <updatesSetState+0x28>)
 8014dc8:	683b      	ldr	r3, [r7, #0]
 8014dca:	6013      	str	r3, [r2, #0]
}
 8014dcc:	bf00      	nop
 8014dce:	370c      	adds	r7, #12
 8014dd0:	46bd      	mov	sp, r7
 8014dd2:	bc80      	pop	{r7}
 8014dd4:	4770      	bx	lr
 8014dd6:	bf00      	nop
 8014dd8:	20000030 	.word	0x20000030
 8014ddc:	20000034 	.word	0x20000034

08014de0 <Reset_Handler>:
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
 8014de0:	480c      	ldr	r0, [pc, #48]	; (8014e14 <LoopFillZerobss+0x12>)
  ldr r1, =_edata
 8014de2:	490d      	ldr	r1, [pc, #52]	; (8014e18 <LoopFillZerobss+0x16>)
  ldr r2, =_sidata
 8014de4:	4a0d      	ldr	r2, [pc, #52]	; (8014e1c <LoopFillZerobss+0x1a>)
  movs r3, #0
 8014de6:	2300      	movs	r3, #0
  b LoopCopyDataInit
 8014de8:	e002      	b.n	8014df0 <LoopCopyDataInit>

08014dea <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 8014dea:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 8014dec:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 8014dee:	3304      	adds	r3, #4

08014df0 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 8014df0:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 8014df2:	428c      	cmp	r4, r1
  bcc CopyDataInit
 8014df4:	d3f9      	bcc.n	8014dea <CopyDataInit>
  
/* Zero fill the bss segment. */
  ldr r2, =_sbss
 8014df6:	4a0a      	ldr	r2, [pc, #40]	; (8014e20 <LoopFillZerobss+0x1e>)
  ldr r4, =_ebss
 8014df8:	4c0a      	ldr	r4, [pc, #40]	; (8014e24 <LoopFillZerobss+0x22>)
  movs r3, #0
 8014dfa:	2300      	movs	r3, #0
  b LoopFillZerobss
 8014dfc:	e001      	b.n	8014e02 <LoopFillZerobss>

08014dfe <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 8014dfe:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 8014e00:	3204      	adds	r2, #4

08014e02 <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 8014e02:	42a2      	cmp	r2, r4
  bcc FillZerobss
 8014e04:	d3fb      	bcc.n	8014dfe <FillZerobss>

/* Call the clock system intitialization function.*/
    bl  SystemInit
 8014e06:	f7ff ff8b 	bl	8014d20 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 8014e0a:	f000 f821 	bl	8014e50 <__libc_init_array>
/* Call the application's entry point.*/
  bl main
 8014e0e:	f7ff fef1 	bl	8014bf4 <main>
  bx lr
 8014e12:	4770      	bx	lr
  ldr r0, =_sdata
 8014e14:	20000000 	.word	0x20000000
  ldr r1, =_edata
 8014e18:	20000010 	.word	0x20000010
  ldr r2, =_sidata
 8014e1c:	08014edc 	.word	0x08014edc
  ldr r2, =_sbss
 8014e20:	20000010 	.word	0x20000010
  ldr r4, =_ebss
 8014e24:	2000003c 	.word	0x2000003c

08014e28 <ADC1_2_IRQHandler>:
 * @retval : None
*/
    .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
 8014e28:	e7fe      	b.n	8014e28 <ADC1_2_IRQHandler>
	...

08014e2c <HAL_IncTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
 8014e2c:	b480      	push	{r7}
 8014e2e:	af00      	add	r7, sp, #0
  uwTick += uwTickFreq;
 8014e30:	4b05      	ldr	r3, [pc, #20]	; (8014e48 <HAL_IncTick+0x1c>)
 8014e32:	781b      	ldrb	r3, [r3, #0]
 8014e34:	461a      	mov	r2, r3
 8014e36:	4b05      	ldr	r3, [pc, #20]	; (8014e4c <HAL_IncTick+0x20>)
 8014e38:	681b      	ldr	r3, [r3, #0]
 8014e3a:	4413      	add	r3, r2
 8014e3c:	4a03      	ldr	r2, [pc, #12]	; (8014e4c <HAL_IncTick+0x20>)
 8014e3e:	6013      	str	r3, [r2, #0]
}
 8014e40:	bf00      	nop
 8014e42:	46bd      	mov	sp, r7
 8014e44:	bc80      	pop	{r7}
 8014e46:	4770      	bx	lr
 8014e48:	2000000c 	.word	0x2000000c
 8014e4c:	20000038 	.word	0x20000038

08014e50 <__libc_init_array>:
 8014e50:	b570      	push	{r4, r5, r6, lr}
 8014e52:	2500      	movs	r5, #0
 8014e54:	4e0c      	ldr	r6, [pc, #48]	; (8014e88 <__libc_init_array+0x38>)
 8014e56:	4c0d      	ldr	r4, [pc, #52]	; (8014e8c <__libc_init_array+0x3c>)
 8014e58:	1ba4      	subs	r4, r4, r6
 8014e5a:	10a4      	asrs	r4, r4, #2
 8014e5c:	42a5      	cmp	r5, r4
 8014e5e:	d109      	bne.n	8014e74 <__libc_init_array+0x24>
 8014e60:	f000 f822 	bl	8014ea8 <_init>
 8014e64:	2500      	movs	r5, #0
 8014e66:	4e0a      	ldr	r6, [pc, #40]	; (8014e90 <__libc_init_array+0x40>)
 8014e68:	4c0a      	ldr	r4, [pc, #40]	; (8014e94 <__libc_init_array+0x44>)
 8014e6a:	1ba4      	subs	r4, r4, r6
 8014e6c:	10a4      	asrs	r4, r4, #2
 8014e6e:	42a5      	cmp	r5, r4
 8014e70:	d105      	bne.n	8014e7e <__libc_init_array+0x2e>
 8014e72:	bd70      	pop	{r4, r5, r6, pc}
 8014e74:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 8014e78:	4798      	blx	r3
 8014e7a:	3501      	adds	r5, #1
 8014e7c:	e7ee      	b.n	8014e5c <__libc_init_array+0xc>
 8014e7e:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 8014e82:	4798      	blx	r3
 8014e84:	3501      	adds	r5, #1
 8014e86:	e7f2      	b.n	8014e6e <__libc_init_array+0x1e>
 8014e88:	08014ed4 	.word	0x08014ed4
 8014e8c:	08014ed4 	.word	0x08014ed4
 8014e90:	08014ed4 	.word	0x08014ed4
 8014e94:	08014ed8 	.word	0x08014ed8

08014e98 <memset>:
 8014e98:	4603      	mov	r3, r0
 8014e9a:	4402      	add	r2, r0
 8014e9c:	4293      	cmp	r3, r2
 8014e9e:	d100      	bne.n	8014ea2 <memset+0xa>
 8014ea0:	4770      	bx	lr
 8014ea2:	f803 1b01 	strb.w	r1, [r3], #1
 8014ea6:	e7f9      	b.n	8014e9c <memset+0x4>

08014ea8 <_init>:
 8014ea8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8014eaa:	bf00      	nop
 8014eac:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8014eae:	bc08      	pop	{r3}
 8014eb0:	469e      	mov	lr, r3
 8014eb2:	4770      	bx	lr

08014eb4 <_fini>:
 8014eb4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8014eb6:	bf00      	nop
 8014eb8:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8014eba:	bc08      	pop	{r3}
 8014ebc:	469e      	mov	lr, r3
 8014ebe:	4770      	bx	lr
