
Bootloader_2.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   0000010c  08004400  08004400  00004400  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         000017a4  0800450c  0800450c  0000450c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000010  08005cb0  08005cb0  00005cb0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  08005cc0  08005cc0  00010010  2**0
                  CONTENTS
  4 .ARM          00000000  08005cc0  08005cc0  00010010  2**0
                  CONTENTS
  5 .preinit_array 00000000  08005cc0  08005cc0  00010010  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  08005cc0  08005cc0  00005cc0  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  08005cc4  08005cc4  00005cc4  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         00000010  20000000  08005cc8  00010000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          0000003c  20000010  08005cd8  00010010  2**2
                  ALLOC
 10 ._user_heap_stack 00000604  2000004c  08005cd8  0001004c  2**0
                  ALLOC
 11 .ARM.attributes 00000029  00000000  00000000  00010010  2**0
                  CONTENTS, READONLY
 12 .debug_info   0000354a  00000000  00000000  00010039  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_abbrev 00001031  00000000  00000000  00013583  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_aranges 000003e8  00000000  00000000  000145b8  2**3
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_ranges 00000348  00000000  00000000  000149a0  2**3
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_macro  00010ecd  00000000  00000000  00014ce8  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_line   000041af  00000000  00000000  00025bb5  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_str    0007cb8b  00000000  00000000  00029d64  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .comment      0000007b  00000000  00000000  000a68ef  2**0
                  CONTENTS, READONLY
 20 .debug_frame  00000ca8  00000000  00000000  000a696c  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

0800450c <__do_global_dtors_aux>:
 800450c:	b510      	push	{r4, lr}
 800450e:	4c05      	ldr	r4, [pc, #20]	; (8004524 <__do_global_dtors_aux+0x18>)
 8004510:	7823      	ldrb	r3, [r4, #0]
 8004512:	b933      	cbnz	r3, 8004522 <__do_global_dtors_aux+0x16>
 8004514:	4b04      	ldr	r3, [pc, #16]	; (8004528 <__do_global_dtors_aux+0x1c>)
 8004516:	b113      	cbz	r3, 800451e <__do_global_dtors_aux+0x12>
 8004518:	4804      	ldr	r0, [pc, #16]	; (800452c <__do_global_dtors_aux+0x20>)
 800451a:	f3af 8000 	nop.w
 800451e:	2301      	movs	r3, #1
 8004520:	7023      	strb	r3, [r4, #0]
 8004522:	bd10      	pop	{r4, pc}
 8004524:	20000010 	.word	0x20000010
 8004528:	00000000 	.word	0x00000000
 800452c:	08005c98 	.word	0x08005c98

08004530 <frame_dummy>:
 8004530:	b508      	push	{r3, lr}
 8004532:	4b03      	ldr	r3, [pc, #12]	; (8004540 <frame_dummy+0x10>)
 8004534:	b11b      	cbz	r3, 800453e <frame_dummy+0xe>
 8004536:	4903      	ldr	r1, [pc, #12]	; (8004544 <frame_dummy+0x14>)
 8004538:	4803      	ldr	r0, [pc, #12]	; (8004548 <frame_dummy+0x18>)
 800453a:	f3af 8000 	nop.w
 800453e:	bd08      	pop	{r3, pc}
 8004540:	00000000 	.word	0x00000000
 8004544:	20000014 	.word	0x20000014
 8004548:	08005c98 	.word	0x08005c98

0800454c <USB_LP_CAN1_RX0_IRQHandler>:

static void (*callBack)(void) = NULL;


void  USB_LP_CAN1_RX0_IRQHandler(void)
{
 800454c:	b580      	push	{r7, lr}
 800454e:	af00      	add	r7, sp, #0
	if(callBack != NULL)
 8004550:	4b04      	ldr	r3, [pc, #16]	; (8004564 <USB_LP_CAN1_RX0_IRQHandler+0x18>)
 8004552:	681b      	ldr	r3, [r3, #0]
 8004554:	2b00      	cmp	r3, #0
 8004556:	d002      	beq.n	800455e <USB_LP_CAN1_RX0_IRQHandler+0x12>
		callBack();
 8004558:	4b02      	ldr	r3, [pc, #8]	; (8004564 <USB_LP_CAN1_RX0_IRQHandler+0x18>)
 800455a:	681b      	ldr	r3, [r3, #0]
 800455c:	4798      	blx	r3
}
 800455e:	bf00      	nop
 8004560:	bd80      	pop	{r7, pc}
 8004562:	bf00      	nop
 8004564:	2000002c 	.word	0x2000002c

08004568 <CAN_Init>:



void CAN_Init(void (*ptr)(void))
{
 8004568:	b580      	push	{r7, lr}
 800456a:	b086      	sub	sp, #24
 800456c:	af00      	add	r7, sp, #0
 800456e:	6078      	str	r0, [r7, #4]
	callBack = ptr;
 8004570:	4a5f      	ldr	r2, [pc, #380]	; (80046f0 <CAN_Init+0x188>)
 8004572:	687b      	ldr	r3, [r7, #4]
 8004574:	6013      	str	r3, [r2, #0]

	RCC_EnablePeripheralClock(CAN_PERIPHERAL);
 8004576:	2039      	movs	r0, #57	; 0x39
 8004578:	f001 f95c 	bl	8005834 <RCC_EnablePeripheralClock>
//	RCC_EnablePeripheralClock(GPIOA_PERIPHERAL);
	RCC_EnablePeripheralClock(GPIOB_PERIPHERAL);
 800457c:	2043      	movs	r0, #67	; 0x43
 800457e:	f001 f959 	bl	8005834 <RCC_EnablePeripheralClock>
	RCC_EnablePeripheralClock(AFIO_PERIPHERAL);
 8004582:	2040      	movs	r0, #64	; 0x40
 8004584:	f001 f956 	bl	8005834 <RCC_EnablePeripheralClock>

	NVIC_EnableInterrupt(USB_LP_CAN1_RX0_IRQn);
 8004588:	2014      	movs	r0, #20
 800458a:	f001 f893 	bl	80056b4 <NVIC_EnableInterrupt>


	CLR_BIT(CAN1->MCR, 1);		// exit sleep mode
 800458e:	4b59      	ldr	r3, [pc, #356]	; (80046f4 <CAN_Init+0x18c>)
 8004590:	681b      	ldr	r3, [r3, #0]
 8004592:	4a58      	ldr	r2, [pc, #352]	; (80046f4 <CAN_Init+0x18c>)
 8004594:	f023 0302 	bic.w	r3, r3, #2
 8004598:	6013      	str	r3, [r2, #0]
	while(GET_BIT(CAN1->MSR, 0) == 1);		// wait until sleep ack be 0
 800459a:	bf00      	nop
 800459c:	4b55      	ldr	r3, [pc, #340]	; (80046f4 <CAN_Init+0x18c>)
 800459e:	685b      	ldr	r3, [r3, #4]
 80045a0:	f003 0301 	and.w	r3, r3, #1
 80045a4:	2b01      	cmp	r3, #1
 80045a6:	d0f9      	beq.n	800459c <CAN_Init+0x34>


	SET_BIT(CAN1->MCR, 0);		// enter intialization mode
 80045a8:	4b52      	ldr	r3, [pc, #328]	; (80046f4 <CAN_Init+0x18c>)
 80045aa:	681b      	ldr	r3, [r3, #0]
 80045ac:	4a51      	ldr	r2, [pc, #324]	; (80046f4 <CAN_Init+0x18c>)
 80045ae:	f043 0301 	orr.w	r3, r3, #1
 80045b2:	6013      	str	r3, [r2, #0]
	while(GET_BIT(CAN1->MSR, 0) == 0);		// wait until intialization ack be 1
 80045b4:	bf00      	nop
 80045b6:	4b4f      	ldr	r3, [pc, #316]	; (80046f4 <CAN_Init+0x18c>)
 80045b8:	685b      	ldr	r3, [r3, #4]
 80045ba:	f003 0301 	and.w	r3, r3, #1
 80045be:	2b00      	cmp	r3, #0
 80045c0:	d0f9      	beq.n	80045b6 <CAN_Init+0x4e>

	SET_BIT(CAN1->IER, 1);		// FIFI 0 Rx IRQ enable
 80045c2:	4b4c      	ldr	r3, [pc, #304]	; (80046f4 <CAN_Init+0x18c>)
 80045c4:	695b      	ldr	r3, [r3, #20]
 80045c6:	4a4b      	ldr	r2, [pc, #300]	; (80046f4 <CAN_Init+0x18c>)
 80045c8:	f043 0302 	orr.w	r3, r3, #2
 80045cc:	6153      	str	r3, [r2, #20]

//	SET_BIT(CAN1->BTR, 31);		// silent mode
	CLR_BIT(CAN1->BTR, 31);		// not silent mode
 80045ce:	4b49      	ldr	r3, [pc, #292]	; (80046f4 <CAN_Init+0x18c>)
 80045d0:	69db      	ldr	r3, [r3, #28]
 80045d2:	4a48      	ldr	r2, [pc, #288]	; (80046f4 <CAN_Init+0x18c>)
 80045d4:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 80045d8:	61d3      	str	r3, [r2, #28]
//	SET_BIT(CAN1->BTR, 30);		// loopback mode
	CLR_BIT(CAN1->BTR, 30);		// not loopback mode
 80045da:	4b46      	ldr	r3, [pc, #280]	; (80046f4 <CAN_Init+0x18c>)
 80045dc:	69db      	ldr	r3, [r3, #28]
 80045de:	4a45      	ldr	r2, [pc, #276]	; (80046f4 <CAN_Init+0x18c>)
 80045e0:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
 80045e4:	61d3      	str	r3, [r2, #28]

	// lower data rate to be 250 Kbps
	CAN1->BTR &= 0xF0000000;		// clear all register except high ones
 80045e6:	4b43      	ldr	r3, [pc, #268]	; (80046f4 <CAN_Init+0x18c>)
 80045e8:	69db      	ldr	r3, [r3, #28]
 80045ea:	4a42      	ldr	r2, [pc, #264]	; (80046f4 <CAN_Init+0x18c>)
 80045ec:	f003 4370 	and.w	r3, r3, #4026531840	; 0xf0000000
 80045f0:	61d3      	str	r3, [r2, #28]
	SET_BIT(CAN1->BTR, 0);		// BRP bits (9:0) = 1 --> prescaller = 2
 80045f2:	4b40      	ldr	r3, [pc, #256]	; (80046f4 <CAN_Init+0x18c>)
 80045f4:	69db      	ldr	r3, [r3, #28]
 80045f6:	4a3f      	ldr	r2, [pc, #252]	; (80046f4 <CAN_Init+0x18c>)
 80045f8:	f043 0301 	orr.w	r3, r3, #1
 80045fc:	61d3      	str	r3, [r2, #28]
	SET_BIT(CAN1->BTR, 1);		// BRP bits (9:0) = 3 --> prescaller = 4
 80045fe:	4b3d      	ldr	r3, [pc, #244]	; (80046f4 <CAN_Init+0x18c>)
 8004600:	69db      	ldr	r3, [r3, #28]
 8004602:	4a3c      	ldr	r2, [pc, #240]	; (80046f4 <CAN_Init+0x18c>)
 8004604:	f043 0302 	orr.w	r3, r3, #2
 8004608:	61d3      	str	r3, [r2, #28]
	SET_BIT(CAN1->BTR, 2);		// BRP bits (9:0) = 7 --> prescaller = 8
 800460a:	4b3a      	ldr	r3, [pc, #232]	; (80046f4 <CAN_Init+0x18c>)
 800460c:	69db      	ldr	r3, [r3, #28]
 800460e:	4a39      	ldr	r2, [pc, #228]	; (80046f4 <CAN_Init+0x18c>)
 8004610:	f043 0304 	orr.w	r3, r3, #4
 8004614:	61d3      	str	r3, [r2, #28]

	SET_BIT(CAN1->BTR, 17);		// TS1 bits (19:16) = 2  --> t_BS1 = 3  tq
 8004616:	4b37      	ldr	r3, [pc, #220]	; (80046f4 <CAN_Init+0x18c>)
 8004618:	69db      	ldr	r3, [r3, #28]
 800461a:	4a36      	ldr	r2, [pc, #216]	; (80046f4 <CAN_Init+0x18c>)
 800461c:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8004620:	61d3      	str	r3, [r2, #28]
	SET_BIT(CAN1->BTR, 18);		// TS1 bits (19:16) = 6  --> t_BS1 = 7  tq
 8004622:	4b34      	ldr	r3, [pc, #208]	; (80046f4 <CAN_Init+0x18c>)
 8004624:	69db      	ldr	r3, [r3, #28]
 8004626:	4a33      	ldr	r2, [pc, #204]	; (80046f4 <CAN_Init+0x18c>)
 8004628:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 800462c:	61d3      	str	r3, [r2, #28]
	SET_BIT(CAN1->BTR, 19);		// TS1 bits (19:16) = 14 --> t_BS1 = 15 tq
 800462e:	4b31      	ldr	r3, [pc, #196]	; (80046f4 <CAN_Init+0x18c>)
 8004630:	69db      	ldr	r3, [r3, #28]
 8004632:	4a30      	ldr	r2, [pc, #192]	; (80046f4 <CAN_Init+0x18c>)
 8004634:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 8004638:	61d3      	str	r3, [r2, #28]

	SET_BIT(CAN1->BTR, 20);		// TS2 bits (22:20) = 1 --> t_BS2 = 2 tq
 800463a:	4b2e      	ldr	r3, [pc, #184]	; (80046f4 <CAN_Init+0x18c>)
 800463c:	69db      	ldr	r3, [r3, #28]
 800463e:	4a2d      	ldr	r2, [pc, #180]	; (80046f4 <CAN_Init+0x18c>)
 8004640:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8004644:	61d3      	str	r3, [r2, #28]

	SET_BIT(CAN1->BTR, 24);		// SJW bits (25:24) = 1 --> SJW = tq
 8004646:	4b2b      	ldr	r3, [pc, #172]	; (80046f4 <CAN_Init+0x18c>)
 8004648:	69db      	ldr	r3, [r3, #28]
 800464a:	4a2a      	ldr	r2, [pc, #168]	; (80046f4 <CAN_Init+0x18c>)
 800464c:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8004650:	61d3      	str	r3, [r2, #28]

//	CLR_BIT(CAN1->MCR, 16);	// no debug freeze
//	SET_BIT(CAN1->MCR, 4);	// no automatic retransmission


	CAN1->FMR &= ~(0x3FUL<<8);	// all filters for CAN1
 8004652:	4b28      	ldr	r3, [pc, #160]	; (80046f4 <CAN_Init+0x18c>)
 8004654:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
 8004658:	4a26      	ldr	r2, [pc, #152]	; (80046f4 <CAN_Init+0x18c>)
 800465a:	f423 537c 	bic.w	r3, r3, #16128	; 0x3f00
 800465e:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
	CAN1->FMR |=  (14UL<<8);		// all filters for CAN1
 8004662:	4b24      	ldr	r3, [pc, #144]	; (80046f4 <CAN_Init+0x18c>)
 8004664:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
 8004668:	4a22      	ldr	r2, [pc, #136]	; (80046f4 <CAN_Init+0x18c>)
 800466a:	f443 6360 	orr.w	r3, r3, #3584	; 0xe00
 800466e:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

	SET_BIT(CAN1->MCR, 6);		// Bus-Off is left automatically by hardware
 8004672:	4b20      	ldr	r3, [pc, #128]	; (80046f4 <CAN_Init+0x18c>)
 8004674:	681b      	ldr	r3, [r3, #0]
 8004676:	4a1f      	ldr	r2, [pc, #124]	; (80046f4 <CAN_Init+0x18c>)
 8004678:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800467c:	6013      	str	r3, [r2, #0]

	SET_BIT(CAN1->MCR, 2);		// Tx mailbox priority by first requested
 800467e:	4b1d      	ldr	r3, [pc, #116]	; (80046f4 <CAN_Init+0x18c>)
 8004680:	681b      	ldr	r3, [r3, #0]
 8004682:	4a1c      	ldr	r2, [pc, #112]	; (80046f4 <CAN_Init+0x18c>)
 8004684:	f043 0304 	orr.w	r3, r3, #4
 8004688:	6013      	str	r3, [r2, #0]

	CLR_BIT(CAN1->MCR, 0);		// exit intialization mode
 800468a:	4b1a      	ldr	r3, [pc, #104]	; (80046f4 <CAN_Init+0x18c>)
 800468c:	681b      	ldr	r3, [r3, #0]
 800468e:	4a19      	ldr	r2, [pc, #100]	; (80046f4 <CAN_Init+0x18c>)
 8004690:	f023 0301 	bic.w	r3, r3, #1
 8004694:	6013      	str	r3, [r2, #0]
	while(GET_BIT(CAN1->MSR, 0) == 1);		// wait until intialization mode ack
 8004696:	bf00      	nop
 8004698:	4b16      	ldr	r3, [pc, #88]	; (80046f4 <CAN_Init+0x18c>)
 800469a:	685b      	ldr	r3, [r3, #4]
 800469c:	f003 0301 	and.w	r3, r3, #1
 80046a0:	2b01      	cmp	r3, #1
 80046a2:	d0f9      	beq.n	8004698 <CAN_Init+0x130>


	// remap CAN pins, CAN_RX mapped to PB8, CAN_TX mapped to PB9
	SET_BIT(AFIO->MAPR, 14);
 80046a4:	4b14      	ldr	r3, [pc, #80]	; (80046f8 <CAN_Init+0x190>)
 80046a6:	685b      	ldr	r3, [r3, #4]
 80046a8:	4a13      	ldr	r2, [pc, #76]	; (80046f8 <CAN_Init+0x190>)
 80046aa:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 80046ae:	6053      	str	r3, [r2, #4]


	// CAN TX --> PA12 --> Alternate function push-pull
	GPIO_Pin_t  CAN_TxPin = {
 80046b0:	4b12      	ldr	r3, [pc, #72]	; (80046fc <CAN_Init+0x194>)
 80046b2:	681b      	ldr	r3, [r3, #0]
 80046b4:	617b      	str	r3, [r7, #20]
		.port       =  GPIO_PORTB,
		.pinNumber  =  GPIO_PIN9
	};

	GPIO_PinConfg_t  CAN_TxPinConfig = {
 80046b6:	4b12      	ldr	r3, [pc, #72]	; (8004700 <CAN_Init+0x198>)
 80046b8:	881b      	ldrh	r3, [r3, #0]
 80046ba:	823b      	strh	r3, [r7, #16]
		.pinMode      =  ALTERNATE_FUNCTION_OUTPUT_PUSH_PULL,
		.outputSpeed  =  OUTPUT_SPEED_50MHz
	};

	GPIO_InitPins(&CAN_TxPin, &CAN_TxPinConfig);
 80046bc:	f107 0210 	add.w	r2, r7, #16
 80046c0:	f107 0314 	add.w	r3, r7, #20
 80046c4:	4611      	mov	r1, r2
 80046c6:	4618      	mov	r0, r3
 80046c8:	f000 ffb8 	bl	800563c <GPIO_InitPins>



	// CAN RX --> PA11 --> Input floating / Input pull-up
	GPIO_Pin_t  CAN_RxPin = {
 80046cc:	4b0d      	ldr	r3, [pc, #52]	; (8004704 <CAN_Init+0x19c>)
 80046ce:	681b      	ldr	r3, [r3, #0]
 80046d0:	60fb      	str	r3, [r7, #12]
		.port       =  GPIO_PORTB,
		.pinNumber  =  GPIO_PIN8
	};

	GPIO_PinConfg_t  CAN_RxPinConfig = {
 80046d2:	4b0d      	ldr	r3, [pc, #52]	; (8004708 <CAN_Init+0x1a0>)
 80046d4:	881b      	ldrh	r3, [r3, #0]
 80046d6:	813b      	strh	r3, [r7, #8]
		.pinMode      =  INPUT_PULL_UP,
		.outputSpeed  =  OUTPUT_SPEED_50MHz
	};

	GPIO_InitPins(&CAN_RxPin, &CAN_RxPinConfig);
 80046d8:	f107 0208 	add.w	r2, r7, #8
 80046dc:	f107 030c 	add.w	r3, r7, #12
 80046e0:	4611      	mov	r1, r2
 80046e2:	4618      	mov	r0, r3
 80046e4:	f000 ffaa 	bl	800563c <GPIO_InitPins>
}
 80046e8:	bf00      	nop
 80046ea:	3718      	adds	r7, #24
 80046ec:	46bd      	mov	sp, r7
 80046ee:	bd80      	pop	{r7, pc}
 80046f0:	2000002c 	.word	0x2000002c
 80046f4:	40006400 	.word	0x40006400
 80046f8:	40010000 	.word	0x40010000
 80046fc:	08005cb0 	.word	0x08005cb0
 8004700:	08005cb4 	.word	0x08005cb4
 8004704:	08005cb8 	.word	0x08005cb8
 8004708:	08005cbc 	.word	0x08005cbc

0800470c <CAN_InitFilterBank>:



void CAN_InitFilterBank(CAN_RxFilterBankConfig_t*  filterConfig)
{
 800470c:	b490      	push	{r4, r7}
 800470e:	b082      	sub	sp, #8
 8004710:	af00      	add	r7, sp, #0
 8004712:	6078      	str	r0, [r7, #4]
	if((filterConfig->filterBankNum) > 13)
 8004714:	687b      	ldr	r3, [r7, #4]
 8004716:	781b      	ldrb	r3, [r3, #0]
 8004718:	2b0d      	cmp	r3, #13
 800471a:	f200 8262 	bhi.w	8004be2 <CAN_InitFilterBank+0x4d6>
		return;


	SET_BIT(CAN1->FMR, 0);	// enter filter initialization mode
 800471e:	4ba9      	ldr	r3, [pc, #676]	; (80049c4 <CAN_InitFilterBank+0x2b8>)
 8004720:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
 8004724:	4aa7      	ldr	r2, [pc, #668]	; (80049c4 <CAN_InitFilterBank+0x2b8>)
 8004726:	f043 0301 	orr.w	r3, r3, #1
 800472a:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
	CLR_BIT(CAN1->FA1R, filterConfig->filterBankNum);		// deactivate filter
 800472e:	4ba5      	ldr	r3, [pc, #660]	; (80049c4 <CAN_InitFilterBank+0x2b8>)
 8004730:	f8d3 221c 	ldr.w	r2, [r3, #540]	; 0x21c
 8004734:	687b      	ldr	r3, [r7, #4]
 8004736:	781b      	ldrb	r3, [r3, #0]
 8004738:	4619      	mov	r1, r3
 800473a:	2301      	movs	r3, #1
 800473c:	408b      	lsls	r3, r1
 800473e:	43db      	mvns	r3, r3
 8004740:	49a0      	ldr	r1, [pc, #640]	; (80049c4 <CAN_InitFilterBank+0x2b8>)
 8004742:	4013      	ands	r3, r2
 8004744:	f8c1 321c 	str.w	r3, [r1, #540]	; 0x21c


	switch(filterConfig->desFifo)
 8004748:	687b      	ldr	r3, [r7, #4]
 800474a:	78db      	ldrb	r3, [r3, #3]
 800474c:	2b00      	cmp	r3, #0
 800474e:	d002      	beq.n	8004756 <CAN_InitFilterBank+0x4a>
 8004750:	2b01      	cmp	r3, #1
 8004752:	d00e      	beq.n	8004772 <CAN_InitFilterBank+0x66>
 8004754:	e01a      	b.n	800478c <CAN_InitFilterBank+0x80>
	{
		case FIFO_0:
			CLR_BIT(CAN1->FFA1R, filterConfig->filterBankNum);
 8004756:	4b9b      	ldr	r3, [pc, #620]	; (80049c4 <CAN_InitFilterBank+0x2b8>)
 8004758:	f8d3 2214 	ldr.w	r2, [r3, #532]	; 0x214
 800475c:	687b      	ldr	r3, [r7, #4]
 800475e:	781b      	ldrb	r3, [r3, #0]
 8004760:	4619      	mov	r1, r3
 8004762:	2301      	movs	r3, #1
 8004764:	408b      	lsls	r3, r1
 8004766:	43db      	mvns	r3, r3
 8004768:	4996      	ldr	r1, [pc, #600]	; (80049c4 <CAN_InitFilterBank+0x2b8>)
 800476a:	4013      	ands	r3, r2
 800476c:	f8c1 3214 	str.w	r3, [r1, #532]	; 0x214
		break;
 8004770:	e00c      	b.n	800478c <CAN_InitFilterBank+0x80>

		case FIFO_1:
			SET_BIT(CAN1->FFA1R, filterConfig->filterBankNum);
 8004772:	4b94      	ldr	r3, [pc, #592]	; (80049c4 <CAN_InitFilterBank+0x2b8>)
 8004774:	f8d3 2214 	ldr.w	r2, [r3, #532]	; 0x214
 8004778:	687b      	ldr	r3, [r7, #4]
 800477a:	781b      	ldrb	r3, [r3, #0]
 800477c:	4619      	mov	r1, r3
 800477e:	2301      	movs	r3, #1
 8004780:	408b      	lsls	r3, r1
 8004782:	4990      	ldr	r1, [pc, #576]	; (80049c4 <CAN_InitFilterBank+0x2b8>)
 8004784:	4313      	orrs	r3, r2
 8004786:	f8c1 3214 	str.w	r3, [r1, #532]	; 0x214
		break;
 800478a:	bf00      	nop
	}


	switch(filterConfig->mode)
 800478c:	687b      	ldr	r3, [r7, #4]
 800478e:	789b      	ldrb	r3, [r3, #2]
 8004790:	2b00      	cmp	r3, #0
 8004792:	f000 8104 	beq.w	800499e <CAN_InitFilterBank+0x292>
 8004796:	2b01      	cmp	r3, #1
 8004798:	f040 820e 	bne.w	8004bb8 <CAN_InitFilterBank+0x4ac>
	{
		case ID_MASK:
			CLR_BIT(CAN1->FM1R, filterConfig->filterBankNum);	// id mask mode
 800479c:	4b89      	ldr	r3, [pc, #548]	; (80049c4 <CAN_InitFilterBank+0x2b8>)
 800479e:	f8d3 2204 	ldr.w	r2, [r3, #516]	; 0x204
 80047a2:	687b      	ldr	r3, [r7, #4]
 80047a4:	781b      	ldrb	r3, [r3, #0]
 80047a6:	4619      	mov	r1, r3
 80047a8:	2301      	movs	r3, #1
 80047aa:	408b      	lsls	r3, r1
 80047ac:	43db      	mvns	r3, r3
 80047ae:	4985      	ldr	r1, [pc, #532]	; (80049c4 <CAN_InitFilterBank+0x2b8>)
 80047b0:	4013      	ands	r3, r2
 80047b2:	f8c1 3204 	str.w	r3, [r1, #516]	; 0x204

			switch(filterConfig->scale)
 80047b6:	687b      	ldr	r3, [r7, #4]
 80047b8:	785b      	ldrb	r3, [r3, #1]
 80047ba:	2b00      	cmp	r3, #0
 80047bc:	d002      	beq.n	80047c4 <CAN_InitFilterBank+0xb8>
 80047be:	2b01      	cmp	r3, #1
 80047c0:	d057      	beq.n	8004872 <CAN_InitFilterBank+0x166>
							);
						break;
					}
				break;
			}
		break;
 80047c2:	e1f9      	b.n	8004bb8 <CAN_InitFilterBank+0x4ac>
					CLR_BIT(CAN1->FS1R, filterConfig->filterBankNum);	// 16bit scale
 80047c4:	4b7f      	ldr	r3, [pc, #508]	; (80049c4 <CAN_InitFilterBank+0x2b8>)
 80047c6:	f8d3 220c 	ldr.w	r2, [r3, #524]	; 0x20c
 80047ca:	687b      	ldr	r3, [r7, #4]
 80047cc:	781b      	ldrb	r3, [r3, #0]
 80047ce:	4619      	mov	r1, r3
 80047d0:	2301      	movs	r3, #1
 80047d2:	408b      	lsls	r3, r1
 80047d4:	43db      	mvns	r3, r3
 80047d6:	497b      	ldr	r1, [pc, #492]	; (80049c4 <CAN_InitFilterBank+0x2b8>)
 80047d8:	4013      	ands	r3, r2
 80047da:	f8c1 320c 	str.w	r3, [r1, #524]	; 0x20c
						(((u32)filterConfig->accepted[0].frameType)<<4)   |  // RTR
 80047de:	687b      	ldr	r3, [r7, #4]
 80047e0:	7b5b      	ldrb	r3, [r3, #13]
						((0UL)<<3)  |  // standard ID
 80047e2:	011a      	lsls	r2, r3, #4
						(((u32)filterConfig->accepted[0].id)<<5)          |  // ID
 80047e4:	687b      	ldr	r3, [r7, #4]
 80047e6:	685b      	ldr	r3, [r3, #4]
 80047e8:	015b      	lsls	r3, r3, #5
						(((u32)filterConfig->accepted[0].frameType)<<4)   |  // RTR
 80047ea:	4313      	orrs	r3, r2
						(((u32)(!filterConfig->accepted[0].maskIdType))<<19) |  // standard ID
 80047ec:	687a      	ldr	r2, [r7, #4]
 80047ee:	7b92      	ldrb	r2, [r2, #14]
 80047f0:	2a00      	cmp	r2, #0
 80047f2:	d102      	bne.n	80047fa <CAN_InitFilterBank+0xee>
 80047f4:	f44f 2200 	mov.w	r2, #524288	; 0x80000
 80047f8:	e000      	b.n	80047fc <CAN_InitFilterBank+0xf0>
 80047fa:	2200      	movs	r2, #0
						(((u32)filterConfig->accepted[0].id)<<5)          |  // ID
 80047fc:	4313      	orrs	r3, r2
						(((u32)(!filterConfig->accepted[0].maskFrameType))<<20)  |  // RTR
 80047fe:	687a      	ldr	r2, [r7, #4]
 8004800:	7bd2      	ldrb	r2, [r2, #15]
 8004802:	2a00      	cmp	r2, #0
 8004804:	d102      	bne.n	800480c <CAN_InitFilterBank+0x100>
 8004806:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
 800480a:	e000      	b.n	800480e <CAN_InitFilterBank+0x102>
 800480c:	2200      	movs	r2, #0
						(((u32)(!filterConfig->accepted[0].maskIdType))<<19) |  // standard ID
 800480e:	431a      	orrs	r2, r3
						(((u32)filterConfig->accepted[0].mask)<<21)       // ID mask
 8004810:	687b      	ldr	r3, [r7, #4]
 8004812:	689b      	ldr	r3, [r3, #8]
 8004814:	055b      	lsls	r3, r3, #21
					CAN1->sFilterRegister[filterConfig->filterBankNum].FR1 = (
 8004816:	486b      	ldr	r0, [pc, #428]	; (80049c4 <CAN_InitFilterBank+0x2b8>)
 8004818:	6879      	ldr	r1, [r7, #4]
 800481a:	7809      	ldrb	r1, [r1, #0]
						(((u32)(!filterConfig->accepted[0].maskFrameType))<<20)  |  // RTR
 800481c:	431a      	orrs	r2, r3
					CAN1->sFilterRegister[filterConfig->filterBankNum].FR1 = (
 800481e:	f101 0348 	add.w	r3, r1, #72	; 0x48
 8004822:	f840 2033 	str.w	r2, [r0, r3, lsl #3]
						(((u32)filterConfig->accepted[1].frameType)<<4)  |  // RTR
 8004826:	687b      	ldr	r3, [r7, #4]
 8004828:	7e5b      	ldrb	r3, [r3, #25]
						((0UL)<<3)  |  // standard ID
 800482a:	011a      	lsls	r2, r3, #4
						(((u32)filterConfig->accepted[1].id)<<5)    |   // ID
 800482c:	687b      	ldr	r3, [r7, #4]
 800482e:	691b      	ldr	r3, [r3, #16]
 8004830:	015b      	lsls	r3, r3, #5
						(((u32)filterConfig->accepted[1].frameType)<<4)  |  // RTR
 8004832:	4313      	orrs	r3, r2
						(((u32)(!filterConfig->accepted[1].maskIdType))<<19)  |  // standard ID
 8004834:	687a      	ldr	r2, [r7, #4]
 8004836:	7e92      	ldrb	r2, [r2, #26]
 8004838:	2a00      	cmp	r2, #0
 800483a:	d102      	bne.n	8004842 <CAN_InitFilterBank+0x136>
 800483c:	f44f 2200 	mov.w	r2, #524288	; 0x80000
 8004840:	e000      	b.n	8004844 <CAN_InitFilterBank+0x138>
 8004842:	2200      	movs	r2, #0
						(((u32)filterConfig->accepted[1].id)<<5)    |   // ID
 8004844:	4313      	orrs	r3, r2
						(((u32)(!filterConfig->accepted[1].maskFrameType))<<20)  |  // RTR
 8004846:	687a      	ldr	r2, [r7, #4]
 8004848:	7ed2      	ldrb	r2, [r2, #27]
 800484a:	2a00      	cmp	r2, #0
 800484c:	d102      	bne.n	8004854 <CAN_InitFilterBank+0x148>
 800484e:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
 8004852:	e000      	b.n	8004856 <CAN_InitFilterBank+0x14a>
 8004854:	2200      	movs	r2, #0
						(((u32)(!filterConfig->accepted[1].maskIdType))<<19)  |  // standard ID
 8004856:	431a      	orrs	r2, r3
						(((u32)filterConfig->accepted[1].mask)<<21)       // ID mask
 8004858:	687b      	ldr	r3, [r7, #4]
 800485a:	695b      	ldr	r3, [r3, #20]
 800485c:	055b      	lsls	r3, r3, #21
					CAN1->sFilterRegister[filterConfig->filterBankNum].FR2 = (
 800485e:	4859      	ldr	r0, [pc, #356]	; (80049c4 <CAN_InitFilterBank+0x2b8>)
 8004860:	6879      	ldr	r1, [r7, #4]
 8004862:	7809      	ldrb	r1, [r1, #0]
						(((u32)(!filterConfig->accepted[1].maskFrameType))<<20)  |  // RTR
 8004864:	431a      	orrs	r2, r3
					CAN1->sFilterRegister[filterConfig->filterBankNum].FR2 = (
 8004866:	f101 0348 	add.w	r3, r1, #72	; 0x48
 800486a:	00db      	lsls	r3, r3, #3
 800486c:	4403      	add	r3, r0
 800486e:	605a      	str	r2, [r3, #4]
				break;
 8004870:	e094      	b.n	800499c <CAN_InitFilterBank+0x290>
					SET_BIT(CAN1->FS1R, filterConfig->filterBankNum);	// 32bit scale
 8004872:	4b54      	ldr	r3, [pc, #336]	; (80049c4 <CAN_InitFilterBank+0x2b8>)
 8004874:	f8d3 220c 	ldr.w	r2, [r3, #524]	; 0x20c
 8004878:	687b      	ldr	r3, [r7, #4]
 800487a:	781b      	ldrb	r3, [r3, #0]
 800487c:	4619      	mov	r1, r3
 800487e:	2301      	movs	r3, #1
 8004880:	408b      	lsls	r3, r1
 8004882:	4950      	ldr	r1, [pc, #320]	; (80049c4 <CAN_InitFilterBank+0x2b8>)
 8004884:	4313      	orrs	r3, r2
 8004886:	f8c1 320c 	str.w	r3, [r1, #524]	; 0x20c
						(((u32)filterConfig->accepted[0].frameType)<<1)  |  // RTR
 800488a:	687b      	ldr	r3, [r7, #4]
 800488c:	7b5b      	ldrb	r3, [r3, #13]
 800488e:	005a      	lsls	r2, r3, #1
						(((u32)filterConfig->accepted[0].idType)<<2)     |  // IDE
 8004890:	687b      	ldr	r3, [r7, #4]
 8004892:	7b1b      	ldrb	r3, [r3, #12]
 8004894:	009b      	lsls	r3, r3, #2
						(((u32)filterConfig->accepted[0].frameType)<<1)  |  // RTR
 8004896:	4313      	orrs	r3, r2
					CAN1->sFilterRegister[filterConfig->filterBankNum].FR1 = (
 8004898:	494a      	ldr	r1, [pc, #296]	; (80049c4 <CAN_InitFilterBank+0x2b8>)
 800489a:	687a      	ldr	r2, [r7, #4]
 800489c:	7812      	ldrb	r2, [r2, #0]
 800489e:	4610      	mov	r0, r2
						(((u32)filterConfig->accepted[0].idType)<<2)     |  // IDE
 80048a0:	f063 023f 	orn	r2, r3, #63	; 0x3f
					CAN1->sFilterRegister[filterConfig->filterBankNum].FR1 = (
 80048a4:	f100 0348 	add.w	r3, r0, #72	; 0x48
 80048a8:	f841 2033 	str.w	r2, [r1, r3, lsl #3]
						(((u32)(!filterConfig->accepted[0].maskFrameType))<<1)  |  // RTR
 80048ac:	687b      	ldr	r3, [r7, #4]
 80048ae:	7bdb      	ldrb	r3, [r3, #15]
 80048b0:	2b00      	cmp	r3, #0
 80048b2:	d101      	bne.n	80048b8 <CAN_InitFilterBank+0x1ac>
 80048b4:	2202      	movs	r2, #2
 80048b6:	e000      	b.n	80048ba <CAN_InitFilterBank+0x1ae>
 80048b8:	2200      	movs	r2, #0
						(((u32)(!filterConfig->accepted[0].maskIdType))<<2)     |  // IDE
 80048ba:	687b      	ldr	r3, [r7, #4]
 80048bc:	7b9b      	ldrb	r3, [r3, #14]
 80048be:	2b00      	cmp	r3, #0
 80048c0:	d101      	bne.n	80048c6 <CAN_InitFilterBank+0x1ba>
 80048c2:	2304      	movs	r3, #4
 80048c4:	e000      	b.n	80048c8 <CAN_InitFilterBank+0x1bc>
 80048c6:	2300      	movs	r3, #0
						(((u32)(!filterConfig->accepted[0].maskFrameType))<<1)  |  // RTR
 80048c8:	4313      	orrs	r3, r2
					CAN1->sFilterRegister[filterConfig->filterBankNum].FR2 = (
 80048ca:	493e      	ldr	r1, [pc, #248]	; (80049c4 <CAN_InitFilterBank+0x2b8>)
 80048cc:	687a      	ldr	r2, [r7, #4]
 80048ce:	7812      	ldrb	r2, [r2, #0]
 80048d0:	4610      	mov	r0, r2
						(((u32)(!filterConfig->accepted[0].maskIdType))<<2)     |  // IDE
 80048d2:	f063 023f 	orn	r2, r3, #63	; 0x3f
					CAN1->sFilterRegister[filterConfig->filterBankNum].FR2 = (
 80048d6:	f100 0348 	add.w	r3, r0, #72	; 0x48
 80048da:	00db      	lsls	r3, r3, #3
 80048dc:	440b      	add	r3, r1
 80048de:	605a      	str	r2, [r3, #4]
					switch(filterConfig->accepted[0].idType)
 80048e0:	687b      	ldr	r3, [r7, #4]
 80048e2:	7b1b      	ldrb	r3, [r3, #12]
 80048e4:	2b00      	cmp	r3, #0
 80048e6:	d002      	beq.n	80048ee <CAN_InitFilterBank+0x1e2>
 80048e8:	2b01      	cmp	r3, #1
 80048ea:	d02d      	beq.n	8004948 <CAN_InitFilterBank+0x23c>
				break;
 80048ec:	e055      	b.n	800499a <CAN_InitFilterBank+0x28e>
							CAN1->sFilterRegister[filterConfig->filterBankNum].FR1 &= (
 80048ee:	4a35      	ldr	r2, [pc, #212]	; (80049c4 <CAN_InitFilterBank+0x2b8>)
 80048f0:	687b      	ldr	r3, [r7, #4]
 80048f2:	781b      	ldrb	r3, [r3, #0]
 80048f4:	3348      	adds	r3, #72	; 0x48
 80048f6:	f852 2033 	ldr.w	r2, [r2, r3, lsl #3]
								((filterConfig->accepted[0].id)<<21)    |  // standard  ID
 80048fa:	687b      	ldr	r3, [r7, #4]
 80048fc:	685b      	ldr	r3, [r3, #4]
 80048fe:	055b      	lsls	r3, r3, #21
 8004900:	ea6f 5353 	mvn.w	r3, r3, lsr #21
 8004904:	ea6f 5343 	mvn.w	r3, r3, lsl #21
							CAN1->sFilterRegister[filterConfig->filterBankNum].FR1 &= (
 8004908:	482e      	ldr	r0, [pc, #184]	; (80049c4 <CAN_InitFilterBank+0x2b8>)
 800490a:	6879      	ldr	r1, [r7, #4]
 800490c:	7809      	ldrb	r1, [r1, #0]
 800490e:	401a      	ands	r2, r3
 8004910:	f101 0348 	add.w	r3, r1, #72	; 0x48
 8004914:	f840 2033 	str.w	r2, [r0, r3, lsl #3]
							CAN1->sFilterRegister[filterConfig->filterBankNum].FR2 &= (
 8004918:	4a2a      	ldr	r2, [pc, #168]	; (80049c4 <CAN_InitFilterBank+0x2b8>)
 800491a:	687b      	ldr	r3, [r7, #4]
 800491c:	781b      	ldrb	r3, [r3, #0]
 800491e:	3348      	adds	r3, #72	; 0x48
 8004920:	00db      	lsls	r3, r3, #3
 8004922:	4413      	add	r3, r2
 8004924:	685a      	ldr	r2, [r3, #4]
								((filterConfig->accepted[0].mask)<<21)    |  // standard  ID
 8004926:	687b      	ldr	r3, [r7, #4]
 8004928:	689b      	ldr	r3, [r3, #8]
 800492a:	055b      	lsls	r3, r3, #21
 800492c:	ea6f 5353 	mvn.w	r3, r3, lsr #21
 8004930:	ea6f 5343 	mvn.w	r3, r3, lsl #21
							CAN1->sFilterRegister[filterConfig->filterBankNum].FR2 &= (
 8004934:	4823      	ldr	r0, [pc, #140]	; (80049c4 <CAN_InitFilterBank+0x2b8>)
 8004936:	6879      	ldr	r1, [r7, #4]
 8004938:	7809      	ldrb	r1, [r1, #0]
 800493a:	401a      	ands	r2, r3
 800493c:	f101 0348 	add.w	r3, r1, #72	; 0x48
 8004940:	00db      	lsls	r3, r3, #3
 8004942:	4403      	add	r3, r0
 8004944:	605a      	str	r2, [r3, #4]
						break;
 8004946:	e028      	b.n	800499a <CAN_InitFilterBank+0x28e>
							CAN1->sFilterRegister[filterConfig->filterBankNum].FR1 &= (
 8004948:	4a1e      	ldr	r2, [pc, #120]	; (80049c4 <CAN_InitFilterBank+0x2b8>)
 800494a:	687b      	ldr	r3, [r7, #4]
 800494c:	781b      	ldrb	r3, [r3, #0]
 800494e:	3348      	adds	r3, #72	; 0x48
 8004950:	f852 2033 	ldr.w	r2, [r2, r3, lsl #3]
								(((u32)filterConfig->accepted[0].id)<<3)   |   // extended ID
 8004954:	687b      	ldr	r3, [r7, #4]
 8004956:	685b      	ldr	r3, [r3, #4]
 8004958:	00db      	lsls	r3, r3, #3
 800495a:	f043 0307 	orr.w	r3, r3, #7
							CAN1->sFilterRegister[filterConfig->filterBankNum].FR1 &= (
 800495e:	4819      	ldr	r0, [pc, #100]	; (80049c4 <CAN_InitFilterBank+0x2b8>)
 8004960:	6879      	ldr	r1, [r7, #4]
 8004962:	7809      	ldrb	r1, [r1, #0]
 8004964:	401a      	ands	r2, r3
 8004966:	f101 0348 	add.w	r3, r1, #72	; 0x48
 800496a:	f840 2033 	str.w	r2, [r0, r3, lsl #3]
							CAN1->sFilterRegister[filterConfig->filterBankNum].FR2 &= (
 800496e:	4a15      	ldr	r2, [pc, #84]	; (80049c4 <CAN_InitFilterBank+0x2b8>)
 8004970:	687b      	ldr	r3, [r7, #4]
 8004972:	781b      	ldrb	r3, [r3, #0]
 8004974:	3348      	adds	r3, #72	; 0x48
 8004976:	00db      	lsls	r3, r3, #3
 8004978:	4413      	add	r3, r2
 800497a:	685a      	ldr	r2, [r3, #4]
								(((u32)filterConfig->accepted[0].mask)<<3)     |  // extended ID
 800497c:	687b      	ldr	r3, [r7, #4]
 800497e:	689b      	ldr	r3, [r3, #8]
 8004980:	00db      	lsls	r3, r3, #3
 8004982:	f043 0307 	orr.w	r3, r3, #7
							CAN1->sFilterRegister[filterConfig->filterBankNum].FR2 &= (
 8004986:	480f      	ldr	r0, [pc, #60]	; (80049c4 <CAN_InitFilterBank+0x2b8>)
 8004988:	6879      	ldr	r1, [r7, #4]
 800498a:	7809      	ldrb	r1, [r1, #0]
 800498c:	401a      	ands	r2, r3
 800498e:	f101 0348 	add.w	r3, r1, #72	; 0x48
 8004992:	00db      	lsls	r3, r3, #3
 8004994:	4403      	add	r3, r0
 8004996:	605a      	str	r2, [r3, #4]
						break;
 8004998:	bf00      	nop
				break;
 800499a:	bf00      	nop
		break;
 800499c:	e10c      	b.n	8004bb8 <CAN_InitFilterBank+0x4ac>

		case ID_LIST:
			SET_BIT(CAN1->FM1R, filterConfig->filterBankNum);
 800499e:	4b09      	ldr	r3, [pc, #36]	; (80049c4 <CAN_InitFilterBank+0x2b8>)
 80049a0:	f8d3 2204 	ldr.w	r2, [r3, #516]	; 0x204
 80049a4:	687b      	ldr	r3, [r7, #4]
 80049a6:	781b      	ldrb	r3, [r3, #0]
 80049a8:	4619      	mov	r1, r3
 80049aa:	2301      	movs	r3, #1
 80049ac:	408b      	lsls	r3, r1
 80049ae:	4905      	ldr	r1, [pc, #20]	; (80049c4 <CAN_InitFilterBank+0x2b8>)
 80049b0:	4313      	orrs	r3, r2
 80049b2:	f8c1 3204 	str.w	r3, [r1, #516]	; 0x204

			switch(filterConfig->scale)
 80049b6:	687b      	ldr	r3, [r7, #4]
 80049b8:	785b      	ldrb	r3, [r3, #1]
 80049ba:	2b00      	cmp	r3, #0
 80049bc:	d004      	beq.n	80049c8 <CAN_InitFilterBank+0x2bc>
 80049be:	2b01      	cmp	r3, #1
 80049c0:	d075      	beq.n	8004aae <CAN_InitFilterBank+0x3a2>
							);
						break;
					}
				break;
			}
		break;
 80049c2:	e0f8      	b.n	8004bb6 <CAN_InitFilterBank+0x4aa>
 80049c4:	40006400 	.word	0x40006400
					CLR_BIT(CAN1->FS1R, filterConfig->filterBankNum);	// 16bit scale
 80049c8:	4b88      	ldr	r3, [pc, #544]	; (8004bec <CAN_InitFilterBank+0x4e0>)
 80049ca:	f8d3 220c 	ldr.w	r2, [r3, #524]	; 0x20c
 80049ce:	687b      	ldr	r3, [r7, #4]
 80049d0:	781b      	ldrb	r3, [r3, #0]
 80049d2:	4619      	mov	r1, r3
 80049d4:	2301      	movs	r3, #1
 80049d6:	408b      	lsls	r3, r1
 80049d8:	43db      	mvns	r3, r3
 80049da:	4984      	ldr	r1, [pc, #528]	; (8004bec <CAN_InitFilterBank+0x4e0>)
 80049dc:	4013      	ands	r3, r2
 80049de:	f8c1 320c 	str.w	r3, [r1, #524]	; 0x20c
						((filterConfig->accepted[0].idType)<<3)  |  // standard ID
 80049e2:	687b      	ldr	r3, [r7, #4]
 80049e4:	7b1b      	ldrb	r3, [r3, #12]
 80049e6:	00da      	lsls	r2, r3, #3
						((filterConfig->accepted[0].frameType)<<4)  |  // RTR
 80049e8:	687b      	ldr	r3, [r7, #4]
 80049ea:	7b5b      	ldrb	r3, [r3, #13]
 80049ec:	011b      	lsls	r3, r3, #4
						((filterConfig->accepted[0].idType)<<3)  |  // standard ID
 80049ee:	4313      	orrs	r3, r2
 80049f0:	461c      	mov	r4, r3
						((filterConfig->accepted[0].id)<<5)    // ID
 80049f2:	687b      	ldr	r3, [r7, #4]
 80049f4:	685b      	ldr	r3, [r3, #4]
 80049f6:	015b      	lsls	r3, r3, #5
					CAN1->sFilterRegister[filterConfig->filterBankNum].FR1 = (
 80049f8:	497c      	ldr	r1, [pc, #496]	; (8004bec <CAN_InitFilterBank+0x4e0>)
 80049fa:	687a      	ldr	r2, [r7, #4]
 80049fc:	7812      	ldrb	r2, [r2, #0]
 80049fe:	4610      	mov	r0, r2
						((filterConfig->accepted[0].frameType)<<4)  |  // RTR
 8004a00:	ea44 0203 	orr.w	r2, r4, r3
					CAN1->sFilterRegister[filterConfig->filterBankNum].FR1 = (
 8004a04:	f100 0348 	add.w	r3, r0, #72	; 0x48
 8004a08:	f841 2033 	str.w	r2, [r1, r3, lsl #3]
					CAN1->sFilterRegister[filterConfig->filterBankNum].FR1 |= (
 8004a0c:	4a77      	ldr	r2, [pc, #476]	; (8004bec <CAN_InitFilterBank+0x4e0>)
 8004a0e:	687b      	ldr	r3, [r7, #4]
 8004a10:	781b      	ldrb	r3, [r3, #0]
 8004a12:	3348      	adds	r3, #72	; 0x48
 8004a14:	f852 2033 	ldr.w	r2, [r2, r3, lsl #3]
						((filterConfig->accepted[1].idType)<<19)  |  // standard ID
 8004a18:	687b      	ldr	r3, [r7, #4]
 8004a1a:	7e1b      	ldrb	r3, [r3, #24]
 8004a1c:	04d9      	lsls	r1, r3, #19
						((filterConfig->accepted[1].frameType)<<20)  |  // RTR
 8004a1e:	687b      	ldr	r3, [r7, #4]
 8004a20:	7e5b      	ldrb	r3, [r3, #25]
 8004a22:	051b      	lsls	r3, r3, #20
						((filterConfig->accepted[1].idType)<<19)  |  // standard ID
 8004a24:	430b      	orrs	r3, r1
 8004a26:	4619      	mov	r1, r3
						((filterConfig->accepted[1].id)<<21)    // ID
 8004a28:	687b      	ldr	r3, [r7, #4]
 8004a2a:	691b      	ldr	r3, [r3, #16]
 8004a2c:	055b      	lsls	r3, r3, #21
						((filterConfig->accepted[1].frameType)<<20)  |  // RTR
 8004a2e:	430b      	orrs	r3, r1
					CAN1->sFilterRegister[filterConfig->filterBankNum].FR1 |= (
 8004a30:	486e      	ldr	r0, [pc, #440]	; (8004bec <CAN_InitFilterBank+0x4e0>)
 8004a32:	6879      	ldr	r1, [r7, #4]
 8004a34:	7809      	ldrb	r1, [r1, #0]
 8004a36:	431a      	orrs	r2, r3
 8004a38:	f101 0348 	add.w	r3, r1, #72	; 0x48
 8004a3c:	f840 2033 	str.w	r2, [r0, r3, lsl #3]
						((filterConfig->accepted[2].idType)<<3)  |  // standard ID
 8004a40:	687b      	ldr	r3, [r7, #4]
 8004a42:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 8004a46:	00da      	lsls	r2, r3, #3
						((filterConfig->accepted[2].frameType)<<4)  |  // RTR
 8004a48:	687b      	ldr	r3, [r7, #4]
 8004a4a:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
 8004a4e:	011b      	lsls	r3, r3, #4
						((filterConfig->accepted[2].idType)<<3)  |  // standard ID
 8004a50:	4313      	orrs	r3, r2
 8004a52:	461c      	mov	r4, r3
						((filterConfig->accepted[2].id)<<5)    // ID
 8004a54:	687b      	ldr	r3, [r7, #4]
 8004a56:	69db      	ldr	r3, [r3, #28]
 8004a58:	015b      	lsls	r3, r3, #5
					CAN1->sFilterRegister[filterConfig->filterBankNum].FR2 = (
 8004a5a:	4964      	ldr	r1, [pc, #400]	; (8004bec <CAN_InitFilterBank+0x4e0>)
 8004a5c:	687a      	ldr	r2, [r7, #4]
 8004a5e:	7812      	ldrb	r2, [r2, #0]
 8004a60:	4610      	mov	r0, r2
						((filterConfig->accepted[2].frameType)<<4)  |  // RTR
 8004a62:	ea44 0203 	orr.w	r2, r4, r3
					CAN1->sFilterRegister[filterConfig->filterBankNum].FR2 = (
 8004a66:	f100 0348 	add.w	r3, r0, #72	; 0x48
 8004a6a:	00db      	lsls	r3, r3, #3
 8004a6c:	440b      	add	r3, r1
 8004a6e:	605a      	str	r2, [r3, #4]
					CAN1->sFilterRegister[filterConfig->filterBankNum].FR2 |= (
 8004a70:	4a5e      	ldr	r2, [pc, #376]	; (8004bec <CAN_InitFilterBank+0x4e0>)
 8004a72:	687b      	ldr	r3, [r7, #4]
 8004a74:	781b      	ldrb	r3, [r3, #0]
 8004a76:	3348      	adds	r3, #72	; 0x48
 8004a78:	00db      	lsls	r3, r3, #3
 8004a7a:	4413      	add	r3, r2
 8004a7c:	685a      	ldr	r2, [r3, #4]
						((filterConfig->accepted[3].idType)<<19)  |  // standard ID
 8004a7e:	687b      	ldr	r3, [r7, #4]
 8004a80:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 8004a84:	04d9      	lsls	r1, r3, #19
						((filterConfig->accepted[3].frameType)<<20)  |  // RTR
 8004a86:	687b      	ldr	r3, [r7, #4]
 8004a88:	f893 3031 	ldrb.w	r3, [r3, #49]	; 0x31
 8004a8c:	051b      	lsls	r3, r3, #20
						((filterConfig->accepted[3].idType)<<19)  |  // standard ID
 8004a8e:	430b      	orrs	r3, r1
 8004a90:	4619      	mov	r1, r3
						((filterConfig->accepted[3].id)<<21)    // ID
 8004a92:	687b      	ldr	r3, [r7, #4]
 8004a94:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8004a96:	055b      	lsls	r3, r3, #21
						((filterConfig->accepted[3].frameType)<<20)  |  // RTR
 8004a98:	430b      	orrs	r3, r1
					CAN1->sFilterRegister[filterConfig->filterBankNum].FR2 |= (
 8004a9a:	4854      	ldr	r0, [pc, #336]	; (8004bec <CAN_InitFilterBank+0x4e0>)
 8004a9c:	6879      	ldr	r1, [r7, #4]
 8004a9e:	7809      	ldrb	r1, [r1, #0]
 8004aa0:	431a      	orrs	r2, r3
 8004aa2:	f101 0348 	add.w	r3, r1, #72	; 0x48
 8004aa6:	00db      	lsls	r3, r3, #3
 8004aa8:	4403      	add	r3, r0
 8004aaa:	605a      	str	r2, [r3, #4]
				break;
 8004aac:	e083      	b.n	8004bb6 <CAN_InitFilterBank+0x4aa>
					SET_BIT(CAN1->FS1R, filterConfig->filterBankNum);	// 32bit scale
 8004aae:	4b4f      	ldr	r3, [pc, #316]	; (8004bec <CAN_InitFilterBank+0x4e0>)
 8004ab0:	f8d3 220c 	ldr.w	r2, [r3, #524]	; 0x20c
 8004ab4:	687b      	ldr	r3, [r7, #4]
 8004ab6:	781b      	ldrb	r3, [r3, #0]
 8004ab8:	4619      	mov	r1, r3
 8004aba:	2301      	movs	r3, #1
 8004abc:	408b      	lsls	r3, r1
 8004abe:	494b      	ldr	r1, [pc, #300]	; (8004bec <CAN_InitFilterBank+0x4e0>)
 8004ac0:	4313      	orrs	r3, r2
 8004ac2:	f8c1 320c 	str.w	r3, [r1, #524]	; 0x20c
						((u32)(filterConfig->accepted[0].frameType)<<1)  |  // RTR
 8004ac6:	687b      	ldr	r3, [r7, #4]
 8004ac8:	7b5b      	ldrb	r3, [r3, #13]
 8004aca:	005a      	lsls	r2, r3, #1
						((u32)(filterConfig->accepted[0].idType)<<2)    // IDE
 8004acc:	687b      	ldr	r3, [r7, #4]
 8004ace:	7b1b      	ldrb	r3, [r3, #12]
 8004ad0:	009b      	lsls	r3, r3, #2
					CAN1->sFilterRegister[filterConfig->filterBankNum].FR1 = (
 8004ad2:	4846      	ldr	r0, [pc, #280]	; (8004bec <CAN_InitFilterBank+0x4e0>)
 8004ad4:	6879      	ldr	r1, [r7, #4]
 8004ad6:	7809      	ldrb	r1, [r1, #0]
						((u32)(filterConfig->accepted[0].frameType)<<1)  |  // RTR
 8004ad8:	431a      	orrs	r2, r3
					CAN1->sFilterRegister[filterConfig->filterBankNum].FR1 = (
 8004ada:	f101 0348 	add.w	r3, r1, #72	; 0x48
 8004ade:	f840 2033 	str.w	r2, [r0, r3, lsl #3]
					switch(filterConfig->accepted[0].idType)
 8004ae2:	687b      	ldr	r3, [r7, #4]
 8004ae4:	7b1b      	ldrb	r3, [r3, #12]
 8004ae6:	2b00      	cmp	r3, #0
 8004ae8:	d002      	beq.n	8004af0 <CAN_InitFilterBank+0x3e4>
 8004aea:	2b01      	cmp	r3, #1
 8004aec:	d012      	beq.n	8004b14 <CAN_InitFilterBank+0x408>
 8004aee:	e023      	b.n	8004b38 <CAN_InitFilterBank+0x42c>
							CAN1->sFilterRegister[filterConfig->filterBankNum].FR1 |= (
 8004af0:	4a3e      	ldr	r2, [pc, #248]	; (8004bec <CAN_InitFilterBank+0x4e0>)
 8004af2:	687b      	ldr	r3, [r7, #4]
 8004af4:	781b      	ldrb	r3, [r3, #0]
 8004af6:	3348      	adds	r3, #72	; 0x48
 8004af8:	f852 2033 	ldr.w	r2, [r2, r3, lsl #3]
								((u32)(filterConfig->accepted[0].id)<<21)    // ID
 8004afc:	687b      	ldr	r3, [r7, #4]
 8004afe:	685b      	ldr	r3, [r3, #4]
 8004b00:	055b      	lsls	r3, r3, #21
							CAN1->sFilterRegister[filterConfig->filterBankNum].FR1 |= (
 8004b02:	483a      	ldr	r0, [pc, #232]	; (8004bec <CAN_InitFilterBank+0x4e0>)
 8004b04:	6879      	ldr	r1, [r7, #4]
 8004b06:	7809      	ldrb	r1, [r1, #0]
 8004b08:	431a      	orrs	r2, r3
 8004b0a:	f101 0348 	add.w	r3, r1, #72	; 0x48
 8004b0e:	f840 2033 	str.w	r2, [r0, r3, lsl #3]
						break;
 8004b12:	e011      	b.n	8004b38 <CAN_InitFilterBank+0x42c>
							CAN1->sFilterRegister[filterConfig->filterBankNum].FR1 |= (
 8004b14:	4a35      	ldr	r2, [pc, #212]	; (8004bec <CAN_InitFilterBank+0x4e0>)
 8004b16:	687b      	ldr	r3, [r7, #4]
 8004b18:	781b      	ldrb	r3, [r3, #0]
 8004b1a:	3348      	adds	r3, #72	; 0x48
 8004b1c:	f852 2033 	ldr.w	r2, [r2, r3, lsl #3]
								((u32)(filterConfig->accepted[0].id)<<3)    // ID
 8004b20:	687b      	ldr	r3, [r7, #4]
 8004b22:	685b      	ldr	r3, [r3, #4]
 8004b24:	00db      	lsls	r3, r3, #3
							CAN1->sFilterRegister[filterConfig->filterBankNum].FR1 |= (
 8004b26:	4831      	ldr	r0, [pc, #196]	; (8004bec <CAN_InitFilterBank+0x4e0>)
 8004b28:	6879      	ldr	r1, [r7, #4]
 8004b2a:	7809      	ldrb	r1, [r1, #0]
 8004b2c:	431a      	orrs	r2, r3
 8004b2e:	f101 0348 	add.w	r3, r1, #72	; 0x48
 8004b32:	f840 2033 	str.w	r2, [r0, r3, lsl #3]
						break;
 8004b36:	bf00      	nop
						((u32)(filterConfig->accepted[1].frameType)<<1)  |  // RTR
 8004b38:	687b      	ldr	r3, [r7, #4]
 8004b3a:	7e5b      	ldrb	r3, [r3, #25]
 8004b3c:	005a      	lsls	r2, r3, #1
						((u32)(filterConfig->accepted[1].idType)<<2)    // IDE
 8004b3e:	687b      	ldr	r3, [r7, #4]
 8004b40:	7e1b      	ldrb	r3, [r3, #24]
 8004b42:	009b      	lsls	r3, r3, #2
					CAN1->sFilterRegister[filterConfig->filterBankNum].FR2 = (
 8004b44:	4829      	ldr	r0, [pc, #164]	; (8004bec <CAN_InitFilterBank+0x4e0>)
 8004b46:	6879      	ldr	r1, [r7, #4]
 8004b48:	7809      	ldrb	r1, [r1, #0]
						((u32)(filterConfig->accepted[1].frameType)<<1)  |  // RTR
 8004b4a:	431a      	orrs	r2, r3
					CAN1->sFilterRegister[filterConfig->filterBankNum].FR2 = (
 8004b4c:	f101 0348 	add.w	r3, r1, #72	; 0x48
 8004b50:	00db      	lsls	r3, r3, #3
 8004b52:	4403      	add	r3, r0
 8004b54:	605a      	str	r2, [r3, #4]
					switch(filterConfig->accepted[1].idType)
 8004b56:	687b      	ldr	r3, [r7, #4]
 8004b58:	7e1b      	ldrb	r3, [r3, #24]
 8004b5a:	2b00      	cmp	r3, #0
 8004b5c:	d002      	beq.n	8004b64 <CAN_InitFilterBank+0x458>
 8004b5e:	2b01      	cmp	r3, #1
 8004b60:	d014      	beq.n	8004b8c <CAN_InitFilterBank+0x480>
				break;
 8004b62:	e027      	b.n	8004bb4 <CAN_InitFilterBank+0x4a8>
							CAN1->sFilterRegister[filterConfig->filterBankNum].FR2 |= (
 8004b64:	4a21      	ldr	r2, [pc, #132]	; (8004bec <CAN_InitFilterBank+0x4e0>)
 8004b66:	687b      	ldr	r3, [r7, #4]
 8004b68:	781b      	ldrb	r3, [r3, #0]
 8004b6a:	3348      	adds	r3, #72	; 0x48
 8004b6c:	00db      	lsls	r3, r3, #3
 8004b6e:	4413      	add	r3, r2
 8004b70:	685a      	ldr	r2, [r3, #4]
								((u32)(filterConfig->accepted[1].id)<<21)    // ID
 8004b72:	687b      	ldr	r3, [r7, #4]
 8004b74:	691b      	ldr	r3, [r3, #16]
 8004b76:	055b      	lsls	r3, r3, #21
							CAN1->sFilterRegister[filterConfig->filterBankNum].FR2 |= (
 8004b78:	481c      	ldr	r0, [pc, #112]	; (8004bec <CAN_InitFilterBank+0x4e0>)
 8004b7a:	6879      	ldr	r1, [r7, #4]
 8004b7c:	7809      	ldrb	r1, [r1, #0]
 8004b7e:	431a      	orrs	r2, r3
 8004b80:	f101 0348 	add.w	r3, r1, #72	; 0x48
 8004b84:	00db      	lsls	r3, r3, #3
 8004b86:	4403      	add	r3, r0
 8004b88:	605a      	str	r2, [r3, #4]
						break;
 8004b8a:	e013      	b.n	8004bb4 <CAN_InitFilterBank+0x4a8>
							CAN1->sFilterRegister[filterConfig->filterBankNum].FR2 |= (
 8004b8c:	4a17      	ldr	r2, [pc, #92]	; (8004bec <CAN_InitFilterBank+0x4e0>)
 8004b8e:	687b      	ldr	r3, [r7, #4]
 8004b90:	781b      	ldrb	r3, [r3, #0]
 8004b92:	3348      	adds	r3, #72	; 0x48
 8004b94:	00db      	lsls	r3, r3, #3
 8004b96:	4413      	add	r3, r2
 8004b98:	685a      	ldr	r2, [r3, #4]
								((u32)(filterConfig->accepted[1].id)<<3)    // ID
 8004b9a:	687b      	ldr	r3, [r7, #4]
 8004b9c:	691b      	ldr	r3, [r3, #16]
 8004b9e:	00db      	lsls	r3, r3, #3
							CAN1->sFilterRegister[filterConfig->filterBankNum].FR2 |= (
 8004ba0:	4812      	ldr	r0, [pc, #72]	; (8004bec <CAN_InitFilterBank+0x4e0>)
 8004ba2:	6879      	ldr	r1, [r7, #4]
 8004ba4:	7809      	ldrb	r1, [r1, #0]
 8004ba6:	431a      	orrs	r2, r3
 8004ba8:	f101 0348 	add.w	r3, r1, #72	; 0x48
 8004bac:	00db      	lsls	r3, r3, #3
 8004bae:	4403      	add	r3, r0
 8004bb0:	605a      	str	r2, [r3, #4]
						break;
 8004bb2:	bf00      	nop
				break;
 8004bb4:	bf00      	nop
		break;
 8004bb6:	bf00      	nop
	}



	SET_BIT(CAN1->FA1R, filterConfig->filterBankNum);		// activate filter
 8004bb8:	4b0c      	ldr	r3, [pc, #48]	; (8004bec <CAN_InitFilterBank+0x4e0>)
 8004bba:	f8d3 221c 	ldr.w	r2, [r3, #540]	; 0x21c
 8004bbe:	687b      	ldr	r3, [r7, #4]
 8004bc0:	781b      	ldrb	r3, [r3, #0]
 8004bc2:	4619      	mov	r1, r3
 8004bc4:	2301      	movs	r3, #1
 8004bc6:	408b      	lsls	r3, r1
 8004bc8:	4908      	ldr	r1, [pc, #32]	; (8004bec <CAN_InitFilterBank+0x4e0>)
 8004bca:	4313      	orrs	r3, r2
 8004bcc:	f8c1 321c 	str.w	r3, [r1, #540]	; 0x21c

	CLR_BIT(CAN1->FMR, 0);	// exit filter initialization mode
 8004bd0:	4b06      	ldr	r3, [pc, #24]	; (8004bec <CAN_InitFilterBank+0x4e0>)
 8004bd2:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
 8004bd6:	4a05      	ldr	r2, [pc, #20]	; (8004bec <CAN_InitFilterBank+0x4e0>)
 8004bd8:	f023 0301 	bic.w	r3, r3, #1
 8004bdc:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
 8004be0:	e000      	b.n	8004be4 <CAN_InitFilterBank+0x4d8>
		return;
 8004be2:	bf00      	nop
}
 8004be4:	3708      	adds	r7, #8
 8004be6:	46bd      	mov	sp, r7
 8004be8:	bc90      	pop	{r4, r7}
 8004bea:	4770      	bx	lr
 8004bec:	40006400 	.word	0x40006400

08004bf0 <CAN_Tx>:




void CAN_Tx(CAN_Frame_t* frame)
{
 8004bf0:	b480      	push	{r7}
 8004bf2:	b085      	sub	sp, #20
 8004bf4:	af00      	add	r7, sp, #0
 8004bf6:	6078      	str	r0, [r7, #4]
	/* wait while all three mailboxes are busy (bits 26, 27, 28 are 0) */
	while((((CAN1->TSR)>>26) & 0x7) == 0);
 8004bf8:	bf00      	nop
 8004bfa:	4b78      	ldr	r3, [pc, #480]	; (8004ddc <CAN_Tx+0x1ec>)
 8004bfc:	689b      	ldr	r3, [r3, #8]
 8004bfe:	0e9b      	lsrs	r3, r3, #26
 8004c00:	f003 0307 	and.w	r3, r3, #7
 8004c04:	2b00      	cmp	r3, #0
 8004c06:	d0f8      	beq.n	8004bfa <CAN_Tx+0xa>

	u8 freeMailBox = 0;
 8004c08:	2300      	movs	r3, #0
 8004c0a:	73fb      	strb	r3, [r7, #15]
	for(u8 i = 0; i < 3; i++)
 8004c0c:	2300      	movs	r3, #0
 8004c0e:	73bb      	strb	r3, [r7, #14]
 8004c10:	e00f      	b.n	8004c32 <CAN_Tx+0x42>
	{
		if(GET_BIT(CAN1->TSR, i + 26) == 1)
 8004c12:	4b72      	ldr	r3, [pc, #456]	; (8004ddc <CAN_Tx+0x1ec>)
 8004c14:	689a      	ldr	r2, [r3, #8]
 8004c16:	7bbb      	ldrb	r3, [r7, #14]
 8004c18:	331a      	adds	r3, #26
 8004c1a:	fa22 f303 	lsr.w	r3, r2, r3
 8004c1e:	f003 0301 	and.w	r3, r3, #1
 8004c22:	2b01      	cmp	r3, #1
 8004c24:	d102      	bne.n	8004c2c <CAN_Tx+0x3c>
		{
			freeMailBox = i;
 8004c26:	7bbb      	ldrb	r3, [r7, #14]
 8004c28:	73fb      	strb	r3, [r7, #15]
			break;
 8004c2a:	e005      	b.n	8004c38 <CAN_Tx+0x48>
	for(u8 i = 0; i < 3; i++)
 8004c2c:	7bbb      	ldrb	r3, [r7, #14]
 8004c2e:	3301      	adds	r3, #1
 8004c30:	73bb      	strb	r3, [r7, #14]
 8004c32:	7bbb      	ldrb	r3, [r7, #14]
 8004c34:	2b02      	cmp	r3, #2
 8004c36:	d9ec      	bls.n	8004c12 <CAN_Tx+0x22>
		}
	}

	/* fill lowest 4 bytes of data in TDLR register */
	CAN1->sTxMailBox[freeMailBox].TDLR = 0;
 8004c38:	4a68      	ldr	r2, [pc, #416]	; (8004ddc <CAN_Tx+0x1ec>)
 8004c3a:	7bfb      	ldrb	r3, [r7, #15]
 8004c3c:	011b      	lsls	r3, r3, #4
 8004c3e:	4413      	add	r3, r2
 8004c40:	f503 73c4 	add.w	r3, r3, #392	; 0x188
 8004c44:	2200      	movs	r2, #0
 8004c46:	601a      	str	r2, [r3, #0]
	for(u8 i = 0; i < 4; i++)
 8004c48:	2300      	movs	r3, #0
 8004c4a:	737b      	strb	r3, [r7, #13]
 8004c4c:	e01b      	b.n	8004c86 <CAN_Tx+0x96>
	{
		CAN1->sTxMailBox[freeMailBox].TDLR |= (frame->data[i])<<(i<<3);
 8004c4e:	4a63      	ldr	r2, [pc, #396]	; (8004ddc <CAN_Tx+0x1ec>)
 8004c50:	7bfb      	ldrb	r3, [r7, #15]
 8004c52:	011b      	lsls	r3, r3, #4
 8004c54:	4413      	add	r3, r2
 8004c56:	f503 73c4 	add.w	r3, r3, #392	; 0x188
 8004c5a:	681a      	ldr	r2, [r3, #0]
 8004c5c:	7b7b      	ldrb	r3, [r7, #13]
 8004c5e:	6879      	ldr	r1, [r7, #4]
 8004c60:	440b      	add	r3, r1
 8004c62:	79db      	ldrb	r3, [r3, #7]
 8004c64:	4619      	mov	r1, r3
 8004c66:	7b7b      	ldrb	r3, [r7, #13]
 8004c68:	00db      	lsls	r3, r3, #3
 8004c6a:	fa01 f303 	lsl.w	r3, r1, r3
 8004c6e:	4618      	mov	r0, r3
 8004c70:	495a      	ldr	r1, [pc, #360]	; (8004ddc <CAN_Tx+0x1ec>)
 8004c72:	7bfb      	ldrb	r3, [r7, #15]
 8004c74:	4302      	orrs	r2, r0
 8004c76:	011b      	lsls	r3, r3, #4
 8004c78:	440b      	add	r3, r1
 8004c7a:	f503 73c4 	add.w	r3, r3, #392	; 0x188
 8004c7e:	601a      	str	r2, [r3, #0]
	for(u8 i = 0; i < 4; i++)
 8004c80:	7b7b      	ldrb	r3, [r7, #13]
 8004c82:	3301      	adds	r3, #1
 8004c84:	737b      	strb	r3, [r7, #13]
 8004c86:	7b7b      	ldrb	r3, [r7, #13]
 8004c88:	2b03      	cmp	r3, #3
 8004c8a:	d9e0      	bls.n	8004c4e <CAN_Tx+0x5e>
	}

	/* fill highest 4 bytes of data in TDHR register */
	CAN1->sTxMailBox[freeMailBox].TDHR = 0;
 8004c8c:	4a53      	ldr	r2, [pc, #332]	; (8004ddc <CAN_Tx+0x1ec>)
 8004c8e:	7bfb      	ldrb	r3, [r7, #15]
 8004c90:	011b      	lsls	r3, r3, #4
 8004c92:	4413      	add	r3, r2
 8004c94:	f503 73c6 	add.w	r3, r3, #396	; 0x18c
 8004c98:	2200      	movs	r2, #0
 8004c9a:	601a      	str	r2, [r3, #0]
	for(u8 i = 0; i < 4; i++)
 8004c9c:	2300      	movs	r3, #0
 8004c9e:	733b      	strb	r3, [r7, #12]
 8004ca0:	e01c      	b.n	8004cdc <CAN_Tx+0xec>
	{
		CAN1->sTxMailBox[freeMailBox].TDHR |= (frame->data[i + 4])<<(i<<3);
 8004ca2:	4a4e      	ldr	r2, [pc, #312]	; (8004ddc <CAN_Tx+0x1ec>)
 8004ca4:	7bfb      	ldrb	r3, [r7, #15]
 8004ca6:	011b      	lsls	r3, r3, #4
 8004ca8:	4413      	add	r3, r2
 8004caa:	f503 73c6 	add.w	r3, r3, #396	; 0x18c
 8004cae:	681a      	ldr	r2, [r3, #0]
 8004cb0:	7b3b      	ldrb	r3, [r7, #12]
 8004cb2:	3304      	adds	r3, #4
 8004cb4:	6879      	ldr	r1, [r7, #4]
 8004cb6:	440b      	add	r3, r1
 8004cb8:	79db      	ldrb	r3, [r3, #7]
 8004cba:	4619      	mov	r1, r3
 8004cbc:	7b3b      	ldrb	r3, [r7, #12]
 8004cbe:	00db      	lsls	r3, r3, #3
 8004cc0:	fa01 f303 	lsl.w	r3, r1, r3
 8004cc4:	4618      	mov	r0, r3
 8004cc6:	4945      	ldr	r1, [pc, #276]	; (8004ddc <CAN_Tx+0x1ec>)
 8004cc8:	7bfb      	ldrb	r3, [r7, #15]
 8004cca:	4302      	orrs	r2, r0
 8004ccc:	011b      	lsls	r3, r3, #4
 8004cce:	440b      	add	r3, r1
 8004cd0:	f503 73c6 	add.w	r3, r3, #396	; 0x18c
 8004cd4:	601a      	str	r2, [r3, #0]
	for(u8 i = 0; i < 4; i++)
 8004cd6:	7b3b      	ldrb	r3, [r7, #12]
 8004cd8:	3301      	adds	r3, #1
 8004cda:	733b      	strb	r3, [r7, #12]
 8004cdc:	7b3b      	ldrb	r3, [r7, #12]
 8004cde:	2b03      	cmp	r3, #3
 8004ce0:	d9df      	bls.n	8004ca2 <CAN_Tx+0xb2>
	}

	CAN1->sTxMailBox[freeMailBox].TDTR = frame->DLC;			// Data Lenght Code (DLC)
 8004ce2:	687b      	ldr	r3, [r7, #4]
 8004ce4:	7999      	ldrb	r1, [r3, #6]
 8004ce6:	4a3d      	ldr	r2, [pc, #244]	; (8004ddc <CAN_Tx+0x1ec>)
 8004ce8:	7bfb      	ldrb	r3, [r7, #15]
 8004cea:	3318      	adds	r3, #24
 8004cec:	011b      	lsls	r3, r3, #4
 8004cee:	4413      	add	r3, r2
 8004cf0:	3304      	adds	r3, #4
 8004cf2:	6019      	str	r1, [r3, #0]


	/* configure IDE & RTR */
	CAN1->sTxMailBox[freeMailBox].TIR = (
		((frame->frameType)<<1)  |   // RTR
 8004cf4:	687b      	ldr	r3, [r7, #4]
 8004cf6:	795b      	ldrb	r3, [r3, #5]
 8004cf8:	005a      	lsls	r2, r3, #1
		((frame->idType)<<2)         // IDE
 8004cfa:	687b      	ldr	r3, [r7, #4]
 8004cfc:	791b      	ldrb	r3, [r3, #4]
 8004cfe:	009b      	lsls	r3, r3, #2
		((frame->frameType)<<1)  |   // RTR
 8004d00:	ea42 0103 	orr.w	r1, r2, r3
	CAN1->sTxMailBox[freeMailBox].TIR = (
 8004d04:	4a35      	ldr	r2, [pc, #212]	; (8004ddc <CAN_Tx+0x1ec>)
 8004d06:	7bfb      	ldrb	r3, [r7, #15]
 8004d08:	3318      	adds	r3, #24
 8004d0a:	011b      	lsls	r3, r3, #4
 8004d0c:	4413      	add	r3, r2
 8004d0e:	6019      	str	r1, [r3, #0]
	);

	/* configure ID */
	switch(frame->idType)
 8004d10:	687b      	ldr	r3, [r7, #4]
 8004d12:	791b      	ldrb	r3, [r3, #4]
 8004d14:	2b00      	cmp	r3, #0
 8004d16:	d002      	beq.n	8004d1e <CAN_Tx+0x12e>
 8004d18:	2b01      	cmp	r3, #1
 8004d1a:	d011      	beq.n	8004d40 <CAN_Tx+0x150>
 8004d1c:	e021      	b.n	8004d62 <CAN_Tx+0x172>
	{
		case STANDARD_ID:
			CAN1->sTxMailBox[freeMailBox].TIR |= (frame->id)<<21;
 8004d1e:	4a2f      	ldr	r2, [pc, #188]	; (8004ddc <CAN_Tx+0x1ec>)
 8004d20:	7bfb      	ldrb	r3, [r7, #15]
 8004d22:	3318      	adds	r3, #24
 8004d24:	011b      	lsls	r3, r3, #4
 8004d26:	4413      	add	r3, r2
 8004d28:	6819      	ldr	r1, [r3, #0]
 8004d2a:	687b      	ldr	r3, [r7, #4]
 8004d2c:	681b      	ldr	r3, [r3, #0]
 8004d2e:	055a      	lsls	r2, r3, #21
 8004d30:	482a      	ldr	r0, [pc, #168]	; (8004ddc <CAN_Tx+0x1ec>)
 8004d32:	7bfb      	ldrb	r3, [r7, #15]
 8004d34:	430a      	orrs	r2, r1
 8004d36:	3318      	adds	r3, #24
 8004d38:	011b      	lsls	r3, r3, #4
 8004d3a:	4403      	add	r3, r0
 8004d3c:	601a      	str	r2, [r3, #0]
		break;
 8004d3e:	e010      	b.n	8004d62 <CAN_Tx+0x172>

		case EXTENDED_ID:
			CAN1->sTxMailBox[freeMailBox].TIR |= (frame->id)<<3;
 8004d40:	4a26      	ldr	r2, [pc, #152]	; (8004ddc <CAN_Tx+0x1ec>)
 8004d42:	7bfb      	ldrb	r3, [r7, #15]
 8004d44:	3318      	adds	r3, #24
 8004d46:	011b      	lsls	r3, r3, #4
 8004d48:	4413      	add	r3, r2
 8004d4a:	6819      	ldr	r1, [r3, #0]
 8004d4c:	687b      	ldr	r3, [r7, #4]
 8004d4e:	681b      	ldr	r3, [r3, #0]
 8004d50:	00da      	lsls	r2, r3, #3
 8004d52:	4822      	ldr	r0, [pc, #136]	; (8004ddc <CAN_Tx+0x1ec>)
 8004d54:	7bfb      	ldrb	r3, [r7, #15]
 8004d56:	430a      	orrs	r2, r1
 8004d58:	3318      	adds	r3, #24
 8004d5a:	011b      	lsls	r3, r3, #4
 8004d5c:	4403      	add	r3, r0
 8004d5e:	601a      	str	r2, [r3, #0]
		break;
 8004d60:	bf00      	nop
	}


	switch(frame->frameType)
 8004d62:	687b      	ldr	r3, [r7, #4]
 8004d64:	795b      	ldrb	r3, [r3, #5]
 8004d66:	2b00      	cmp	r3, #0
 8004d68:	d002      	beq.n	8004d70 <CAN_Tx+0x180>
 8004d6a:	2b01      	cmp	r3, #1
 8004d6c:	d011      	beq.n	8004d92 <CAN_Tx+0x1a2>
 8004d6e:	e021      	b.n	8004db4 <CAN_Tx+0x1c4>
	{
		case DATA_FRAME:
			CAN1->sTxMailBox[freeMailBox].TIR |= (frame->id)<<21;
 8004d70:	4a1a      	ldr	r2, [pc, #104]	; (8004ddc <CAN_Tx+0x1ec>)
 8004d72:	7bfb      	ldrb	r3, [r7, #15]
 8004d74:	3318      	adds	r3, #24
 8004d76:	011b      	lsls	r3, r3, #4
 8004d78:	4413      	add	r3, r2
 8004d7a:	6819      	ldr	r1, [r3, #0]
 8004d7c:	687b      	ldr	r3, [r7, #4]
 8004d7e:	681b      	ldr	r3, [r3, #0]
 8004d80:	055a      	lsls	r2, r3, #21
 8004d82:	4816      	ldr	r0, [pc, #88]	; (8004ddc <CAN_Tx+0x1ec>)
 8004d84:	7bfb      	ldrb	r3, [r7, #15]
 8004d86:	430a      	orrs	r2, r1
 8004d88:	3318      	adds	r3, #24
 8004d8a:	011b      	lsls	r3, r3, #4
 8004d8c:	4403      	add	r3, r0
 8004d8e:	601a      	str	r2, [r3, #0]
		break;
 8004d90:	e010      	b.n	8004db4 <CAN_Tx+0x1c4>

		case REMOTE_FRAME:
			CAN1->sTxMailBox[freeMailBox].TIR |= (frame->id)<<3;
 8004d92:	4a12      	ldr	r2, [pc, #72]	; (8004ddc <CAN_Tx+0x1ec>)
 8004d94:	7bfb      	ldrb	r3, [r7, #15]
 8004d96:	3318      	adds	r3, #24
 8004d98:	011b      	lsls	r3, r3, #4
 8004d9a:	4413      	add	r3, r2
 8004d9c:	6819      	ldr	r1, [r3, #0]
 8004d9e:	687b      	ldr	r3, [r7, #4]
 8004da0:	681b      	ldr	r3, [r3, #0]
 8004da2:	00da      	lsls	r2, r3, #3
 8004da4:	480d      	ldr	r0, [pc, #52]	; (8004ddc <CAN_Tx+0x1ec>)
 8004da6:	7bfb      	ldrb	r3, [r7, #15]
 8004da8:	430a      	orrs	r2, r1
 8004daa:	3318      	adds	r3, #24
 8004dac:	011b      	lsls	r3, r3, #4
 8004dae:	4403      	add	r3, r0
 8004db0:	601a      	str	r2, [r3, #0]
		break;
 8004db2:	bf00      	nop
	}


	SET_BIT(CAN1->sTxMailBox[freeMailBox].TIR, 0);	// Tx request
 8004db4:	4a09      	ldr	r2, [pc, #36]	; (8004ddc <CAN_Tx+0x1ec>)
 8004db6:	7bfb      	ldrb	r3, [r7, #15]
 8004db8:	3318      	adds	r3, #24
 8004dba:	011b      	lsls	r3, r3, #4
 8004dbc:	4413      	add	r3, r2
 8004dbe:	681a      	ldr	r2, [r3, #0]
 8004dc0:	4906      	ldr	r1, [pc, #24]	; (8004ddc <CAN_Tx+0x1ec>)
 8004dc2:	7bfb      	ldrb	r3, [r7, #15]
 8004dc4:	f042 0201 	orr.w	r2, r2, #1
 8004dc8:	3318      	adds	r3, #24
 8004dca:	011b      	lsls	r3, r3, #4
 8004dcc:	440b      	add	r3, r1
 8004dce:	601a      	str	r2, [r3, #0]
}
 8004dd0:	bf00      	nop
 8004dd2:	3714      	adds	r7, #20
 8004dd4:	46bd      	mov	sp, r7
 8004dd6:	bc80      	pop	{r7}
 8004dd8:	4770      	bx	lr
 8004dda:	bf00      	nop
 8004ddc:	40006400 	.word	0x40006400

08004de0 <CAN_Rx>:


void CAN_Rx(CAN_Frame_t* frame, CAN_RxFifo_t fifo)
{
 8004de0:	b480      	push	{r7}
 8004de2:	b085      	sub	sp, #20
 8004de4:	af00      	add	r7, sp, #0
 8004de6:	6078      	str	r0, [r7, #4]
 8004de8:	460b      	mov	r3, r1
 8004dea:	70fb      	strb	r3, [r7, #3]
	// wait until there's received data in FIFO
	switch(fifo)
 8004dec:	78fb      	ldrb	r3, [r7, #3]
 8004dee:	2b00      	cmp	r3, #0
 8004df0:	d002      	beq.n	8004df8 <CAN_Rx+0x18>
 8004df2:	2b01      	cmp	r3, #1
 8004df4:	d008      	beq.n	8004e08 <CAN_Rx+0x28>
 8004df6:	e00f      	b.n	8004e18 <CAN_Rx+0x38>
	{
		case FIFO_0:
			while((CAN1->RF0R & 0x3) == 0);
 8004df8:	bf00      	nop
 8004dfa:	4b57      	ldr	r3, [pc, #348]	; (8004f58 <CAN_Rx+0x178>)
 8004dfc:	68db      	ldr	r3, [r3, #12]
 8004dfe:	f003 0303 	and.w	r3, r3, #3
 8004e02:	2b00      	cmp	r3, #0
 8004e04:	d0f9      	beq.n	8004dfa <CAN_Rx+0x1a>
		break;
 8004e06:	e007      	b.n	8004e18 <CAN_Rx+0x38>

		case FIFO_1:
			while((CAN1->RF1R & 0x3) == 0);
 8004e08:	bf00      	nop
 8004e0a:	4b53      	ldr	r3, [pc, #332]	; (8004f58 <CAN_Rx+0x178>)
 8004e0c:	691b      	ldr	r3, [r3, #16]
 8004e0e:	f003 0303 	and.w	r3, r3, #3
 8004e12:	2b00      	cmp	r3, #0
 8004e14:	d0f9      	beq.n	8004e0a <CAN_Rx+0x2a>
		break;
 8004e16:	bf00      	nop
	}


	/* read frame type (RTR) */
	switch(GET_BIT(CAN1->sFIFOMailBox[fifo].RIR, 1))
 8004e18:	4a4f      	ldr	r2, [pc, #316]	; (8004f58 <CAN_Rx+0x178>)
 8004e1a:	78fb      	ldrb	r3, [r7, #3]
 8004e1c:	331b      	adds	r3, #27
 8004e1e:	011b      	lsls	r3, r3, #4
 8004e20:	4413      	add	r3, r2
 8004e22:	681b      	ldr	r3, [r3, #0]
 8004e24:	085b      	lsrs	r3, r3, #1
 8004e26:	f003 0301 	and.w	r3, r3, #1
 8004e2a:	2b00      	cmp	r3, #0
 8004e2c:	d002      	beq.n	8004e34 <CAN_Rx+0x54>
 8004e2e:	2b01      	cmp	r3, #1
 8004e30:	d004      	beq.n	8004e3c <CAN_Rx+0x5c>
 8004e32:	e007      	b.n	8004e44 <CAN_Rx+0x64>
	{
		case 0:
			frame->frameType = DATA_FRAME;
 8004e34:	687b      	ldr	r3, [r7, #4]
 8004e36:	2200      	movs	r2, #0
 8004e38:	715a      	strb	r2, [r3, #5]
		break;
 8004e3a:	e003      	b.n	8004e44 <CAN_Rx+0x64>

		case 1:
			frame->frameType = REMOTE_FRAME;
 8004e3c:	687b      	ldr	r3, [r7, #4]
 8004e3e:	2201      	movs	r2, #1
 8004e40:	715a      	strb	r2, [r3, #5]
		break;
 8004e42:	bf00      	nop
	}


	/* read ID type (IDE) */
	switch(GET_BIT(CAN1->sFIFOMailBox[fifo].RIR, 2))
 8004e44:	4a44      	ldr	r2, [pc, #272]	; (8004f58 <CAN_Rx+0x178>)
 8004e46:	78fb      	ldrb	r3, [r7, #3]
 8004e48:	331b      	adds	r3, #27
 8004e4a:	011b      	lsls	r3, r3, #4
 8004e4c:	4413      	add	r3, r2
 8004e4e:	681b      	ldr	r3, [r3, #0]
 8004e50:	089b      	lsrs	r3, r3, #2
 8004e52:	f003 0301 	and.w	r3, r3, #1
 8004e56:	2b00      	cmp	r3, #0
 8004e58:	d002      	beq.n	8004e60 <CAN_Rx+0x80>
 8004e5a:	2b01      	cmp	r3, #1
 8004e5c:	d004      	beq.n	8004e68 <CAN_Rx+0x88>
 8004e5e:	e007      	b.n	8004e70 <CAN_Rx+0x90>
	{
		case 0:
			frame->idType = STANDARD_ID;
 8004e60:	687b      	ldr	r3, [r7, #4]
 8004e62:	2200      	movs	r2, #0
 8004e64:	711a      	strb	r2, [r3, #4]
		break;
 8004e66:	e003      	b.n	8004e70 <CAN_Rx+0x90>

		case 1:
			frame->idType = EXTENDED_ID;
 8004e68:	687b      	ldr	r3, [r7, #4]
 8004e6a:	2201      	movs	r2, #1
 8004e6c:	711a      	strb	r2, [r3, #4]
		break;
 8004e6e:	bf00      	nop
	}


	/* read ID */
	switch(frame->idType)
 8004e70:	687b      	ldr	r3, [r7, #4]
 8004e72:	791b      	ldrb	r3, [r3, #4]
 8004e74:	2b00      	cmp	r3, #0
 8004e76:	d002      	beq.n	8004e7e <CAN_Rx+0x9e>
 8004e78:	2b01      	cmp	r3, #1
 8004e7a:	d00a      	beq.n	8004e92 <CAN_Rx+0xb2>
 8004e7c:	e013      	b.n	8004ea6 <CAN_Rx+0xc6>
	{
		case STANDARD_ID:
			frame->id = (CAN1->sFIFOMailBox[fifo].RIR)>>21;
 8004e7e:	4a36      	ldr	r2, [pc, #216]	; (8004f58 <CAN_Rx+0x178>)
 8004e80:	78fb      	ldrb	r3, [r7, #3]
 8004e82:	331b      	adds	r3, #27
 8004e84:	011b      	lsls	r3, r3, #4
 8004e86:	4413      	add	r3, r2
 8004e88:	681b      	ldr	r3, [r3, #0]
 8004e8a:	0d5a      	lsrs	r2, r3, #21
 8004e8c:	687b      	ldr	r3, [r7, #4]
 8004e8e:	601a      	str	r2, [r3, #0]
		break;
 8004e90:	e009      	b.n	8004ea6 <CAN_Rx+0xc6>

		case 1:
			frame->id = (CAN1->sFIFOMailBox[fifo].RIR)>>3;
 8004e92:	4a31      	ldr	r2, [pc, #196]	; (8004f58 <CAN_Rx+0x178>)
 8004e94:	78fb      	ldrb	r3, [r7, #3]
 8004e96:	331b      	adds	r3, #27
 8004e98:	011b      	lsls	r3, r3, #4
 8004e9a:	4413      	add	r3, r2
 8004e9c:	681b      	ldr	r3, [r3, #0]
 8004e9e:	08da      	lsrs	r2, r3, #3
 8004ea0:	687b      	ldr	r3, [r7, #4]
 8004ea2:	601a      	str	r2, [r3, #0]
		break;
 8004ea4:	bf00      	nop
	}


	/* read DLC */
	frame->DLC = (CAN1->sFIFOMailBox[fifo].RDTR) & 0xF;
 8004ea6:	4a2c      	ldr	r2, [pc, #176]	; (8004f58 <CAN_Rx+0x178>)
 8004ea8:	78fb      	ldrb	r3, [r7, #3]
 8004eaa:	331b      	adds	r3, #27
 8004eac:	011b      	lsls	r3, r3, #4
 8004eae:	4413      	add	r3, r2
 8004eb0:	3304      	adds	r3, #4
 8004eb2:	681b      	ldr	r3, [r3, #0]
 8004eb4:	b2db      	uxtb	r3, r3
 8004eb6:	f003 030f 	and.w	r3, r3, #15
 8004eba:	b2da      	uxtb	r2, r3
 8004ebc:	687b      	ldr	r3, [r7, #4]
 8004ebe:	719a      	strb	r2, [r3, #6]



	/* read lower 4 bytes of data from RDLR register */
	for(u8 i = 0; i < 4; i++)
 8004ec0:	2300      	movs	r3, #0
 8004ec2:	73fb      	strb	r3, [r7, #15]
 8004ec4:	e012      	b.n	8004eec <CAN_Rx+0x10c>
	{
		frame->data[i] = (CAN1->sFIFOMailBox[fifo].RDLR)>>(i<<3);
 8004ec6:	4a24      	ldr	r2, [pc, #144]	; (8004f58 <CAN_Rx+0x178>)
 8004ec8:	78fb      	ldrb	r3, [r7, #3]
 8004eca:	011b      	lsls	r3, r3, #4
 8004ecc:	4413      	add	r3, r2
 8004ece:	f503 73dc 	add.w	r3, r3, #440	; 0x1b8
 8004ed2:	681a      	ldr	r2, [r3, #0]
 8004ed4:	7bfb      	ldrb	r3, [r7, #15]
 8004ed6:	00db      	lsls	r3, r3, #3
 8004ed8:	40da      	lsrs	r2, r3
 8004eda:	7bfb      	ldrb	r3, [r7, #15]
 8004edc:	b2d1      	uxtb	r1, r2
 8004ede:	687a      	ldr	r2, [r7, #4]
 8004ee0:	4413      	add	r3, r2
 8004ee2:	460a      	mov	r2, r1
 8004ee4:	71da      	strb	r2, [r3, #7]
	for(u8 i = 0; i < 4; i++)
 8004ee6:	7bfb      	ldrb	r3, [r7, #15]
 8004ee8:	3301      	adds	r3, #1
 8004eea:	73fb      	strb	r3, [r7, #15]
 8004eec:	7bfb      	ldrb	r3, [r7, #15]
 8004eee:	2b03      	cmp	r3, #3
 8004ef0:	d9e9      	bls.n	8004ec6 <CAN_Rx+0xe6>
	}

	/* read higher 4 bytes of data from RDHR register */
	for(u8 i = 0; i < 4; i++)
 8004ef2:	2300      	movs	r3, #0
 8004ef4:	73bb      	strb	r3, [r7, #14]
 8004ef6:	e013      	b.n	8004f20 <CAN_Rx+0x140>
	{
		frame->data[i + 4] = (CAN1->sFIFOMailBox[fifo].RDHR)>>(i<<3);
 8004ef8:	4a17      	ldr	r2, [pc, #92]	; (8004f58 <CAN_Rx+0x178>)
 8004efa:	78fb      	ldrb	r3, [r7, #3]
 8004efc:	011b      	lsls	r3, r3, #4
 8004efe:	4413      	add	r3, r2
 8004f00:	f503 73de 	add.w	r3, r3, #444	; 0x1bc
 8004f04:	681a      	ldr	r2, [r3, #0]
 8004f06:	7bbb      	ldrb	r3, [r7, #14]
 8004f08:	00db      	lsls	r3, r3, #3
 8004f0a:	40da      	lsrs	r2, r3
 8004f0c:	7bbb      	ldrb	r3, [r7, #14]
 8004f0e:	3304      	adds	r3, #4
 8004f10:	b2d1      	uxtb	r1, r2
 8004f12:	687a      	ldr	r2, [r7, #4]
 8004f14:	4413      	add	r3, r2
 8004f16:	460a      	mov	r2, r1
 8004f18:	71da      	strb	r2, [r3, #7]
	for(u8 i = 0; i < 4; i++)
 8004f1a:	7bbb      	ldrb	r3, [r7, #14]
 8004f1c:	3301      	adds	r3, #1
 8004f1e:	73bb      	strb	r3, [r7, #14]
 8004f20:	7bbb      	ldrb	r3, [r7, #14]
 8004f22:	2b03      	cmp	r3, #3
 8004f24:	d9e8      	bls.n	8004ef8 <CAN_Rx+0x118>
	}


	/* release FIFO (pop first message) */
	switch(fifo)
 8004f26:	78fb      	ldrb	r3, [r7, #3]
 8004f28:	2b00      	cmp	r3, #0
 8004f2a:	d002      	beq.n	8004f32 <CAN_Rx+0x152>
 8004f2c:	2b01      	cmp	r3, #1
 8004f2e:	d007      	beq.n	8004f40 <CAN_Rx+0x160>

		case FIFO_1:
			SET_BIT(CAN1->RF1R, 5);
		break;
	}
}
 8004f30:	e00d      	b.n	8004f4e <CAN_Rx+0x16e>
			SET_BIT(CAN1->RF0R, 5);
 8004f32:	4b09      	ldr	r3, [pc, #36]	; (8004f58 <CAN_Rx+0x178>)
 8004f34:	68db      	ldr	r3, [r3, #12]
 8004f36:	4a08      	ldr	r2, [pc, #32]	; (8004f58 <CAN_Rx+0x178>)
 8004f38:	f043 0320 	orr.w	r3, r3, #32
 8004f3c:	60d3      	str	r3, [r2, #12]
		break;
 8004f3e:	e006      	b.n	8004f4e <CAN_Rx+0x16e>
			SET_BIT(CAN1->RF1R, 5);
 8004f40:	4b05      	ldr	r3, [pc, #20]	; (8004f58 <CAN_Rx+0x178>)
 8004f42:	691b      	ldr	r3, [r3, #16]
 8004f44:	4a04      	ldr	r2, [pc, #16]	; (8004f58 <CAN_Rx+0x178>)
 8004f46:	f043 0320 	orr.w	r3, r3, #32
 8004f4a:	6113      	str	r3, [r2, #16]
		break;
 8004f4c:	bf00      	nop
}
 8004f4e:	bf00      	nop
 8004f50:	3714      	adds	r7, #20
 8004f52:	46bd      	mov	sp, r7
 8004f54:	bc80      	pop	{r7}
 8004f56:	4770      	bx	lr
 8004f58:	40006400 	.word	0x40006400

08004f5c <ECU_UpdateConfig>:
	ecuConfig.activeBootRegion  =  FPEC_ReadByte(ACTIVE_BOOT_PAGE_NUMBER, ACTIVE_BOOT_BYTE_OFFSET);
}


void  ECU_UpdateConfig(void)
{
 8004f5c:	b580      	push	{r7, lr}
 8004f5e:	af00      	add	r7, sp, #0
	FPEC_WriteByte(ACTIVE_APP_PAGE_NUMBER , ACTIVE_APP_BYTE_OFFSET , ecuConfig.activeAppRegion);
 8004f60:	4b07      	ldr	r3, [pc, #28]	; (8004f80 <ECU_UpdateConfig+0x24>)
 8004f62:	781b      	ldrb	r3, [r3, #0]
 8004f64:	461a      	mov	r2, r3
 8004f66:	2102      	movs	r1, #2
 8004f68:	2005      	movs	r0, #5
 8004f6a:	f000 fa03 	bl	8005374 <FPEC_WriteByte>
	FPEC_WriteByte(ACTIVE_BOOT_PAGE_NUMBER, ACTIVE_BOOT_BYTE_OFFSET, ecuConfig.activeBootRegion);
 8004f6e:	4b04      	ldr	r3, [pc, #16]	; (8004f80 <ECU_UpdateConfig+0x24>)
 8004f70:	785b      	ldrb	r3, [r3, #1]
 8004f72:	461a      	mov	r2, r3
 8004f74:	2101      	movs	r1, #1
 8004f76:	2005      	movs	r0, #5
 8004f78:	f000 f9fc 	bl	8005374 <FPEC_WriteByte>
}
 8004f7c:	bf00      	nop
 8004f7e:	bd80      	pop	{r7, pc}
 8004f80:	20000044 	.word	0x20000044

08004f84 <ECU_ConfigActivateApp>:


void  ECU_ConfigActivateApp(void)
{
 8004f84:	b580      	push	{r7, lr}
 8004f86:	af00      	add	r7, sp, #0
	FPEC_WriteByte(BRANCHING_PAGE_NUMBER, BRANCHING_BYTE_OFFSET, APP);
 8004f88:	2241      	movs	r2, #65	; 0x41
 8004f8a:	2100      	movs	r1, #0
 8004f8c:	2005      	movs	r0, #5
 8004f8e:	f000 f9f1 	bl	8005374 <FPEC_WriteByte>
}
 8004f92:	bf00      	nop
 8004f94:	bd80      	pop	{r7, pc}
	...

08004f98 <FPEC_UnlockFlash>:
  * @brief  Unlock the Embedded Flash.
  * @param  None.
  * @retval None.
  */
static void  FPEC_UnlockFlash(void)
{
 8004f98:	b480      	push	{r7}
 8004f9a:	af00      	add	r7, sp, #0
	FLASH->KEYR = KEY1;  //write KEY1
 8004f9c:	4b04      	ldr	r3, [pc, #16]	; (8004fb0 <FPEC_UnlockFlash+0x18>)
 8004f9e:	4a05      	ldr	r2, [pc, #20]	; (8004fb4 <FPEC_UnlockFlash+0x1c>)
 8004fa0:	605a      	str	r2, [r3, #4]
	FLASH->KEYR = KEY2;  //write KEY2
 8004fa2:	4b03      	ldr	r3, [pc, #12]	; (8004fb0 <FPEC_UnlockFlash+0x18>)
 8004fa4:	4a04      	ldr	r2, [pc, #16]	; (8004fb8 <FPEC_UnlockFlash+0x20>)
 8004fa6:	605a      	str	r2, [r3, #4]
}
 8004fa8:	bf00      	nop
 8004faa:	46bd      	mov	sp, r7
 8004fac:	bc80      	pop	{r7}
 8004fae:	4770      	bx	lr
 8004fb0:	40022000 	.word	0x40022000
 8004fb4:	45670123 	.word	0x45670123
 8004fb8:	cdef89ab 	.word	0xcdef89ab

08004fbc <FPEC_LockFlash>:
  * @brief  Lock the Embedded Flash.
  * @param  None.
  * @retval None.
  */
static void  FPEC_LockFlash(void)
{
 8004fbc:	b480      	push	{r7}
 8004fbe:	af00      	add	r7, sp, #0
	SET_BIT(FLASH->CR, 7);
 8004fc0:	4b04      	ldr	r3, [pc, #16]	; (8004fd4 <FPEC_LockFlash+0x18>)
 8004fc2:	691b      	ldr	r3, [r3, #16]
 8004fc4:	4a03      	ldr	r2, [pc, #12]	; (8004fd4 <FPEC_LockFlash+0x18>)
 8004fc6:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8004fca:	6113      	str	r3, [r2, #16]
}
 8004fcc:	bf00      	nop
 8004fce:	46bd      	mov	sp, r7
 8004fd0:	bc80      	pop	{r7}
 8004fd2:	4770      	bx	lr
 8004fd4:	40022000 	.word	0x40022000

08004fd8 <FPEC_CheckErrors>:
  * @brief  Check if any errors occurred while programming/erasing flash
  * @param  None
  * @retval Flash error
  */
static FPEC_Error_t  FPEC_CheckErrors(void)
{
 8004fd8:	b480      	push	{r7}
 8004fda:	af00      	add	r7, sp, #0
	if(GET_BIT(FLASH->SR, 4) == 1)
 8004fdc:	4b11      	ldr	r3, [pc, #68]	; (8005024 <FPEC_CheckErrors+0x4c>)
 8004fde:	68db      	ldr	r3, [r3, #12]
 8004fe0:	091b      	lsrs	r3, r3, #4
 8004fe2:	f003 0301 	and.w	r3, r3, #1
 8004fe6:	2b01      	cmp	r3, #1
 8004fe8:	d107      	bne.n	8004ffa <FPEC_CheckErrors+0x22>
	{
		SET_BIT(FLASH->SR, 4);  //clear flag
 8004fea:	4b0e      	ldr	r3, [pc, #56]	; (8005024 <FPEC_CheckErrors+0x4c>)
 8004fec:	68db      	ldr	r3, [r3, #12]
 8004fee:	4a0d      	ldr	r2, [pc, #52]	; (8005024 <FPEC_CheckErrors+0x4c>)
 8004ff0:	f043 0310 	orr.w	r3, r3, #16
 8004ff4:	60d3      	str	r3, [r2, #12]
		return  FPEC_WRITE_PROTECTION_ERROR;
 8004ff6:	2301      	movs	r3, #1
 8004ff8:	e00f      	b.n	800501a <FPEC_CheckErrors+0x42>
	}
	if(GET_BIT(FLASH->SR, 2) == 1)
 8004ffa:	4b0a      	ldr	r3, [pc, #40]	; (8005024 <FPEC_CheckErrors+0x4c>)
 8004ffc:	68db      	ldr	r3, [r3, #12]
 8004ffe:	089b      	lsrs	r3, r3, #2
 8005000:	f003 0301 	and.w	r3, r3, #1
 8005004:	2b01      	cmp	r3, #1
 8005006:	d107      	bne.n	8005018 <FPEC_CheckErrors+0x40>
	{
		SET_BIT(FLASH->SR, 2);  //clear flag
 8005008:	4b06      	ldr	r3, [pc, #24]	; (8005024 <FPEC_CheckErrors+0x4c>)
 800500a:	68db      	ldr	r3, [r3, #12]
 800500c:	4a05      	ldr	r2, [pc, #20]	; (8005024 <FPEC_CheckErrors+0x4c>)
 800500e:	f043 0304 	orr.w	r3, r3, #4
 8005012:	60d3      	str	r3, [r2, #12]
		return  FPEC_PROGRAMMING_ERROR;
 8005014:	2300      	movs	r3, #0
 8005016:	e000      	b.n	800501a <FPEC_CheckErrors+0x42>
	}
	return FPEC_NO_ERRORS;
 8005018:	2302      	movs	r3, #2
}
 800501a:	4618      	mov	r0, r3
 800501c:	46bd      	mov	sp, r7
 800501e:	bc80      	pop	{r7}
 8005020:	4770      	bx	lr
 8005022:	bf00      	nop
 8005024:	40022000 	.word	0x40022000

08005028 <FPEC_DirectWriteHalfWord>:
  * @note   offsetAddress must be even number
  * @param  data: actual data you want to write.
  * @retval Flash error
  */
FPEC_Error_t  FPEC_DirectWriteHalfWord(u8 pageNumber, u16 offsetAddress, u16 data)
{
 8005028:	b580      	push	{r7, lr}
 800502a:	b084      	sub	sp, #16
 800502c:	af00      	add	r7, sp, #0
 800502e:	4603      	mov	r3, r0
 8005030:	71fb      	strb	r3, [r7, #7]
 8005032:	460b      	mov	r3, r1
 8005034:	80bb      	strh	r3, [r7, #4]
 8005036:	4613      	mov	r3, r2
 8005038:	807b      	strh	r3, [r7, #2]
	if(offsetAddress % 2 == 1)	return FPEC_PROGRAMMING_ERROR;
 800503a:	88bb      	ldrh	r3, [r7, #4]
 800503c:	f003 0301 	and.w	r3, r3, #1
 8005040:	b29b      	uxth	r3, r3
 8005042:	2b00      	cmp	r3, #0
 8005044:	d001      	beq.n	800504a <FPEC_DirectWriteHalfWord+0x22>
 8005046:	2300      	movs	r3, #0
 8005048:	e03d      	b.n	80050c6 <FPEC_DirectWriteHalfWord+0x9e>

	FPEC_Error_t writeStatus = FPEC_NO_ERRORS;
 800504a:	2302      	movs	r3, #2
 800504c:	73fb      	strb	r3, [r7, #15]

	FPEC_UnlockFlash();
 800504e:	f7ff ffa3 	bl	8004f98 <FPEC_UnlockFlash>

	/* Wait if the flash is busy */
	while(GET_BIT(FLASH->SR, 0) == 1) {}
 8005052:	bf00      	nop
 8005054:	4b1e      	ldr	r3, [pc, #120]	; (80050d0 <FPEC_DirectWriteHalfWord+0xa8>)
 8005056:	68db      	ldr	r3, [r3, #12]
 8005058:	f003 0301 	and.w	r3, r3, #1
 800505c:	2b01      	cmp	r3, #1
 800505e:	d0f9      	beq.n	8005054 <FPEC_DirectWriteHalfWord+0x2c>

	SET_BIT(FLASH->CR, 0);   //Set bit 0 to select flash programming
 8005060:	4b1b      	ldr	r3, [pc, #108]	; (80050d0 <FPEC_DirectWriteHalfWord+0xa8>)
 8005062:	691b      	ldr	r3, [r3, #16]
 8005064:	4a1a      	ldr	r2, [pc, #104]	; (80050d0 <FPEC_DirectWriteHalfWord+0xa8>)
 8005066:	f043 0301 	orr.w	r3, r3, #1
 800506a:	6113      	str	r3, [r2, #16]

	/* Get physical address of the desired half word */
	volatile u16* physicalAddress = (volatile u16*)(FLASH_BASE_ADDRESS + pageNumber * PAGE_SIZE_BYTES + offsetAddress);
 800506c:	79fb      	ldrb	r3, [r7, #7]
 800506e:	029b      	lsls	r3, r3, #10
 8005070:	461a      	mov	r2, r3
 8005072:	88bb      	ldrh	r3, [r7, #4]
 8005074:	4413      	add	r3, r2
 8005076:	f103 6300 	add.w	r3, r3, #134217728	; 0x8000000
 800507a:	60bb      	str	r3, [r7, #8]
	*physicalAddress = data;
 800507c:	68bb      	ldr	r3, [r7, #8]
 800507e:	887a      	ldrh	r2, [r7, #2]
 8005080:	801a      	strh	r2, [r3, #0]

	/* Wait until writing is completed */
	while(GET_BIT(FLASH->SR, 0) == 1) {}
 8005082:	bf00      	nop
 8005084:	4b12      	ldr	r3, [pc, #72]	; (80050d0 <FPEC_DirectWriteHalfWord+0xa8>)
 8005086:	68db      	ldr	r3, [r3, #12]
 8005088:	f003 0301 	and.w	r3, r3, #1
 800508c:	2b01      	cmp	r3, #1
 800508e:	d0f9      	beq.n	8005084 <FPEC_DirectWriteHalfWord+0x5c>

	CLR_BIT(FLASH->CR, 0);   //clear bit 0 to unselect flash programming
 8005090:	4b0f      	ldr	r3, [pc, #60]	; (80050d0 <FPEC_DirectWriteHalfWord+0xa8>)
 8005092:	691b      	ldr	r3, [r3, #16]
 8005094:	4a0e      	ldr	r2, [pc, #56]	; (80050d0 <FPEC_DirectWriteHalfWord+0xa8>)
 8005096:	f023 0301 	bic.w	r3, r3, #1
 800509a:	6113      	str	r3, [r2, #16]

	/* Read the written half word to make sure it's written successfully */
	if(FPEC_ReadHalfWord(pageNumber, offsetAddress) == data)
 800509c:	88ba      	ldrh	r2, [r7, #4]
 800509e:	79fb      	ldrb	r3, [r7, #7]
 80050a0:	4611      	mov	r1, r2
 80050a2:	4618      	mov	r0, r3
 80050a4:	f000 f926 	bl	80052f4 <FPEC_ReadHalfWord>
 80050a8:	4603      	mov	r3, r0
 80050aa:	461a      	mov	r2, r3
 80050ac:	887b      	ldrh	r3, [r7, #2]
 80050ae:	4293      	cmp	r3, r2
 80050b0:	d102      	bne.n	80050b8 <FPEC_DirectWriteHalfWord+0x90>
	{
		writeStatus = FPEC_NO_ERRORS;
 80050b2:	2302      	movs	r3, #2
 80050b4:	73fb      	strb	r3, [r7, #15]
 80050b6:	e003      	b.n	80050c0 <FPEC_DirectWriteHalfWord+0x98>
	}
	else
	{
		writeStatus =  FPEC_CheckErrors();
 80050b8:	f7ff ff8e 	bl	8004fd8 <FPEC_CheckErrors>
 80050bc:	4603      	mov	r3, r0
 80050be:	73fb      	strb	r3, [r7, #15]
	}

	FPEC_LockFlash();
 80050c0:	f7ff ff7c 	bl	8004fbc <FPEC_LockFlash>

	return writeStatus;
 80050c4:	7bfb      	ldrb	r3, [r7, #15]
}
 80050c6:	4618      	mov	r0, r3
 80050c8:	3710      	adds	r7, #16
 80050ca:	46bd      	mov	sp, r7
 80050cc:	bd80      	pop	{r7, pc}
 80050ce:	bf00      	nop
 80050d0:	40022000 	.word	0x40022000

080050d4 <FPEC_DirectWriteByte>:
  * @param  offsetAddress: offset address of the half word you want to write.
  * @param  data: actual data you want to write.
  * @retval Flash error
  */
FPEC_Error_t  FPEC_DirectWriteByte(u8 pageNumber, u16 offsetAddress, u8 data)
{
 80050d4:	b580      	push	{r7, lr}
 80050d6:	b084      	sub	sp, #16
 80050d8:	af00      	add	r7, sp, #0
 80050da:	4603      	mov	r3, r0
 80050dc:	71fb      	strb	r3, [r7, #7]
 80050de:	460b      	mov	r3, r1
 80050e0:	80bb      	strh	r3, [r7, #4]
 80050e2:	4613      	mov	r3, r2
 80050e4:	71bb      	strb	r3, [r7, #6]
	FPEC_Error_t writeStatus = FPEC_NO_ERRORS;
 80050e6:	2302      	movs	r3, #2
 80050e8:	73fb      	strb	r3, [r7, #15]

	FPEC_UnlockFlash();
 80050ea:	f7ff ff55 	bl	8004f98 <FPEC_UnlockFlash>

	/* Wait if the flash is busy */
	while(GET_BIT(FLASH->SR, 0) == 1) {}
 80050ee:	bf00      	nop
 80050f0:	4b1e      	ldr	r3, [pc, #120]	; (800516c <FPEC_DirectWriteByte+0x98>)
 80050f2:	68db      	ldr	r3, [r3, #12]
 80050f4:	f003 0301 	and.w	r3, r3, #1
 80050f8:	2b01      	cmp	r3, #1
 80050fa:	d0f9      	beq.n	80050f0 <FPEC_DirectWriteByte+0x1c>

	SET_BIT(FLASH->CR, 0);   //Set bit 0 to select flash programming
 80050fc:	4b1b      	ldr	r3, [pc, #108]	; (800516c <FPEC_DirectWriteByte+0x98>)
 80050fe:	691b      	ldr	r3, [r3, #16]
 8005100:	4a1a      	ldr	r2, [pc, #104]	; (800516c <FPEC_DirectWriteByte+0x98>)
 8005102:	f043 0301 	orr.w	r3, r3, #1
 8005106:	6113      	str	r3, [r2, #16]

	/* Get physical address of the desired half word */
	volatile u8* physicalAddress = (volatile u8*)(FLASH_BASE_ADDRESS + pageNumber * PAGE_SIZE_BYTES + offsetAddress);
 8005108:	79fb      	ldrb	r3, [r7, #7]
 800510a:	029b      	lsls	r3, r3, #10
 800510c:	461a      	mov	r2, r3
 800510e:	88bb      	ldrh	r3, [r7, #4]
 8005110:	4413      	add	r3, r2
 8005112:	f103 6300 	add.w	r3, r3, #134217728	; 0x8000000
 8005116:	60bb      	str	r3, [r7, #8]
	*physicalAddress = data;
 8005118:	68bb      	ldr	r3, [r7, #8]
 800511a:	79ba      	ldrb	r2, [r7, #6]
 800511c:	701a      	strb	r2, [r3, #0]

	/* Wait until writing is completed */
	while(GET_BIT(FLASH->SR, 0) == 1) {}
 800511e:	bf00      	nop
 8005120:	4b12      	ldr	r3, [pc, #72]	; (800516c <FPEC_DirectWriteByte+0x98>)
 8005122:	68db      	ldr	r3, [r3, #12]
 8005124:	f003 0301 	and.w	r3, r3, #1
 8005128:	2b01      	cmp	r3, #1
 800512a:	d0f9      	beq.n	8005120 <FPEC_DirectWriteByte+0x4c>

	CLR_BIT(FLASH->CR, 0);   //clear bit 0 to unselect flash programming
 800512c:	4b0f      	ldr	r3, [pc, #60]	; (800516c <FPEC_DirectWriteByte+0x98>)
 800512e:	691b      	ldr	r3, [r3, #16]
 8005130:	4a0e      	ldr	r2, [pc, #56]	; (800516c <FPEC_DirectWriteByte+0x98>)
 8005132:	f023 0301 	bic.w	r3, r3, #1
 8005136:	6113      	str	r3, [r2, #16]

	/* Read the written half word to make sure it's written successfully */
	if(FPEC_ReadByte(pageNumber, offsetAddress) == data)
 8005138:	88ba      	ldrh	r2, [r7, #4]
 800513a:	79fb      	ldrb	r3, [r7, #7]
 800513c:	4611      	mov	r1, r2
 800513e:	4618      	mov	r0, r3
 8005140:	f000 f8fa 	bl	8005338 <FPEC_ReadByte>
 8005144:	4603      	mov	r3, r0
 8005146:	461a      	mov	r2, r3
 8005148:	79bb      	ldrb	r3, [r7, #6]
 800514a:	4293      	cmp	r3, r2
 800514c:	d102      	bne.n	8005154 <FPEC_DirectWriteByte+0x80>
	{
		writeStatus = FPEC_NO_ERRORS;
 800514e:	2302      	movs	r3, #2
 8005150:	73fb      	strb	r3, [r7, #15]
 8005152:	e003      	b.n	800515c <FPEC_DirectWriteByte+0x88>
	}
	else
	{
		writeStatus =  FPEC_CheckErrors();
 8005154:	f7ff ff40 	bl	8004fd8 <FPEC_CheckErrors>
 8005158:	4603      	mov	r3, r0
 800515a:	73fb      	strb	r3, [r7, #15]
	}

	FPEC_LockFlash();
 800515c:	f7ff ff2e 	bl	8004fbc <FPEC_LockFlash>

	return writeStatus;
 8005160:	7bfb      	ldrb	r3, [r7, #15]
}
 8005162:	4618      	mov	r0, r3
 8005164:	3710      	adds	r7, #16
 8005166:	46bd      	mov	sp, r7
 8005168:	bd80      	pop	{r7, pc}
 800516a:	bf00      	nop
 800516c:	40022000 	.word	0x40022000

08005170 <FPEC_InitFlash>:
  * @note   This function must be called once before any reading, writing or erasing.
  * @param  None.
  * @retval Flash error.
  */
void  FPEC_InitFlash(void)
{
 8005170:	b580      	push	{r7, lr}
 8005172:	af00      	add	r7, sp, #0
	RCC_EnablePeripheralClock(FLITF_PERIPHERAL);
 8005174:	2004      	movs	r0, #4
 8005176:	f000 fb5d 	bl	8005834 <RCC_EnablePeripheralClock>
	FPEC_UnlockFlash();
 800517a:	f7ff ff0d 	bl	8004f98 <FPEC_UnlockFlash>
#elif  SYSTEM_CLK  <=  48000000
	SET_BIT(FLASH->ACR, 0);
	CLR_BIT(FLASH->ACR, 1);
	CLR_BIT(FLASH->ACR, 2);
#elif  SYSTEM_CLK  <=  72000000
	CLR_BIT(FLASH->ACR, 0);
 800517e:	4b0b      	ldr	r3, [pc, #44]	; (80051ac <FPEC_InitFlash+0x3c>)
 8005180:	681b      	ldr	r3, [r3, #0]
 8005182:	4a0a      	ldr	r2, [pc, #40]	; (80051ac <FPEC_InitFlash+0x3c>)
 8005184:	f023 0301 	bic.w	r3, r3, #1
 8005188:	6013      	str	r3, [r2, #0]
	SET_BIT(FLASH->ACR, 1);
 800518a:	4b08      	ldr	r3, [pc, #32]	; (80051ac <FPEC_InitFlash+0x3c>)
 800518c:	681b      	ldr	r3, [r3, #0]
 800518e:	4a07      	ldr	r2, [pc, #28]	; (80051ac <FPEC_InitFlash+0x3c>)
 8005190:	f043 0302 	orr.w	r3, r3, #2
 8005194:	6013      	str	r3, [r2, #0]
	CLR_BIT(FLASH->ACR, 2);
 8005196:	4b05      	ldr	r3, [pc, #20]	; (80051ac <FPEC_InitFlash+0x3c>)
 8005198:	681b      	ldr	r3, [r3, #0]
 800519a:	4a04      	ldr	r2, [pc, #16]	; (80051ac <FPEC_InitFlash+0x3c>)
 800519c:	f023 0304 	bic.w	r3, r3, #4
 80051a0:	6013      	str	r3, [r2, #0]
#endif

	FPEC_LockFlash();
 80051a2:	f7ff ff0b 	bl	8004fbc <FPEC_LockFlash>
}
 80051a6:	bf00      	nop
 80051a8:	bd80      	pop	{r7, pc}
 80051aa:	bf00      	nop
 80051ac:	40022000 	.word	0x40022000

080051b0 <FPEC_ErasePage>:
  * @param  pageNumber: number of the page to be erased.
  * @note   There are 128 pages in the flash memory (from page 0 to page 127)
  * @retval Flash error
  */
FPEC_Error_t  FPEC_ErasePage(u8 pageNumber)
{
 80051b0:	b580      	push	{r7, lr}
 80051b2:	b084      	sub	sp, #16
 80051b4:	af00      	add	r7, sp, #0
 80051b6:	4603      	mov	r3, r0
 80051b8:	71fb      	strb	r3, [r7, #7]
	FPEC_Error_t  eraseStatus;

	FPEC_UnlockFlash();
 80051ba:	f7ff feed 	bl	8004f98 <FPEC_UnlockFlash>

	/* Wait if the flash is busy */
	while(GET_BIT(FLASH->SR, 0) == 1) {}
 80051be:	bf00      	nop
 80051c0:	4b1f      	ldr	r3, [pc, #124]	; (8005240 <FPEC_ErasePage+0x90>)
 80051c2:	68db      	ldr	r3, [r3, #12]
 80051c4:	f003 0301 	and.w	r3, r3, #1
 80051c8:	2b01      	cmp	r3, #1
 80051ca:	d0f9      	beq.n	80051c0 <FPEC_ErasePage+0x10>

	SET_BIT(FLASH->CR, 1);   //Set bit 1 to select page erase
 80051cc:	4b1c      	ldr	r3, [pc, #112]	; (8005240 <FPEC_ErasePage+0x90>)
 80051ce:	691b      	ldr	r3, [r3, #16]
 80051d0:	4a1b      	ldr	r2, [pc, #108]	; (8005240 <FPEC_ErasePage+0x90>)
 80051d2:	f043 0302 	orr.w	r3, r3, #2
 80051d6:	6113      	str	r3, [r2, #16]

	/* Get address of first byte in the desired page to be erased */
	u32 pagePhysicalAddress = FLASH_BASE_ADDRESS + pageNumber * PAGE_SIZE_BYTES;
 80051d8:	79fb      	ldrb	r3, [r7, #7]
 80051da:	029b      	lsls	r3, r3, #10
 80051dc:	f103 6300 	add.w	r3, r3, #134217728	; 0x8000000
 80051e0:	60bb      	str	r3, [r7, #8]
	FLASH->AR = pagePhysicalAddress;
 80051e2:	4a17      	ldr	r2, [pc, #92]	; (8005240 <FPEC_ErasePage+0x90>)
 80051e4:	68bb      	ldr	r3, [r7, #8]
 80051e6:	6153      	str	r3, [r2, #20]

	SET_BIT(FLASH->CR, 6);   //Start erasing the page
 80051e8:	4b15      	ldr	r3, [pc, #84]	; (8005240 <FPEC_ErasePage+0x90>)
 80051ea:	691b      	ldr	r3, [r3, #16]
 80051ec:	4a14      	ldr	r2, [pc, #80]	; (8005240 <FPEC_ErasePage+0x90>)
 80051ee:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80051f2:	6113      	str	r3, [r2, #16]

	/* wait until page erasing is completed */
	while(GET_BIT(FLASH->SR, 0) == 1) {}
 80051f4:	bf00      	nop
 80051f6:	4b12      	ldr	r3, [pc, #72]	; (8005240 <FPEC_ErasePage+0x90>)
 80051f8:	68db      	ldr	r3, [r3, #12]
 80051fa:	f003 0301 	and.w	r3, r3, #1
 80051fe:	2b01      	cmp	r3, #1
 8005200:	d0f9      	beq.n	80051f6 <FPEC_ErasePage+0x46>

	CLR_BIT(FLASH->CR, 1);   //Clear bit 1 to unselect page erase
 8005202:	4b0f      	ldr	r3, [pc, #60]	; (8005240 <FPEC_ErasePage+0x90>)
 8005204:	691b      	ldr	r3, [r3, #16]
 8005206:	4a0e      	ldr	r2, [pc, #56]	; (8005240 <FPEC_ErasePage+0x90>)
 8005208:	f023 0302 	bic.w	r3, r3, #2
 800520c:	6113      	str	r3, [r2, #16]

	/* read first half word of this page to make sure it's erased successfully */
	if(FPEC_ReadHalfWord(pageNumber, 0) == 0xFFFF)
 800520e:	79fb      	ldrb	r3, [r7, #7]
 8005210:	2100      	movs	r1, #0
 8005212:	4618      	mov	r0, r3
 8005214:	f000 f86e 	bl	80052f4 <FPEC_ReadHalfWord>
 8005218:	4603      	mov	r3, r0
 800521a:	461a      	mov	r2, r3
 800521c:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8005220:	429a      	cmp	r2, r3
 8005222:	d102      	bne.n	800522a <FPEC_ErasePage+0x7a>
	{
		eraseStatus = FPEC_NO_ERRORS;
 8005224:	2302      	movs	r3, #2
 8005226:	73fb      	strb	r3, [r7, #15]
 8005228:	e003      	b.n	8005232 <FPEC_ErasePage+0x82>
	}
	else
	{
		eraseStatus = FPEC_CheckErrors();
 800522a:	f7ff fed5 	bl	8004fd8 <FPEC_CheckErrors>
 800522e:	4603      	mov	r3, r0
 8005230:	73fb      	strb	r3, [r7, #15]
	}

	FPEC_LockFlash();
 8005232:	f7ff fec3 	bl	8004fbc <FPEC_LockFlash>

	return eraseStatus;
 8005236:	7bfb      	ldrb	r3, [r7, #15]
}
 8005238:	4618      	mov	r0, r3
 800523a:	3710      	adds	r7, #16
 800523c:	46bd      	mov	sp, r7
 800523e:	bd80      	pop	{r7, pc}
 8005240:	40022000 	.word	0x40022000

08005244 <FPEC_WritePage>:
  * @param  pageNumber: number of the page where you want to write.
  * @param  data: array that contains actual data you want to write.
  * @retval Flash error.
  */
FPEC_Error_t  FPEC_WritePage(u8 pageNumber, u16* data)
{
 8005244:	b580      	push	{r7, lr}
 8005246:	b084      	sub	sp, #16
 8005248:	af00      	add	r7, sp, #0
 800524a:	4603      	mov	r3, r0
 800524c:	6039      	str	r1, [r7, #0]
 800524e:	71fb      	strb	r3, [r7, #7]
	FPEC_Error_t writeStatus = FPEC_NO_ERRORS;
 8005250:	2302      	movs	r3, #2
 8005252:	73fb      	strb	r3, [r7, #15]

	FPEC_UnlockFlash();
 8005254:	f7ff fea0 	bl	8004f98 <FPEC_UnlockFlash>

	/* To write on a page, it must be erased first */
	writeStatus = FPEC_ErasePage(pageNumber);
 8005258:	79fb      	ldrb	r3, [r7, #7]
 800525a:	4618      	mov	r0, r3
 800525c:	f7ff ffa8 	bl	80051b0 <FPEC_ErasePage>
 8005260:	4603      	mov	r3, r0
 8005262:	73fb      	strb	r3, [r7, #15]

	/* Write the data on the page by half word at a time */
	for(u16 i=0; i<PAGE_SIZE_HALF_WORDS; i++)
 8005264:	2300      	movs	r3, #0
 8005266:	81bb      	strh	r3, [r7, #12]
 8005268:	e014      	b.n	8005294 <FPEC_WritePage+0x50>
	{
		u16 offsetAddress = i * HALF_WORD_SIZE;
 800526a:	89bb      	ldrh	r3, [r7, #12]
 800526c:	005b      	lsls	r3, r3, #1
 800526e:	817b      	strh	r3, [r7, #10]
		writeStatus = FPEC_DirectWriteHalfWord(pageNumber, offsetAddress, data[i]);
 8005270:	89bb      	ldrh	r3, [r7, #12]
 8005272:	005b      	lsls	r3, r3, #1
 8005274:	683a      	ldr	r2, [r7, #0]
 8005276:	4413      	add	r3, r2
 8005278:	881a      	ldrh	r2, [r3, #0]
 800527a:	8979      	ldrh	r1, [r7, #10]
 800527c:	79fb      	ldrb	r3, [r7, #7]
 800527e:	4618      	mov	r0, r3
 8005280:	f7ff fed2 	bl	8005028 <FPEC_DirectWriteHalfWord>
 8005284:	4603      	mov	r3, r0
 8005286:	73fb      	strb	r3, [r7, #15]

		/* If there were errors while writing, don't continue writing */
		if(writeStatus != FPEC_NO_ERRORS)		break;
 8005288:	7bfb      	ldrb	r3, [r7, #15]
 800528a:	2b02      	cmp	r3, #2
 800528c:	d107      	bne.n	800529e <FPEC_WritePage+0x5a>
	for(u16 i=0; i<PAGE_SIZE_HALF_WORDS; i++)
 800528e:	89bb      	ldrh	r3, [r7, #12]
 8005290:	3301      	adds	r3, #1
 8005292:	81bb      	strh	r3, [r7, #12]
 8005294:	89bb      	ldrh	r3, [r7, #12]
 8005296:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800529a:	d3e6      	bcc.n	800526a <FPEC_WritePage+0x26>
 800529c:	e000      	b.n	80052a0 <FPEC_WritePage+0x5c>
		if(writeStatus != FPEC_NO_ERRORS)		break;
 800529e:	bf00      	nop
	}

	FPEC_LockFlash();
 80052a0:	f7ff fe8c 	bl	8004fbc <FPEC_LockFlash>

	return writeStatus;
 80052a4:	7bfb      	ldrb	r3, [r7, #15]
}
 80052a6:	4618      	mov	r0, r3
 80052a8:	3710      	adds	r7, #16
 80052aa:	46bd      	mov	sp, r7
 80052ac:	bd80      	pop	{r7, pc}

080052ae <FPEC_ReadPage>:
  * @param  pageNumber: number of the page you want to read.
  * @param  data: the function will fill this array with the data stored in the desired page.
  * @retval Flash error.
  */
void  FPEC_ReadPage(u8 pageNumber, u16* data)
{
 80052ae:	b590      	push	{r4, r7, lr}
 80052b0:	b085      	sub	sp, #20
 80052b2:	af00      	add	r7, sp, #0
 80052b4:	4603      	mov	r3, r0
 80052b6:	6039      	str	r1, [r7, #0]
 80052b8:	71fb      	strb	r3, [r7, #7]
	/* Read the whole page by reading half word at a time */
	for(u16 i=0; i<PAGE_SIZE_HALF_WORDS; i++)
 80052ba:	2300      	movs	r3, #0
 80052bc:	81fb      	strh	r3, [r7, #14]
 80052be:	e011      	b.n	80052e4 <FPEC_ReadPage+0x36>
	{
		u16 offsetAddress = i * HALF_WORD_SIZE;
 80052c0:	89fb      	ldrh	r3, [r7, #14]
 80052c2:	005b      	lsls	r3, r3, #1
 80052c4:	81bb      	strh	r3, [r7, #12]
		data[i] = FPEC_ReadHalfWord(pageNumber, offsetAddress);
 80052c6:	89fb      	ldrh	r3, [r7, #14]
 80052c8:	005b      	lsls	r3, r3, #1
 80052ca:	683a      	ldr	r2, [r7, #0]
 80052cc:	18d4      	adds	r4, r2, r3
 80052ce:	89ba      	ldrh	r2, [r7, #12]
 80052d0:	79fb      	ldrb	r3, [r7, #7]
 80052d2:	4611      	mov	r1, r2
 80052d4:	4618      	mov	r0, r3
 80052d6:	f000 f80d 	bl	80052f4 <FPEC_ReadHalfWord>
 80052da:	4603      	mov	r3, r0
 80052dc:	8023      	strh	r3, [r4, #0]
	for(u16 i=0; i<PAGE_SIZE_HALF_WORDS; i++)
 80052de:	89fb      	ldrh	r3, [r7, #14]
 80052e0:	3301      	adds	r3, #1
 80052e2:	81fb      	strh	r3, [r7, #14]
 80052e4:	89fb      	ldrh	r3, [r7, #14]
 80052e6:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 80052ea:	d3e9      	bcc.n	80052c0 <FPEC_ReadPage+0x12>
	}
}
 80052ec:	bf00      	nop
 80052ee:	3714      	adds	r7, #20
 80052f0:	46bd      	mov	sp, r7
 80052f2:	bd90      	pop	{r4, r7, pc}

080052f4 <FPEC_ReadHalfWord>:
  * @param  offsetAddress: offset address of the half word you want to read.
  * @param  data: the function will fill this array with the data stored in the desired page.
  * @retval data stored in the desired half word.
  */
u16  FPEC_ReadHalfWord(u8 pageNumber, u16 offsetAddress)
{
 80052f4:	b480      	push	{r7}
 80052f6:	b085      	sub	sp, #20
 80052f8:	af00      	add	r7, sp, #0
 80052fa:	4603      	mov	r3, r0
 80052fc:	460a      	mov	r2, r1
 80052fe:	71fb      	strb	r3, [r7, #7]
 8005300:	4613      	mov	r3, r2
 8005302:	80bb      	strh	r3, [r7, #4]
	/* Wait if the flash is busy */
	while(GET_BIT(FLASH->SR, 0) == 1) {}
 8005304:	bf00      	nop
 8005306:	4b0b      	ldr	r3, [pc, #44]	; (8005334 <FPEC_ReadHalfWord+0x40>)
 8005308:	68db      	ldr	r3, [r3, #12]
 800530a:	f003 0301 	and.w	r3, r3, #1
 800530e:	2b01      	cmp	r3, #1
 8005310:	d0f9      	beq.n	8005306 <FPEC_ReadHalfWord+0x12>

	/* Get physical address of the desired half word */
	volatile u16* physicalAddress = (volatile u16*)(FLASH_BASE_ADDRESS + pageNumber * PAGE_SIZE_BYTES + offsetAddress);
 8005312:	79fb      	ldrb	r3, [r7, #7]
 8005314:	029b      	lsls	r3, r3, #10
 8005316:	461a      	mov	r2, r3
 8005318:	88bb      	ldrh	r3, [r7, #4]
 800531a:	4413      	add	r3, r2
 800531c:	f103 6300 	add.w	r3, r3, #134217728	; 0x8000000
 8005320:	60fb      	str	r3, [r7, #12]

	/* Read data from this physical address */
	return *physicalAddress;
 8005322:	68fb      	ldr	r3, [r7, #12]
 8005324:	881b      	ldrh	r3, [r3, #0]
 8005326:	b29b      	uxth	r3, r3
}
 8005328:	4618      	mov	r0, r3
 800532a:	3714      	adds	r7, #20
 800532c:	46bd      	mov	sp, r7
 800532e:	bc80      	pop	{r7}
 8005330:	4770      	bx	lr
 8005332:	bf00      	nop
 8005334:	40022000 	.word	0x40022000

08005338 <FPEC_ReadByte>:
  * @param  pageNumber: number of the page you want to read from.
  * @param  offsetAddress: offset address of the half word you want to read.
  * @retval data stored in the desired byte.
  */
u8  FPEC_ReadByte(u8 pageNumber, u16 offsetAddress)
{
 8005338:	b580      	push	{r7, lr}
 800533a:	b082      	sub	sp, #8
 800533c:	af00      	add	r7, sp, #0
 800533e:	4603      	mov	r3, r0
 8005340:	460a      	mov	r2, r1
 8005342:	71fb      	strb	r3, [r7, #7]
 8005344:	4613      	mov	r3, r2
 8005346:	80bb      	strh	r3, [r7, #4]
	/* Wait if the flash is busy */
	while(GET_BIT(FLASH->SR, 0) == 1) {}
 8005348:	bf00      	nop
 800534a:	4b09      	ldr	r3, [pc, #36]	; (8005370 <FPEC_ReadByte+0x38>)
 800534c:	68db      	ldr	r3, [r3, #12]
 800534e:	f003 0301 	and.w	r3, r3, #1
 8005352:	2b01      	cmp	r3, #1
 8005354:	d0f9      	beq.n	800534a <FPEC_ReadByte+0x12>

	return (u8)FPEC_ReadHalfWord(pageNumber, offsetAddress);
 8005356:	88ba      	ldrh	r2, [r7, #4]
 8005358:	79fb      	ldrb	r3, [r7, #7]
 800535a:	4611      	mov	r1, r2
 800535c:	4618      	mov	r0, r3
 800535e:	f7ff ffc9 	bl	80052f4 <FPEC_ReadHalfWord>
 8005362:	4603      	mov	r3, r0
 8005364:	b2db      	uxtb	r3, r3
}
 8005366:	4618      	mov	r0, r3
 8005368:	3708      	adds	r7, #8
 800536a:	46bd      	mov	sp, r7
 800536c:	bd80      	pop	{r7, pc}
 800536e:	bf00      	nop
 8005370:	40022000 	.word	0x40022000

08005374 <FPEC_WriteByte>:
  * @param  offsetAddress: offset address of the half word you want to write.
  * @param  data: actual data you want to write.
  * @retval Flash error.
  */
FPEC_Error_t  FPEC_WriteByte(u8 pageNumber, u16 offsetAddress, u8 data)
{
 8005374:	b590      	push	{r4, r7, lr}
 8005376:	f2ad 4d14 	subw	sp, sp, #1044	; 0x414
 800537a:	af00      	add	r7, sp, #0
 800537c:	4604      	mov	r4, r0
 800537e:	4608      	mov	r0, r1
 8005380:	4611      	mov	r1, r2
 8005382:	1dfb      	adds	r3, r7, #7
 8005384:	4622      	mov	r2, r4
 8005386:	701a      	strb	r2, [r3, #0]
 8005388:	1d3b      	adds	r3, r7, #4
 800538a:	4602      	mov	r2, r0
 800538c:	801a      	strh	r2, [r3, #0]
 800538e:	1dbb      	adds	r3, r7, #6
 8005390:	460a      	mov	r2, r1
 8005392:	701a      	strb	r2, [r3, #0]
	/* Read the content of the desired page */
	u16 pageData[PAGE_SIZE_HALF_WORDS];
	FPEC_ReadPage(pageNumber, pageData);
 8005394:	f107 020c 	add.w	r2, r7, #12
 8005398:	1dfb      	adds	r3, r7, #7
 800539a:	781b      	ldrb	r3, [r3, #0]
 800539c:	4611      	mov	r1, r2
 800539e:	4618      	mov	r0, r3
 80053a0:	f7ff ff85 	bl	80052ae <FPEC_ReadPage>

	/* modify the desired byte */
	u16 originalhalfWord = pageData[offsetAddress/2];
 80053a4:	1d3b      	adds	r3, r7, #4
 80053a6:	881b      	ldrh	r3, [r3, #0]
 80053a8:	085b      	lsrs	r3, r3, #1
 80053aa:	b29b      	uxth	r3, r3
 80053ac:	461a      	mov	r2, r3
 80053ae:	f107 030c 	add.w	r3, r7, #12
 80053b2:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
 80053b6:	f8a7 340e 	strh.w	r3, [r7, #1038]	; 0x40e
	if(offsetAddress % 2 == 0)
 80053ba:	1d3b      	adds	r3, r7, #4
 80053bc:	881b      	ldrh	r3, [r3, #0]
 80053be:	f003 0301 	and.w	r3, r3, #1
 80053c2:	b29b      	uxth	r3, r3
 80053c4:	2b00      	cmp	r3, #0
 80053c6:	d10e      	bne.n	80053e6 <FPEC_WriteByte+0x72>
	{
		originalhalfWord &= 0xFF00;
 80053c8:	f8b7 340e 	ldrh.w	r3, [r7, #1038]	; 0x40e
 80053cc:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
 80053d0:	f8a7 340e 	strh.w	r3, [r7, #1038]	; 0x40e
		originalhalfWord |= data;
 80053d4:	1dbb      	adds	r3, r7, #6
 80053d6:	781b      	ldrb	r3, [r3, #0]
 80053d8:	b29a      	uxth	r2, r3
 80053da:	f8b7 340e 	ldrh.w	r3, [r7, #1038]	; 0x40e
 80053de:	4313      	orrs	r3, r2
 80053e0:	f8a7 340e 	strh.w	r3, [r7, #1038]	; 0x40e
 80053e4:	e00e      	b.n	8005404 <FPEC_WriteByte+0x90>
	}
	else
	{
		originalhalfWord &= 0x00FF;
 80053e6:	f8b7 340e 	ldrh.w	r3, [r7, #1038]	; 0x40e
 80053ea:	b2db      	uxtb	r3, r3
 80053ec:	f8a7 340e 	strh.w	r3, [r7, #1038]	; 0x40e
		originalhalfWord |= (((u16)data)<<8);
 80053f0:	1dbb      	adds	r3, r7, #6
 80053f2:	781b      	ldrb	r3, [r3, #0]
 80053f4:	021b      	lsls	r3, r3, #8
 80053f6:	b21a      	sxth	r2, r3
 80053f8:	f9b7 340e 	ldrsh.w	r3, [r7, #1038]	; 0x40e
 80053fc:	4313      	orrs	r3, r2
 80053fe:	b21b      	sxth	r3, r3
 8005400:	f8a7 340e 	strh.w	r3, [r7, #1038]	; 0x40e
	}
	pageData[offsetAddress/2] = originalhalfWord;
 8005404:	1d3b      	adds	r3, r7, #4
 8005406:	881b      	ldrh	r3, [r3, #0]
 8005408:	085b      	lsrs	r3, r3, #1
 800540a:	b29b      	uxth	r3, r3
 800540c:	4619      	mov	r1, r3
 800540e:	f107 030c 	add.w	r3, r7, #12
 8005412:	f8b7 240e 	ldrh.w	r2, [r7, #1038]	; 0x40e
 8005416:	f823 2011 	strh.w	r2, [r3, r1, lsl #1]

	/* Erase page */
	FPEC_Error_t eraseStatus = FPEC_ErasePage(pageNumber);
 800541a:	1dfb      	adds	r3, r7, #7
 800541c:	781b      	ldrb	r3, [r3, #0]
 800541e:	4618      	mov	r0, r3
 8005420:	f7ff fec6 	bl	80051b0 <FPEC_ErasePage>
 8005424:	4603      	mov	r3, r0
 8005426:	f887 340d 	strb.w	r3, [r7, #1037]	; 0x40d
	if(eraseStatus != FPEC_NO_ERRORS)
 800542a:	f897 340d 	ldrb.w	r3, [r7, #1037]	; 0x40d
 800542e:	2b02      	cmp	r3, #2
 8005430:	d002      	beq.n	8005438 <FPEC_WriteByte+0xc4>
	{
		return eraseStatus;
 8005432:	f897 340d 	ldrb.w	r3, [r7, #1037]	; 0x40d
 8005436:	e012      	b.n	800545e <FPEC_WriteByte+0xea>
	}

	/* Rewrite the page again after modifications */
	FPEC_Error_t writeStatus = FPEC_WritePage(pageNumber, pageData);
 8005438:	f107 020c 	add.w	r2, r7, #12
 800543c:	1dfb      	adds	r3, r7, #7
 800543e:	781b      	ldrb	r3, [r3, #0]
 8005440:	4611      	mov	r1, r2
 8005442:	4618      	mov	r0, r3
 8005444:	f7ff fefe 	bl	8005244 <FPEC_WritePage>
 8005448:	4603      	mov	r3, r0
 800544a:	f887 340c 	strb.w	r3, [r7, #1036]	; 0x40c
	if(writeStatus != FPEC_NO_ERRORS)
 800544e:	f897 340c 	ldrb.w	r3, [r7, #1036]	; 0x40c
 8005452:	2b02      	cmp	r3, #2
 8005454:	d002      	beq.n	800545c <FPEC_WriteByte+0xe8>
	{
		return writeStatus;
 8005456:	f897 340c 	ldrb.w	r3, [r7, #1036]	; 0x40c
 800545a:	e000      	b.n	800545e <FPEC_WriteByte+0xea>
	}

	return FPEC_NO_ERRORS;
 800545c:	2302      	movs	r3, #2
}
 800545e:	4618      	mov	r0, r3
 8005460:	f207 4714 	addw	r7, r7, #1044	; 0x414
 8005464:	46bd      	mov	sp, r7
 8005466:	bd90      	pop	{r4, r7, pc}

08005468 <GPIO_InitPin>:




static void  GPIO_InitPin(GPIO_Pin_t* pin, const GPIO_PinConfg_t* pinConfg)
{
 8005468:	b590      	push	{r4, r7, lr}
 800546a:	b083      	sub	sp, #12
 800546c:	af00      	add	r7, sp, #0
 800546e:	6078      	str	r0, [r7, #4]
 8005470:	6039      	str	r1, [r7, #0]
	if(pin->pinNumber < 8)
 8005472:	687b      	ldr	r3, [r7, #4]
 8005474:	885b      	ldrh	r3, [r3, #2]
 8005476:	2b07      	cmp	r3, #7
 8005478:	d813      	bhi.n	80054a2 <GPIO_InitPin+0x3a>
	{
		GPIO[pin->port]->CRL = GPIO_GetNewValueOfCR(pin, pinConfg, GPIO[pin->port]->CRL);
 800547a:	687b      	ldr	r3, [r7, #4]
 800547c:	781b      	ldrb	r3, [r3, #0]
 800547e:	461a      	mov	r2, r3
 8005480:	4b2d      	ldr	r3, [pc, #180]	; (8005538 <GPIO_InitPin+0xd0>)
 8005482:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8005486:	681a      	ldr	r2, [r3, #0]
 8005488:	687b      	ldr	r3, [r7, #4]
 800548a:	781b      	ldrb	r3, [r3, #0]
 800548c:	4619      	mov	r1, r3
 800548e:	4b2a      	ldr	r3, [pc, #168]	; (8005538 <GPIO_InitPin+0xd0>)
 8005490:	f853 4021 	ldr.w	r4, [r3, r1, lsl #2]
 8005494:	6839      	ldr	r1, [r7, #0]
 8005496:	6878      	ldr	r0, [r7, #4]
 8005498:	f000 f850 	bl	800553c <GPIO_GetNewValueOfCR>
 800549c:	4603      	mov	r3, r0
 800549e:	6023      	str	r3, [r4, #0]
 80054a0:	e022      	b.n	80054e8 <GPIO_InitPin+0x80>
	}
	else if(pin->pinNumber < 16)
 80054a2:	687b      	ldr	r3, [r7, #4]
 80054a4:	885b      	ldrh	r3, [r3, #2]
 80054a6:	2b0f      	cmp	r3, #15
 80054a8:	d81e      	bhi.n	80054e8 <GPIO_InitPin+0x80>
	{
		pin->pinNumber -= 8;
 80054aa:	687b      	ldr	r3, [r7, #4]
 80054ac:	885b      	ldrh	r3, [r3, #2]
 80054ae:	3b08      	subs	r3, #8
 80054b0:	b29a      	uxth	r2, r3
 80054b2:	687b      	ldr	r3, [r7, #4]
 80054b4:	805a      	strh	r2, [r3, #2]
		GPIO[pin->port]->CRH = GPIO_GetNewValueOfCR(pin, pinConfg, GPIO[pin->port]->CRH);
 80054b6:	687b      	ldr	r3, [r7, #4]
 80054b8:	781b      	ldrb	r3, [r3, #0]
 80054ba:	461a      	mov	r2, r3
 80054bc:	4b1e      	ldr	r3, [pc, #120]	; (8005538 <GPIO_InitPin+0xd0>)
 80054be:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80054c2:	685a      	ldr	r2, [r3, #4]
 80054c4:	687b      	ldr	r3, [r7, #4]
 80054c6:	781b      	ldrb	r3, [r3, #0]
 80054c8:	4619      	mov	r1, r3
 80054ca:	4b1b      	ldr	r3, [pc, #108]	; (8005538 <GPIO_InitPin+0xd0>)
 80054cc:	f853 4021 	ldr.w	r4, [r3, r1, lsl #2]
 80054d0:	6839      	ldr	r1, [r7, #0]
 80054d2:	6878      	ldr	r0, [r7, #4]
 80054d4:	f000 f832 	bl	800553c <GPIO_GetNewValueOfCR>
 80054d8:	4603      	mov	r3, r0
 80054da:	6063      	str	r3, [r4, #4]
		pin->pinNumber += 8;
 80054dc:	687b      	ldr	r3, [r7, #4]
 80054de:	885b      	ldrh	r3, [r3, #2]
 80054e0:	3308      	adds	r3, #8
 80054e2:	b29a      	uxth	r2, r3
 80054e4:	687b      	ldr	r3, [r7, #4]
 80054e6:	805a      	strh	r2, [r3, #2]
	}

	switch(pinConfg->pinMode)
 80054e8:	683b      	ldr	r3, [r7, #0]
 80054ea:	781b      	ldrb	r3, [r3, #0]
 80054ec:	2b02      	cmp	r3, #2
 80054ee:	d002      	beq.n	80054f6 <GPIO_InitPin+0x8e>
 80054f0:	2b03      	cmp	r3, #3
 80054f2:	d00e      	beq.n	8005512 <GPIO_InitPin+0xaa>
			break;
		case INPUT_PULL_DOWN:
			GPIO[pin->port]->BRR  = 1<<(pin->pinNumber);
			break;
		default:
			break;
 80054f4:	e01b      	b.n	800552e <GPIO_InitPin+0xc6>
			GPIO[pin->port]->BSRR = 1<<(pin->pinNumber);
 80054f6:	687b      	ldr	r3, [r7, #4]
 80054f8:	885b      	ldrh	r3, [r3, #2]
 80054fa:	461a      	mov	r2, r3
 80054fc:	2301      	movs	r3, #1
 80054fe:	fa03 f202 	lsl.w	r2, r3, r2
 8005502:	687b      	ldr	r3, [r7, #4]
 8005504:	781b      	ldrb	r3, [r3, #0]
 8005506:	4619      	mov	r1, r3
 8005508:	4b0b      	ldr	r3, [pc, #44]	; (8005538 <GPIO_InitPin+0xd0>)
 800550a:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 800550e:	611a      	str	r2, [r3, #16]
			break;
 8005510:	e00d      	b.n	800552e <GPIO_InitPin+0xc6>
			GPIO[pin->port]->BRR  = 1<<(pin->pinNumber);
 8005512:	687b      	ldr	r3, [r7, #4]
 8005514:	885b      	ldrh	r3, [r3, #2]
 8005516:	461a      	mov	r2, r3
 8005518:	2301      	movs	r3, #1
 800551a:	fa03 f202 	lsl.w	r2, r3, r2
 800551e:	687b      	ldr	r3, [r7, #4]
 8005520:	781b      	ldrb	r3, [r3, #0]
 8005522:	4619      	mov	r1, r3
 8005524:	4b04      	ldr	r3, [pc, #16]	; (8005538 <GPIO_InitPin+0xd0>)
 8005526:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 800552a:	615a      	str	r2, [r3, #20]
			break;
 800552c:	bf00      	nop
	}
}
 800552e:	bf00      	nop
 8005530:	370c      	adds	r7, #12
 8005532:	46bd      	mov	sp, r7
 8005534:	bd90      	pop	{r4, r7, pc}
 8005536:	bf00      	nop
 8005538:	20000000 	.word	0x20000000

0800553c <GPIO_GetNewValueOfCR>:




static u32   GPIO_GetNewValueOfCR(GPIO_Pin_t* pin, const GPIO_PinConfg_t* pinConfg, u32 oldValueOfCR)
{
 800553c:	b480      	push	{r7}
 800553e:	b087      	sub	sp, #28
 8005540:	af00      	add	r7, sp, #0
 8005542:	60f8      	str	r0, [r7, #12]
 8005544:	60b9      	str	r1, [r7, #8]
 8005546:	607a      	str	r2, [r7, #4]
	u32 CRValue = oldValueOfCR;
 8005548:	687b      	ldr	r3, [r7, #4]
 800554a:	617b      	str	r3, [r7, #20]

	/* Clear corresponding two MODE bits and two CNF bits */
	CRValue &= ~(0xFUL<<(4*(pin->pinNumber))) ;
 800554c:	68fb      	ldr	r3, [r7, #12]
 800554e:	885b      	ldrh	r3, [r3, #2]
 8005550:	009b      	lsls	r3, r3, #2
 8005552:	220f      	movs	r2, #15
 8005554:	fa02 f303 	lsl.w	r3, r2, r3
 8005558:	43db      	mvns	r3, r3
 800555a:	697a      	ldr	r2, [r7, #20]
 800555c:	4013      	ands	r3, r2
 800555e:	617b      	str	r3, [r7, #20]


	switch (pinConfg->pinMode)
 8005560:	68bb      	ldr	r3, [r7, #8]
 8005562:	781b      	ldrb	r3, [r3, #0]
 8005564:	2b07      	cmp	r3, #7
 8005566:	d833      	bhi.n	80055d0 <GPIO_GetNewValueOfCR+0x94>
 8005568:	a201      	add	r2, pc, #4	; (adr r2, 8005570 <GPIO_GetNewValueOfCR+0x34>)
 800556a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800556e:	bf00      	nop
 8005570:	080055d1 	.word	0x080055d1
 8005574:	08005591 	.word	0x08005591
 8005578:	080055bb 	.word	0x080055bb
 800557c:	080055bb 	.word	0x080055bb
 8005580:	08005591 	.word	0x08005591
 8005584:	080055d1 	.word	0x080055d1
 8005588:	080055bb 	.word	0x080055bb
 800558c:	080055a7 	.word	0x080055a7
			/* Nothing to do here */
			break;

		case INPUT_FLOATING:
		case GENERAL_PURPOSE_OUTPUT_OPEN_DRAIN:
			SET_BIT(CRValue, 4*(pin->pinNumber)+2);
 8005590:	68fb      	ldr	r3, [r7, #12]
 8005592:	885b      	ldrh	r3, [r3, #2]
 8005594:	009b      	lsls	r3, r3, #2
 8005596:	3302      	adds	r3, #2
 8005598:	2201      	movs	r2, #1
 800559a:	fa02 f303 	lsl.w	r3, r2, r3
 800559e:	697a      	ldr	r2, [r7, #20]
 80055a0:	4313      	orrs	r3, r2
 80055a2:	617b      	str	r3, [r7, #20]
			break;
 80055a4:	e015      	b.n	80055d2 <GPIO_GetNewValueOfCR+0x96>

		case ALTERNATE_FUNCTION_OUTPUT_OPEN_DRAIN:
			SET_BIT(CRValue, 4*(pin->pinNumber)+2);
 80055a6:	68fb      	ldr	r3, [r7, #12]
 80055a8:	885b      	ldrh	r3, [r3, #2]
 80055aa:	009b      	lsls	r3, r3, #2
 80055ac:	3302      	adds	r3, #2
 80055ae:	2201      	movs	r2, #1
 80055b0:	fa02 f303 	lsl.w	r3, r2, r3
 80055b4:	697a      	ldr	r2, [r7, #20]
 80055b6:	4313      	orrs	r3, r2
 80055b8:	617b      	str	r3, [r7, #20]

		case INPUT_PULL_UP:
		case INPUT_PULL_DOWN:
		case ALTERNATE_FUNCTION_OUTPUT_PUSH_PULL:
			SET_BIT(CRValue, 4*(pin->pinNumber)+3);
 80055ba:	68fb      	ldr	r3, [r7, #12]
 80055bc:	885b      	ldrh	r3, [r3, #2]
 80055be:	009b      	lsls	r3, r3, #2
 80055c0:	3303      	adds	r3, #3
 80055c2:	2201      	movs	r2, #1
 80055c4:	fa02 f303 	lsl.w	r3, r2, r3
 80055c8:	697a      	ldr	r2, [r7, #20]
 80055ca:	4313      	orrs	r3, r2
 80055cc:	617b      	str	r3, [r7, #20]
			break;
 80055ce:	e000      	b.n	80055d2 <GPIO_GetNewValueOfCR+0x96>

		default:
			break;
 80055d0:	bf00      	nop
	}

	switch(pinConfg->pinMode)
 80055d2:	68bb      	ldr	r3, [r7, #8]
 80055d4:	781b      	ldrb	r3, [r3, #0]
 80055d6:	3b04      	subs	r3, #4
 80055d8:	2b03      	cmp	r3, #3
 80055da:	d827      	bhi.n	800562c <GPIO_GetNewValueOfCR+0xf0>
	{
		case GENERAL_PURPOSE_OUTPUT_OPEN_DRAIN ... ALTERNATE_FUNCTION_OUTPUT_OPEN_DRAIN:
			switch (pinConfg->outputSpeed)
 80055dc:	68bb      	ldr	r3, [r7, #8]
 80055de:	785b      	ldrb	r3, [r3, #1]
 80055e0:	2b01      	cmp	r3, #1
 80055e2:	d017      	beq.n	8005614 <GPIO_GetNewValueOfCR+0xd8>
 80055e4:	2b02      	cmp	r3, #2
 80055e6:	d00c      	beq.n	8005602 <GPIO_GetNewValueOfCR+0xc6>
 80055e8:	2b00      	cmp	r3, #0
 80055ea:	d000      	beq.n	80055ee <GPIO_GetNewValueOfCR+0xb2>
				case OUTPUT_SPEED_2MHz:
					SET_BIT(CRValue, 4*(pin->pinNumber)+1);
					break;

				default:
					break;
 80055ec:	e01d      	b.n	800562a <GPIO_GetNewValueOfCR+0xee>
					SET_BIT(CRValue, 4*(pin->pinNumber));
 80055ee:	68fb      	ldr	r3, [r7, #12]
 80055f0:	885b      	ldrh	r3, [r3, #2]
 80055f2:	009b      	lsls	r3, r3, #2
 80055f4:	2201      	movs	r2, #1
 80055f6:	fa02 f303 	lsl.w	r3, r2, r3
 80055fa:	697a      	ldr	r2, [r7, #20]
 80055fc:	4313      	orrs	r3, r2
 80055fe:	617b      	str	r3, [r7, #20]
					break;
 8005600:	e013      	b.n	800562a <GPIO_GetNewValueOfCR+0xee>
					SET_BIT(CRValue, 4*(pin->pinNumber));
 8005602:	68fb      	ldr	r3, [r7, #12]
 8005604:	885b      	ldrh	r3, [r3, #2]
 8005606:	009b      	lsls	r3, r3, #2
 8005608:	2201      	movs	r2, #1
 800560a:	fa02 f303 	lsl.w	r3, r2, r3
 800560e:	697a      	ldr	r2, [r7, #20]
 8005610:	4313      	orrs	r3, r2
 8005612:	617b      	str	r3, [r7, #20]
					SET_BIT(CRValue, 4*(pin->pinNumber)+1);
 8005614:	68fb      	ldr	r3, [r7, #12]
 8005616:	885b      	ldrh	r3, [r3, #2]
 8005618:	009b      	lsls	r3, r3, #2
 800561a:	3301      	adds	r3, #1
 800561c:	2201      	movs	r2, #1
 800561e:	fa02 f303 	lsl.w	r3, r2, r3
 8005622:	697a      	ldr	r2, [r7, #20]
 8005624:	4313      	orrs	r3, r2
 8005626:	617b      	str	r3, [r7, #20]
					break;
 8005628:	bf00      	nop
			}
			break;
 800562a:	e000      	b.n	800562e <GPIO_GetNewValueOfCR+0xf2>

		default:
			break;
 800562c:	bf00      	nop
	}

	return CRValue;
 800562e:	697b      	ldr	r3, [r7, #20]
}
 8005630:	4618      	mov	r0, r3
 8005632:	371c      	adds	r7, #28
 8005634:	46bd      	mov	sp, r7
 8005636:	bc80      	pop	{r7}
 8005638:	4770      	bx	lr
 800563a:	bf00      	nop

0800563c <GPIO_InitPins>:




void  GPIO_InitPins(const GPIO_Pin_t* groupOfPins, const GPIO_PinConfg_t* pinConfg)
{
 800563c:	b580      	push	{r7, lr}
 800563e:	b084      	sub	sp, #16
 8005640:	af00      	add	r7, sp, #0
 8005642:	6078      	str	r0, [r7, #4]
 8005644:	6039      	str	r1, [r7, #0]
	GPIO_Pin_t pin;
	pin.port = groupOfPins->port;
 8005646:	687b      	ldr	r3, [r7, #4]
 8005648:	781b      	ldrb	r3, [r3, #0]
 800564a:	723b      	strb	r3, [r7, #8]

	switch(pin.port)
 800564c:	7a3b      	ldrb	r3, [r7, #8]
 800564e:	2b01      	cmp	r3, #1
 8005650:	d007      	beq.n	8005662 <GPIO_InitPins+0x26>
 8005652:	2b02      	cmp	r3, #2
 8005654:	d009      	beq.n	800566a <GPIO_InitPins+0x2e>
 8005656:	2b00      	cmp	r3, #0
 8005658:	d10b      	bne.n	8005672 <GPIO_InitPins+0x36>
	{
		case GPIO_PORTA:
			RCC_EnablePeripheralClock(GPIOA_PERIPHERAL);
 800565a:	2042      	movs	r0, #66	; 0x42
 800565c:	f000 f8ea 	bl	8005834 <RCC_EnablePeripheralClock>
			break;
 8005660:	e007      	b.n	8005672 <GPIO_InitPins+0x36>

		case GPIO_PORTB:
			RCC_EnablePeripheralClock(GPIOB_PERIPHERAL);
 8005662:	2043      	movs	r0, #67	; 0x43
 8005664:	f000 f8e6 	bl	8005834 <RCC_EnablePeripheralClock>
			break;
 8005668:	e003      	b.n	8005672 <GPIO_InitPins+0x36>

		case GPIO_PORTC:
			RCC_EnablePeripheralClock(GPIOC_PERIPHERAL);
 800566a:	2044      	movs	r0, #68	; 0x44
 800566c:	f000 f8e2 	bl	8005834 <RCC_EnablePeripheralClock>
			break;
 8005670:	bf00      	nop
	}


	for(u8 pinNumCounter = 0; pinNumCounter < 16; pinNumCounter++)
 8005672:	2300      	movs	r3, #0
 8005674:	73fb      	strb	r3, [r7, #15]
 8005676:	e015      	b.n	80056a4 <GPIO_InitPins+0x68>
	{
		if(GET_BIT(groupOfPins->pinNumber, pinNumCounter) == 0)
 8005678:	687b      	ldr	r3, [r7, #4]
 800567a:	885b      	ldrh	r3, [r3, #2]
 800567c:	461a      	mov	r2, r3
 800567e:	7bfb      	ldrb	r3, [r7, #15]
 8005680:	fa42 f303 	asr.w	r3, r2, r3
 8005684:	f003 0301 	and.w	r3, r3, #1
 8005688:	2b00      	cmp	r3, #0
 800568a:	d108      	bne.n	800569e <GPIO_InitPins+0x62>
		{
			pin.pinNumber = pinNumCounter;
 800568c:	7bfb      	ldrb	r3, [r7, #15]
 800568e:	b29b      	uxth	r3, r3
 8005690:	817b      	strh	r3, [r7, #10]
			GPIO_InitPin(&pin, pinConfg);
 8005692:	f107 0308 	add.w	r3, r7, #8
 8005696:	6839      	ldr	r1, [r7, #0]
 8005698:	4618      	mov	r0, r3
 800569a:	f7ff fee5 	bl	8005468 <GPIO_InitPin>
	for(u8 pinNumCounter = 0; pinNumCounter < 16; pinNumCounter++)
 800569e:	7bfb      	ldrb	r3, [r7, #15]
 80056a0:	3301      	adds	r3, #1
 80056a2:	73fb      	strb	r3, [r7, #15]
 80056a4:	7bfb      	ldrb	r3, [r7, #15]
 80056a6:	2b0f      	cmp	r3, #15
 80056a8:	d9e6      	bls.n	8005678 <GPIO_InitPins+0x3c>
		}
	}
}
 80056aa:	bf00      	nop
 80056ac:	3710      	adds	r7, #16
 80056ae:	46bd      	mov	sp, r7
 80056b0:	bd80      	pop	{r7, pc}
	...

080056b4 <NVIC_EnableInterrupt>:

#include  "NVIC.h"


void  NVIC_EnableInterrupt(IRQn_Type IRQnID)
{
 80056b4:	b480      	push	{r7}
 80056b6:	b083      	sub	sp, #12
 80056b8:	af00      	add	r7, sp, #0
 80056ba:	4603      	mov	r3, r0
 80056bc:	71fb      	strb	r3, [r7, #7]
	if(IRQnID >= 0)   //if IRQnID is an ID of Peripheral Interrupt not system exception
 80056be:	f997 3007 	ldrsb.w	r3, [r7, #7]
 80056c2:	2b00      	cmp	r3, #0
 80056c4:	db0d      	blt.n	80056e2 <NVIC_EnableInterrupt+0x2e>
	{
		NVIC->ISER[IRQnID>>5] = 1<<(IRQnID & 0x1F);
 80056c6:	79fb      	ldrb	r3, [r7, #7]
 80056c8:	f003 031f 	and.w	r3, r3, #31
 80056cc:	2201      	movs	r2, #1
 80056ce:	fa02 f103 	lsl.w	r1, r2, r3
 80056d2:	4a13      	ldr	r2, [pc, #76]	; (8005720 <NVIC_EnableInterrupt+0x6c>)
 80056d4:	f997 3007 	ldrsb.w	r3, [r7, #7]
 80056d8:	115b      	asrs	r3, r3, #5
 80056da:	b25b      	sxtb	r3, r3
 80056dc:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
	}
	else if(IRQnID == MemoryManagement_IRQn || IRQnID == BusFault_IRQn || IRQnID == UsageFault_IRQn)
	{
		SET_BIT(SCB->SHCSR, IRQnID + 28);
	}
}
 80056e0:	e019      	b.n	8005716 <NVIC_EnableInterrupt+0x62>
	else if(IRQnID == MemoryManagement_IRQn || IRQnID == BusFault_IRQn || IRQnID == UsageFault_IRQn)
 80056e2:	f997 3007 	ldrsb.w	r3, [r7, #7]
 80056e6:	f113 0f0c 	cmn.w	r3, #12
 80056ea:	d009      	beq.n	8005700 <NVIC_EnableInterrupt+0x4c>
 80056ec:	f997 3007 	ldrsb.w	r3, [r7, #7]
 80056f0:	f113 0f0b 	cmn.w	r3, #11
 80056f4:	d004      	beq.n	8005700 <NVIC_EnableInterrupt+0x4c>
 80056f6:	f997 3007 	ldrsb.w	r3, [r7, #7]
 80056fa:	f113 0f0a 	cmn.w	r3, #10
 80056fe:	d10a      	bne.n	8005716 <NVIC_EnableInterrupt+0x62>
		SET_BIT(SCB->SHCSR, IRQnID + 28);
 8005700:	4b08      	ldr	r3, [pc, #32]	; (8005724 <NVIC_EnableInterrupt+0x70>)
 8005702:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8005704:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8005708:	331c      	adds	r3, #28
 800570a:	2101      	movs	r1, #1
 800570c:	fa01 f303 	lsl.w	r3, r1, r3
 8005710:	4904      	ldr	r1, [pc, #16]	; (8005724 <NVIC_EnableInterrupt+0x70>)
 8005712:	4313      	orrs	r3, r2
 8005714:	624b      	str	r3, [r1, #36]	; 0x24
}
 8005716:	bf00      	nop
 8005718:	370c      	adds	r7, #12
 800571a:	46bd      	mov	sp, r7
 800571c:	bc80      	pop	{r7}
 800571e:	4770      	bx	lr
 8005720:	e000e100 	.word	0xe000e100
 8005724:	e000ed00 	.word	0xe000ed00

08005728 <NVIC_ResetSystem>:




void  NVIC_ResetSystem(void)
{
 8005728:	b480      	push	{r7}
 800572a:	af00      	add	r7, sp, #0
	SCB->AIRCR = 0x05FA0004;
 800572c:	4b03      	ldr	r3, [pc, #12]	; (800573c <NVIC_ResetSystem+0x14>)
 800572e:	4a04      	ldr	r2, [pc, #16]	; (8005740 <NVIC_ResetSystem+0x18>)
 8005730:	60da      	str	r2, [r3, #12]
}
 8005732:	bf00      	nop
 8005734:	46bd      	mov	sp, r7
 8005736:	bc80      	pop	{r7}
 8005738:	4770      	bx	lr
 800573a:	bf00      	nop
 800573c:	e000ed00 	.word	0xe000ed00
 8005740:	05fa0004 	.word	0x05fa0004

08005744 <NVIC_MaskIRQs>:
	}
}


void  NVIC_MaskIRQs(u8 thresholdPriority)
{
 8005744:	b480      	push	{r7}
 8005746:	b085      	sub	sp, #20
 8005748:	af00      	add	r7, sp, #0
 800574a:	4603      	mov	r3, r0
 800574c:	71fb      	strb	r3, [r7, #7]
	__set_BASEPRI(thresholdPriority);
 800574e:	79fb      	ldrb	r3, [r7, #7]
 8005750:	60bb      	str	r3, [r7, #8]
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__STATIC_FORCEINLINE void __set_BASEPRI(uint32_t basePri)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8005752:	68bb      	ldr	r3, [r7, #8]
 8005754:	f383 8811 	msr	BASEPRI, r3
 8005758:	2301      	movs	r3, #1
 800575a:	60fb      	str	r3, [r7, #12]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800575c:	68fb      	ldr	r3, [r7, #12]
 800575e:	f383 8810 	msr	PRIMASK, r3
	__set_PRIMASK(1);
}
 8005762:	bf00      	nop
 8005764:	3714      	adds	r7, #20
 8005766:	46bd      	mov	sp, r7
 8005768:	bc80      	pop	{r7}
 800576a:	4770      	bx	lr

0800576c <NVIC_UnMaskIRQs>:

void  NVIC_UnMaskIRQs(void)
{
 800576c:	b480      	push	{r7}
 800576e:	b083      	sub	sp, #12
 8005770:	af00      	add	r7, sp, #0
 8005772:	2300      	movs	r3, #0
 8005774:	607b      	str	r3, [r7, #4]
 8005776:	687b      	ldr	r3, [r7, #4]
 8005778:	f383 8810 	msr	PRIMASK, r3
	__set_PRIMASK(0);
}
 800577c:	bf00      	nop
 800577e:	370c      	adds	r7, #12
 8005780:	46bd      	mov	sp, r7
 8005782:	bc80      	pop	{r7}
 8005784:	4770      	bx	lr
	...

08005788 <RCC_InitClock>:
#include "RCC.h"

void  RCC_InitClock(void)
{
 8005788:	b580      	push	{r7, lr}
 800578a:	af00      	add	r7, sp, #0
	RCC->CR = 0x1;   //enable HSI
 800578c:	4b28      	ldr	r3, [pc, #160]	; (8005830 <RCC_InitClock+0xa8>)
 800578e:	2201      	movs	r2, #1
 8005790:	601a      	str	r2, [r3, #0]
	RCC->CFGR = 0;   //select HSI as system clock
 8005792:	4b27      	ldr	r3, [pc, #156]	; (8005830 <RCC_InitClock+0xa8>)
 8005794:	2200      	movs	r2, #0
 8005796:	605a      	str	r2, [r3, #4]
	RCC->CIR  = 0x9F0000;   //disable all RCC interrupts , clear all flags
 8005798:	4b25      	ldr	r3, [pc, #148]	; (8005830 <RCC_InitClock+0xa8>)
 800579a:	f44f 021f 	mov.w	r2, #10420224	; 0x9f0000
 800579e:	609a      	str	r2, [r3, #8]
	
	RCC_EnablePeripheralClock(FLITF_PERIPHERAL);
 80057a0:	2004      	movs	r0, #4
 80057a2:	f000 f847 	bl	8005834 <RCC_EnablePeripheralClock>
	FPEC_InitFlash();
 80057a6:	f7ff fce3 	bl	8005170 <FPEC_InitFlash>
	
	
	#if  APB1_DIVISION_FACTOR == 1
		/* do nothing, AHB division factor is already 1 */
	#elif  APB1_DIVISION_FACTOR == 2
		RCC->CFGR |= 0x400;
 80057aa:	4b21      	ldr	r3, [pc, #132]	; (8005830 <RCC_InitClock+0xa8>)
 80057ac:	685b      	ldr	r3, [r3, #4]
 80057ae:	4a20      	ldr	r2, [pc, #128]	; (8005830 <RCC_InitClock+0xa8>)
 80057b0:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 80057b4:	6053      	str	r3, [r2, #4]
	#endif
	
	

	#if  CLK_SECURITY_SYSTEM_STATE == ENABLED
		SET_BIT(RCC->CR, 19);
 80057b6:	4b1e      	ldr	r3, [pc, #120]	; (8005830 <RCC_InitClock+0xa8>)
 80057b8:	681b      	ldr	r3, [r3, #0]
 80057ba:	4a1d      	ldr	r2, [pc, #116]	; (8005830 <RCC_InitClock+0xa8>)
 80057bc:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 80057c0:	6013      	str	r3, [r2, #0]
	#if  HSE_STATE == ENABLED
		#if  HSE_SRC == HSE_RC
			SET_BIT(RCC->CR, 18);  //select RC as HSE
		#endif
		
		SET_BIT(RCC->CR, 16);   //enable HSE
 80057c2:	4b1b      	ldr	r3, [pc, #108]	; (8005830 <RCC_InitClock+0xa8>)
 80057c4:	681b      	ldr	r3, [r3, #0]
 80057c6:	4a1a      	ldr	r2, [pc, #104]	; (8005830 <RCC_InitClock+0xa8>)
 80057c8:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80057cc:	6013      	str	r3, [r2, #0]
		while(GET_BIT(RCC->CR, 17) == 0);   //wait until HSE is ready
 80057ce:	bf00      	nop
 80057d0:	4b17      	ldr	r3, [pc, #92]	; (8005830 <RCC_InitClock+0xa8>)
 80057d2:	681b      	ldr	r3, [r3, #0]
 80057d4:	0c5b      	lsrs	r3, r3, #17
 80057d6:	f003 0301 	and.w	r3, r3, #1
 80057da:	2b00      	cmp	r3, #0
 80057dc:	d0f8      	beq.n	80057d0 <RCC_InitClock+0x48>
	
	
	
	#if  PLL_STATE == ENABLED
		#if  PLL_SRC == HSE
			SET_BIT(RCC->CFGR, 16);   //select HSE as PLL input clock 
 80057de:	4b14      	ldr	r3, [pc, #80]	; (8005830 <RCC_InitClock+0xa8>)
 80057e0:	685b      	ldr	r3, [r3, #4]
 80057e2:	4a13      	ldr	r2, [pc, #76]	; (8005830 <RCC_InitClock+0xa8>)
 80057e4:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80057e8:	6053      	str	r3, [r2, #4]
			SET_BIT(RCC->CFGR, 16);   //select HSE/2 as PLL input clock 
		#elif  PLL_SRC == HSI_DIVIDED_BY_2
			/* do nothing, HSI/2 is already selected as PLL input clock */
		#endif
		
		RCC->CFGR |= ((PLL_FACTOR-2)<<18);   //select PLL multiplication factor
 80057ea:	4b11      	ldr	r3, [pc, #68]	; (8005830 <RCC_InitClock+0xa8>)
 80057ec:	685b      	ldr	r3, [r3, #4]
 80057ee:	4a10      	ldr	r2, [pc, #64]	; (8005830 <RCC_InitClock+0xa8>)
 80057f0:	f443 13e0 	orr.w	r3, r3, #1835008	; 0x1c0000
 80057f4:	6053      	str	r3, [r2, #4]
		SET_BIT(RCC->CR, 24);                //enable PLL
 80057f6:	4b0e      	ldr	r3, [pc, #56]	; (8005830 <RCC_InitClock+0xa8>)
 80057f8:	681b      	ldr	r3, [r3, #0]
 80057fa:	4a0d      	ldr	r2, [pc, #52]	; (8005830 <RCC_InitClock+0xa8>)
 80057fc:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8005800:	6013      	str	r3, [r2, #0]
		while(GET_BIT(RCC->CR, 25) == 0);    //wait until PLL is ready
 8005802:	bf00      	nop
 8005804:	4b0a      	ldr	r3, [pc, #40]	; (8005830 <RCC_InitClock+0xa8>)
 8005806:	681b      	ldr	r3, [r3, #0]
 8005808:	0e5b      	lsrs	r3, r3, #25
 800580a:	f003 0301 	and.w	r3, r3, #1
 800580e:	2b00      	cmp	r3, #0
 8005810:	d0f8      	beq.n	8005804 <RCC_InitClock+0x7c>
		
		#if  CLK_TYPE == PLL
			SET_BIT(RCC->CFGR, 1);   //select PLL as system clock
 8005812:	4b07      	ldr	r3, [pc, #28]	; (8005830 <RCC_InitClock+0xa8>)
 8005814:	685b      	ldr	r3, [r3, #4]
 8005816:	4a06      	ldr	r2, [pc, #24]	; (8005830 <RCC_InitClock+0xa8>)
 8005818:	f043 0302 	orr.w	r3, r3, #2
 800581c:	6053      	str	r3, [r2, #4]
			while( (RCC->CFGR & 0xC) != 0x8);   //wait until PLL is used as system clock
 800581e:	bf00      	nop
 8005820:	4b03      	ldr	r3, [pc, #12]	; (8005830 <RCC_InitClock+0xa8>)
 8005822:	685b      	ldr	r3, [r3, #4]
 8005824:	f003 030c 	and.w	r3, r3, #12
 8005828:	2b08      	cmp	r3, #8
 800582a:	d1f9      	bne.n	8005820 <RCC_InitClock+0x98>
	
	#if  HSI_STATE == DISABLED
		CLR_BIT(RCC->CR, 0);
	#endif
	
}
 800582c:	bf00      	nop
 800582e:	bd80      	pop	{r7, pc}
 8005830:	40021000 	.word	0x40021000

08005834 <RCC_EnablePeripheralClock>:


void  RCC_EnablePeripheralClock (uint8_t peripheral)
{
 8005834:	b480      	push	{r7}
 8005836:	b083      	sub	sp, #12
 8005838:	af00      	add	r7, sp, #0
 800583a:	4603      	mov	r3, r0
 800583c:	71fb      	strb	r3, [r7, #7]
	if(peripheral < 32)    //if peripheral is connected to AHB
 800583e:	79fb      	ldrb	r3, [r7, #7]
 8005840:	2b1f      	cmp	r3, #31
 8005842:	d809      	bhi.n	8005858 <RCC_EnablePeripheralClock+0x24>
	{
		SET_BIT(RCC->AHBENR, peripheral);
 8005844:	4b14      	ldr	r3, [pc, #80]	; (8005898 <RCC_EnablePeripheralClock+0x64>)
 8005846:	695a      	ldr	r2, [r3, #20]
 8005848:	79fb      	ldrb	r3, [r7, #7]
 800584a:	2101      	movs	r1, #1
 800584c:	fa01 f303 	lsl.w	r3, r1, r3
 8005850:	4911      	ldr	r1, [pc, #68]	; (8005898 <RCC_EnablePeripheralClock+0x64>)
 8005852:	4313      	orrs	r3, r2
 8005854:	614b      	str	r3, [r1, #20]
	}
	else if(peripheral < 96)    //if peripheral is connected to APB2
	{
		SET_BIT(RCC->APB2ENR, peripheral-64);
	}
}
 8005856:	e01a      	b.n	800588e <RCC_EnablePeripheralClock+0x5a>
	else if(peripheral < 64)    //if peripheral is connected to APB1
 8005858:	79fb      	ldrb	r3, [r7, #7]
 800585a:	2b3f      	cmp	r3, #63	; 0x3f
 800585c:	d80a      	bhi.n	8005874 <RCC_EnablePeripheralClock+0x40>
		SET_BIT(RCC->APB1ENR, peripheral-32);
 800585e:	4b0e      	ldr	r3, [pc, #56]	; (8005898 <RCC_EnablePeripheralClock+0x64>)
 8005860:	69da      	ldr	r2, [r3, #28]
 8005862:	79fb      	ldrb	r3, [r7, #7]
 8005864:	3b20      	subs	r3, #32
 8005866:	2101      	movs	r1, #1
 8005868:	fa01 f303 	lsl.w	r3, r1, r3
 800586c:	490a      	ldr	r1, [pc, #40]	; (8005898 <RCC_EnablePeripheralClock+0x64>)
 800586e:	4313      	orrs	r3, r2
 8005870:	61cb      	str	r3, [r1, #28]
}
 8005872:	e00c      	b.n	800588e <RCC_EnablePeripheralClock+0x5a>
	else if(peripheral < 96)    //if peripheral is connected to APB2
 8005874:	79fb      	ldrb	r3, [r7, #7]
 8005876:	2b5f      	cmp	r3, #95	; 0x5f
 8005878:	d809      	bhi.n	800588e <RCC_EnablePeripheralClock+0x5a>
		SET_BIT(RCC->APB2ENR, peripheral-64);
 800587a:	4b07      	ldr	r3, [pc, #28]	; (8005898 <RCC_EnablePeripheralClock+0x64>)
 800587c:	699a      	ldr	r2, [r3, #24]
 800587e:	79fb      	ldrb	r3, [r7, #7]
 8005880:	3b40      	subs	r3, #64	; 0x40
 8005882:	2101      	movs	r1, #1
 8005884:	fa01 f303 	lsl.w	r3, r1, r3
 8005888:	4903      	ldr	r1, [pc, #12]	; (8005898 <RCC_EnablePeripheralClock+0x64>)
 800588a:	4313      	orrs	r3, r2
 800588c:	618b      	str	r3, [r1, #24]
}
 800588e:	bf00      	nop
 8005890:	370c      	adds	r7, #12
 8005892:	46bd      	mov	sp, r7
 8005894:	bc80      	pop	{r7}
 8005896:	4770      	bx	lr
 8005898:	40021000 	.word	0x40021000

0800589c <main>:

void jumpToApp(void);


int main(void)
{
 800589c:	b580      	push	{r7, lr}
 800589e:	b082      	sub	sp, #8
 80058a0:	af00      	add	r7, sp, #0
	RCC_InitClock();
 80058a2:	f7ff ff71 	bl	8005788 <RCC_InitClock>
	updatesInit();
 80058a6:	f000 f8b3 	bl	8005a10 <updatesInit>
	NVIC_UnMaskIRQs();
 80058aa:	f7ff ff5f 	bl	800576c <NVIC_UnMaskIRQs>

	ImgType_t  imgType;
	Boolean_t  state = updateImg(&imgType);
 80058ae:	1dbb      	adds	r3, r7, #6
 80058b0:	4618      	mov	r0, r3
 80058b2:	f000 f8cf 	bl	8005a54 <updateImg>
 80058b6:	4603      	mov	r3, r0
 80058b8:	71fb      	strb	r3, [r7, #7]
	if(state == TRUE)
 80058ba:	79fb      	ldrb	r3, [r7, #7]
 80058bc:	2b01      	cmp	r3, #1
 80058be:	d11f      	bne.n	8005900 <main+0x64>
	{
		switch(imgType)
 80058c0:	79bb      	ldrb	r3, [r7, #6]
 80058c2:	2b41      	cmp	r3, #65	; 0x41
 80058c4:	d002      	beq.n	80058cc <main+0x30>
 80058c6:	2b42      	cmp	r3, #66	; 0x42
 80058c8:	d00c      	beq.n	80058e4 <main+0x48>
 80058ca:	e017      	b.n	80058fc <main+0x60>
		{
			case APP:
				if (ecuConfig.activeAppRegion == 1)
 80058cc:	4b0e      	ldr	r3, [pc, #56]	; (8005908 <main+0x6c>)
 80058ce:	781b      	ldrb	r3, [r3, #0]
 80058d0:	2b01      	cmp	r3, #1
 80058d2:	d103      	bne.n	80058dc <main+0x40>
					ecuConfig.activeAppRegion = 2;
 80058d4:	4b0c      	ldr	r3, [pc, #48]	; (8005908 <main+0x6c>)
 80058d6:	2202      	movs	r2, #2
 80058d8:	701a      	strb	r2, [r3, #0]
				else
					ecuConfig.activeAppRegion = 1;
			break;
 80058da:	e00f      	b.n	80058fc <main+0x60>
					ecuConfig.activeAppRegion = 1;
 80058dc:	4b0a      	ldr	r3, [pc, #40]	; (8005908 <main+0x6c>)
 80058de:	2201      	movs	r2, #1
 80058e0:	701a      	strb	r2, [r3, #0]
			break;
 80058e2:	e00b      	b.n	80058fc <main+0x60>

			case BOOTLOADER:
				if (ecuConfig.activeBootRegion == 1)
 80058e4:	4b08      	ldr	r3, [pc, #32]	; (8005908 <main+0x6c>)
 80058e6:	785b      	ldrb	r3, [r3, #1]
 80058e8:	2b01      	cmp	r3, #1
 80058ea:	d103      	bne.n	80058f4 <main+0x58>
					ecuConfig.activeBootRegion = 2;
 80058ec:	4b06      	ldr	r3, [pc, #24]	; (8005908 <main+0x6c>)
 80058ee:	2202      	movs	r2, #2
 80058f0:	705a      	strb	r2, [r3, #1]
				else
					ecuConfig.activeBootRegion = 1;
			break;
 80058f2:	e002      	b.n	80058fa <main+0x5e>
					ecuConfig.activeBootRegion = 1;
 80058f4:	4b04      	ldr	r3, [pc, #16]	; (8005908 <main+0x6c>)
 80058f6:	2201      	movs	r2, #1
 80058f8:	705a      	strb	r2, [r3, #1]
			break;
 80058fa:	bf00      	nop
		}

		ECU_UpdateConfig();
 80058fc:	f7ff fb2e 	bl	8004f5c <ECU_UpdateConfig>
	}

	jumpToApp();
 8005900:	f000 f804 	bl	800590c <jumpToApp>

	while (1)
 8005904:	e7fe      	b.n	8005904 <main+0x68>
 8005906:	bf00      	nop
 8005908:	20000044 	.word	0x20000044

0800590c <jumpToApp>:
	return 0;
}


void jumpToApp(void)
{
 800590c:	b580      	push	{r7, lr}
 800590e:	af00      	add	r7, sp, #0
	ECU_ConfigActivateApp();
 8005910:	f7ff fb38 	bl	8004f84 <ECU_ConfigActivateApp>
	NVIC_MaskIRQs(0);
 8005914:	2000      	movs	r0, #0
 8005916:	f7ff ff15 	bl	8005744 <NVIC_MaskIRQs>
	NVIC_ResetSystem();
 800591a:	f7ff ff05 	bl	8005728 <NVIC_ResetSystem>
}
 800591e:	bf00      	nop
 8005920:	bd80      	pop	{r7, pc}

08005922 <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
 8005922:	b480      	push	{r7}
 8005924:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
  while (1)
 8005926:	e7fe      	b.n	8005926 <NMI_Handler+0x4>

08005928 <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
 8005928:	b480      	push	{r7}
 800592a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 800592c:	e7fe      	b.n	800592c <HardFault_Handler+0x4>

0800592e <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
 800592e:	b480      	push	{r7}
 8005930:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
 8005932:	e7fe      	b.n	8005932 <MemManage_Handler+0x4>

08005934 <BusFault_Handler>:

/**
  * @brief This function handles Prefetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
 8005934:	b480      	push	{r7}
 8005936:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
 8005938:	e7fe      	b.n	8005938 <BusFault_Handler+0x4>

0800593a <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
 800593a:	b480      	push	{r7}
 800593c:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
 800593e:	e7fe      	b.n	800593e <UsageFault_Handler+0x4>

08005940 <SVC_Handler>:

/**
  * @brief This function handles System service call via SWI instruction.
  */
void SVC_Handler(void)
{
 8005940:	b480      	push	{r7}
 8005942:	af00      	add	r7, sp, #0

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
 8005944:	bf00      	nop
 8005946:	46bd      	mov	sp, r7
 8005948:	bc80      	pop	{r7}
 800594a:	4770      	bx	lr

0800594c <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
{
 800594c:	b480      	push	{r7}
 800594e:	af00      	add	r7, sp, #0

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
 8005950:	bf00      	nop
 8005952:	46bd      	mov	sp, r7
 8005954:	bc80      	pop	{r7}
 8005956:	4770      	bx	lr

08005958 <PendSV_Handler>:

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
{
 8005958:	b480      	push	{r7}
 800595a:	af00      	add	r7, sp, #0

  /* USER CODE END PendSV_IRQn 0 */
  /* USER CODE BEGIN PendSV_IRQn 1 */

  /* USER CODE END PendSV_IRQn 1 */
}
 800595c:	bf00      	nop
 800595e:	46bd      	mov	sp, r7
 8005960:	bc80      	pop	{r7}
 8005962:	4770      	bx	lr

08005964 <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
 8005964:	b580      	push	{r7, lr}
 8005966:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 8005968:	f000 f958 	bl	8005c1c <HAL_IncTick>
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
 800596c:	bf00      	nop
 800596e:	bd80      	pop	{r7, pc}

08005970 <SystemInit>:
  * @note   This function should be used only after reset.
  * @param  None
  * @retval None
  */
void SystemInit (void)
{
 8005970:	b480      	push	{r7}
 8005972:	af00      	add	r7, sp, #0

  /* Configure the Vector Table location -------------------------------------*/
#if defined(USER_VECT_TAB_ADDRESS)
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM. */
#endif /* USER_VECT_TAB_ADDRESS */
}
 8005974:	bf00      	nop
 8005976:	46bd      	mov	sp, r7
 8005978:	bc80      	pop	{r7}
 800597a:	4770      	bx	lr

0800597c <CAN_CallBackFun>:
static CAN_Frame_t rxFrame;
static Boolean_t   newRxFrame = FALSE;


static void CAN_CallBackFun(void)
{
 800597c:	b580      	push	{r7, lr}
 800597e:	af00      	add	r7, sp, #0
	CAN_Rx(&rxFrame, 0);
 8005980:	2100      	movs	r1, #0
 8005982:	4804      	ldr	r0, [pc, #16]	; (8005994 <CAN_CallBackFun+0x18>)
 8005984:	f7ff fa2c 	bl	8004de0 <CAN_Rx>
	newRxFrame = TRUE;
 8005988:	4b03      	ldr	r3, [pc, #12]	; (8005998 <CAN_CallBackFun+0x1c>)
 800598a:	2201      	movs	r2, #1
 800598c:	701a      	strb	r2, [r3, #0]
}
 800598e:	bf00      	nop
 8005990:	bd80      	pop	{r7, pc}
 8005992:	bf00      	nop
 8005994:	20000030 	.word	0x20000030
 8005998:	20000040 	.word	0x20000040

0800599c <validateRes>:


static Boolean_t  validateRes(void)
{
 800599c:	b480      	push	{r7}
 800599e:	b083      	sub	sp, #12
 80059a0:	af00      	add	r7, sp, #0
	u32 timeut = 0xFFFFFF;
 80059a2:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
 80059a6:	607b      	str	r3, [r7, #4]
	while(newRxFrame == FALSE && timeut)
 80059a8:	e002      	b.n	80059b0 <validateRes+0x14>
		timeut--;
 80059aa:	687b      	ldr	r3, [r7, #4]
 80059ac:	3b01      	subs	r3, #1
 80059ae:	607b      	str	r3, [r7, #4]
	while(newRxFrame == FALSE && timeut)
 80059b0:	4b15      	ldr	r3, [pc, #84]	; (8005a08 <validateRes+0x6c>)
 80059b2:	781b      	ldrb	r3, [r3, #0]
 80059b4:	2b00      	cmp	r3, #0
 80059b6:	d102      	bne.n	80059be <validateRes+0x22>
 80059b8:	687b      	ldr	r3, [r7, #4]
 80059ba:	2b00      	cmp	r3, #0
 80059bc:	d1f5      	bne.n	80059aa <validateRes+0xe>

	if(newRxFrame == FALSE)
 80059be:	4b12      	ldr	r3, [pc, #72]	; (8005a08 <validateRes+0x6c>)
 80059c0:	781b      	ldrb	r3, [r3, #0]
 80059c2:	2b00      	cmp	r3, #0
 80059c4:	d101      	bne.n	80059ca <validateRes+0x2e>
		return FALSE;
 80059c6:	2300      	movs	r3, #0
 80059c8:	e019      	b.n	80059fe <validateRes+0x62>

	newRxFrame = FALSE;
 80059ca:	4b0f      	ldr	r3, [pc, #60]	; (8005a08 <validateRes+0x6c>)
 80059cc:	2200      	movs	r2, #0
 80059ce:	701a      	strb	r2, [r3, #0]

	if(rxFrame.idType != STANDARD_ID)
 80059d0:	4b0e      	ldr	r3, [pc, #56]	; (8005a0c <validateRes+0x70>)
 80059d2:	791b      	ldrb	r3, [r3, #4]
 80059d4:	2b00      	cmp	r3, #0
 80059d6:	d001      	beq.n	80059dc <validateRes+0x40>
		return FALSE;
 80059d8:	2300      	movs	r3, #0
 80059da:	e010      	b.n	80059fe <validateRes+0x62>

	if(rxFrame.id != ECU_UPDATE_CONTROL_ID && rxFrame.id != ECU_UPDATE_PAYLOAD_ID)
 80059dc:	4b0b      	ldr	r3, [pc, #44]	; (8005a0c <validateRes+0x70>)
 80059de:	681b      	ldr	r3, [r3, #0]
 80059e0:	2b51      	cmp	r3, #81	; 0x51
 80059e2:	d005      	beq.n	80059f0 <validateRes+0x54>
 80059e4:	4b09      	ldr	r3, [pc, #36]	; (8005a0c <validateRes+0x70>)
 80059e6:	681b      	ldr	r3, [r3, #0]
 80059e8:	2b50      	cmp	r3, #80	; 0x50
 80059ea:	d001      	beq.n	80059f0 <validateRes+0x54>
		return FALSE;
 80059ec:	2300      	movs	r3, #0
 80059ee:	e006      	b.n	80059fe <validateRes+0x62>

	if(rxFrame.frameType != DATA_FRAME)
 80059f0:	4b06      	ldr	r3, [pc, #24]	; (8005a0c <validateRes+0x70>)
 80059f2:	795b      	ldrb	r3, [r3, #5]
 80059f4:	2b00      	cmp	r3, #0
 80059f6:	d001      	beq.n	80059fc <validateRes+0x60>
		return FALSE;
 80059f8:	2300      	movs	r3, #0
 80059fa:	e000      	b.n	80059fe <validateRes+0x62>

	return TRUE;
 80059fc:	2301      	movs	r3, #1
}
 80059fe:	4618      	mov	r0, r3
 8005a00:	370c      	adds	r7, #12
 8005a02:	46bd      	mov	sp, r7
 8005a04:	bc80      	pop	{r7}
 8005a06:	4770      	bx	lr
 8005a08:	20000040 	.word	0x20000040
 8005a0c:	20000030 	.word	0x20000030

08005a10 <updatesInit>:


void  updatesInit(void)
{
 8005a10:	b580      	push	{r7, lr}
 8005a12:	b08e      	sub	sp, #56	; 0x38
 8005a14:	af00      	add	r7, sp, #0
	RCC_EnablePeripheralClock(CAN_PERIPHERAL);
 8005a16:	2039      	movs	r0, #57	; 0x39
 8005a18:	f7ff ff0c 	bl	8005834 <RCC_EnablePeripheralClock>
	CAN_Init(CAN_CallBackFun);
 8005a1c:	480c      	ldr	r0, [pc, #48]	; (8005a50 <updatesInit+0x40>)
 8005a1e:	f7fe fda3 	bl	8004568 <CAN_Init>

	/* config filters */
	CAN_RxFilterBankConfig_t filterConfig = {
 8005a22:	1d3b      	adds	r3, r7, #4
 8005a24:	2234      	movs	r2, #52	; 0x34
 8005a26:	2100      	movs	r1, #0
 8005a28:	4618      	mov	r0, r3
 8005a2a:	f000 f92d 	bl	8005c88 <memset>
 8005a2e:	2350      	movs	r3, #80	; 0x50
 8005a30:	60bb      	str	r3, [r7, #8]
 8005a32:	2351      	movs	r3, #81	; 0x51
 8005a34:	617b      	str	r3, [r7, #20]
 8005a36:	2350      	movs	r3, #80	; 0x50
 8005a38:	623b      	str	r3, [r7, #32]
 8005a3a:	2351      	movs	r3, #81	; 0x51
 8005a3c:	62fb      	str	r3, [r7, #44]	; 0x2c
				.frameType        =  DATA_FRAME
			}
		}
	};

	CAN_InitFilterBank(&filterConfig);
 8005a3e:	1d3b      	adds	r3, r7, #4
 8005a40:	4618      	mov	r0, r3
 8005a42:	f7fe fe63 	bl	800470c <CAN_InitFilterBank>
}
 8005a46:	bf00      	nop
 8005a48:	3738      	adds	r7, #56	; 0x38
 8005a4a:	46bd      	mov	sp, r7
 8005a4c:	bd80      	pop	{r7, pc}
 8005a4e:	bf00      	nop
 8005a50:	0800597d 	.word	0x0800597d

08005a54 <updateImg>:


Boolean_t  updateImg(ImgType_t*  imgType)
{
 8005a54:	b580      	push	{r7, lr}
 8005a56:	b08a      	sub	sp, #40	; 0x28
 8005a58:	af00      	add	r7, sp, #0
 8005a5a:	6078      	str	r0, [r7, #4]
	CAN_Frame_t txFrame = {
 8005a5c:	f107 0308 	add.w	r3, r7, #8
 8005a60:	2200      	movs	r2, #0
 8005a62:	601a      	str	r2, [r3, #0]
 8005a64:	605a      	str	r2, [r3, #4]
 8005a66:	609a      	str	r2, [r3, #8]
 8005a68:	60da      	str	r2, [r3, #12]
 8005a6a:	2351      	movs	r3, #81	; 0x51
 8005a6c:	60bb      	str	r3, [r7, #8]
 8005a6e:	2301      	movs	r3, #1
 8005a70:	73bb      	strb	r3, [r7, #14]
 8005a72:	2341      	movs	r3, #65	; 0x41
 8005a74:	73fb      	strb	r3, [r7, #15]
		.frameType        =    DATA_FRAME,
		.idType           =    STANDARD_ID,
		.data             =    {ECU_ACK}
	};

	CAN_Tx(&txFrame);
 8005a76:	f107 0308 	add.w	r3, r7, #8
 8005a7a:	4618      	mov	r0, r3
 8005a7c:	f7ff f8b8 	bl	8004bf0 <CAN_Tx>

	Boolean_t res  =  validateRes();
 8005a80:	f7ff ff8c 	bl	800599c <validateRes>
 8005a84:	4603      	mov	r3, r0
 8005a86:	f887 3021 	strb.w	r3, [r7, #33]	; 0x21
	if(res == FALSE)
 8005a8a:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
 8005a8e:	2b00      	cmp	r3, #0
 8005a90:	d101      	bne.n	8005a96 <updateImg+0x42>
		return FALSE;
 8005a92:	2300      	movs	r3, #0
 8005a94:	e095      	b.n	8005bc2 <updateImg+0x16e>

	if(rxFrame.DLC != 1)
 8005a96:	4b4d      	ldr	r3, [pc, #308]	; (8005bcc <updateImg+0x178>)
 8005a98:	799b      	ldrb	r3, [r3, #6]
 8005a9a:	2b01      	cmp	r3, #1
 8005a9c:	d001      	beq.n	8005aa2 <updateImg+0x4e>
		return FALSE;
 8005a9e:	2300      	movs	r3, #0
 8005aa0:	e08f      	b.n	8005bc2 <updateImg+0x16e>

	*imgType = rxFrame.data[0];
 8005aa2:	4b4a      	ldr	r3, [pc, #296]	; (8005bcc <updateImg+0x178>)
 8005aa4:	79da      	ldrb	r2, [r3, #7]
 8005aa6:	687b      	ldr	r3, [r7, #4]
 8005aa8:	701a      	strb	r2, [r3, #0]
	if((*imgType) != APP && (*imgType) != BOOTLOADER)
 8005aaa:	687b      	ldr	r3, [r7, #4]
 8005aac:	781b      	ldrb	r3, [r3, #0]
 8005aae:	2b41      	cmp	r3, #65	; 0x41
 8005ab0:	d005      	beq.n	8005abe <updateImg+0x6a>
 8005ab2:	687b      	ldr	r3, [r7, #4]
 8005ab4:	781b      	ldrb	r3, [r3, #0]
 8005ab6:	2b42      	cmp	r3, #66	; 0x42
 8005ab8:	d001      	beq.n	8005abe <updateImg+0x6a>
		return FALSE;
 8005aba:	2300      	movs	r3, #0
 8005abc:	e081      	b.n	8005bc2 <updateImg+0x16e>


	Boolean_t  isFileEnded = FALSE;
 8005abe:	2300      	movs	r3, #0
 8005ac0:	f887 3020 	strb.w	r3, [r7, #32]
	while(isFileEnded == FALSE)
 8005ac4:	e078      	b.n	8005bb8 <updateImg+0x164>
	{
		CAN_Tx(&txFrame);
 8005ac6:	f107 0308 	add.w	r3, r7, #8
 8005aca:	4618      	mov	r0, r3
 8005acc:	f7ff f890 	bl	8004bf0 <CAN_Tx>
		res  =  validateRes();
 8005ad0:	f7ff ff64 	bl	800599c <validateRes>
 8005ad4:	4603      	mov	r3, r0
 8005ad6:	f887 3021 	strb.w	r3, [r7, #33]	; 0x21
		if(res == FALSE)
 8005ada:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
 8005ade:	2b00      	cmp	r3, #0
 8005ae0:	d101      	bne.n	8005ae6 <updateImg+0x92>
			return FALSE;
 8005ae2:	2300      	movs	r3, #0
 8005ae4:	e06d      	b.n	8005bc2 <updateImg+0x16e>

		if(rxFrame.id == ECU_UPDATE_CONTROL_ID)
 8005ae6:	4b39      	ldr	r3, [pc, #228]	; (8005bcc <updateImg+0x178>)
 8005ae8:	681b      	ldr	r3, [r3, #0]
 8005aea:	2b51      	cmp	r3, #81	; 0x51
 8005aec:	d102      	bne.n	8005af4 <updateImg+0xa0>
			return rxFrame.data[0];
 8005aee:	4b37      	ldr	r3, [pc, #220]	; (8005bcc <updateImg+0x178>)
 8005af0:	79db      	ldrb	r3, [r3, #7]
 8005af2:	e066      	b.n	8005bc2 <updateImg+0x16e>

		if(rxFrame.DLC <= 4)
 8005af4:	4b35      	ldr	r3, [pc, #212]	; (8005bcc <updateImg+0x178>)
 8005af6:	799b      	ldrb	r3, [r3, #6]
 8005af8:	2b04      	cmp	r3, #4
 8005afa:	d801      	bhi.n	8005b00 <updateImg+0xac>
			return FALSE;
 8005afc:	2300      	movs	r3, #0
 8005afe:	e060      	b.n	8005bc2 <updateImg+0x16e>


		u32 address = 0;
 8005b00:	2300      	movs	r3, #0
 8005b02:	627b      	str	r3, [r7, #36]	; 0x24
		for(u8 i = 0; i < 4; i++)
 8005b04:	2300      	movs	r3, #0
 8005b06:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
 8005b0a:	e013      	b.n	8005b34 <updateImg+0xe0>
		{
			address |= rxFrame.data[i]<<(i<<3);
 8005b0c:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 8005b10:	4a2e      	ldr	r2, [pc, #184]	; (8005bcc <updateImg+0x178>)
 8005b12:	4413      	add	r3, r2
 8005b14:	79db      	ldrb	r3, [r3, #7]
 8005b16:	461a      	mov	r2, r3
 8005b18:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 8005b1c:	00db      	lsls	r3, r3, #3
 8005b1e:	fa02 f303 	lsl.w	r3, r2, r3
 8005b22:	461a      	mov	r2, r3
 8005b24:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8005b26:	4313      	orrs	r3, r2
 8005b28:	627b      	str	r3, [r7, #36]	; 0x24
		for(u8 i = 0; i < 4; i++)
 8005b2a:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 8005b2e:	3301      	adds	r3, #1
 8005b30:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
 8005b34:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 8005b38:	2b03      	cmp	r3, #3
 8005b3a:	d9e7      	bls.n	8005b0c <updateImg+0xb8>
		}


		u16 startByteOffset  =  (address - FLASH_BASE_ADDRESS) & 0x3FF;
 8005b3c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8005b3e:	b29b      	uxth	r3, r3
 8005b40:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8005b44:	83fb      	strh	r3, [r7, #30]
		u16 startBytePageNum =  (address - FLASH_BASE_ADDRESS) >> 10;
 8005b46:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8005b48:	f103 4378 	add.w	r3, r3, #4160749568	; 0xf8000000
 8005b4c:	0a9b      	lsrs	r3, r3, #10
 8005b4e:	83bb      	strh	r3, [r7, #28]

		FPEC_Error_t  flashState;

		if(startByteOffset == 0)
 8005b50:	8bfb      	ldrh	r3, [r7, #30]
 8005b52:	2b00      	cmp	r3, #0
 8005b54:	d10d      	bne.n	8005b72 <updateImg+0x11e>
		{
			flashState = FPEC_ErasePage(startBytePageNum);
 8005b56:	8bbb      	ldrh	r3, [r7, #28]
 8005b58:	b2db      	uxtb	r3, r3
 8005b5a:	4618      	mov	r0, r3
 8005b5c:	f7ff fb28 	bl	80051b0 <FPEC_ErasePage>
 8005b60:	4603      	mov	r3, r0
 8005b62:	76fb      	strb	r3, [r7, #27]

			if(flashState != FPEC_NO_ERRORS)
 8005b64:	7efb      	ldrb	r3, [r7, #27]
 8005b66:	2b02      	cmp	r3, #2
 8005b68:	d003      	beq.n	8005b72 <updateImg+0x11e>
			{
				txFrame.data[0] = ECU_NAK;
 8005b6a:	234e      	movs	r3, #78	; 0x4e
 8005b6c:	73fb      	strb	r3, [r7, #15]
				return FALSE;
 8005b6e:	2300      	movs	r3, #0
 8005b70:	e027      	b.n	8005bc2 <updateImg+0x16e>
			}
		}


		for(u8 i = 4; i < rxFrame.DLC; i++)
 8005b72:	2304      	movs	r3, #4
 8005b74:	f887 3022 	strb.w	r3, [r7, #34]	; 0x22
 8005b78:	e018      	b.n	8005bac <updateImg+0x158>
		{
			flashState = FPEC_DirectWriteByte(startBytePageNum, startByteOffset, rxFrame.data[i]);
 8005b7a:	8bbb      	ldrh	r3, [r7, #28]
 8005b7c:	b2d8      	uxtb	r0, r3
 8005b7e:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
 8005b82:	4a12      	ldr	r2, [pc, #72]	; (8005bcc <updateImg+0x178>)
 8005b84:	4413      	add	r3, r2
 8005b86:	79da      	ldrb	r2, [r3, #7]
 8005b88:	8bfb      	ldrh	r3, [r7, #30]
 8005b8a:	4619      	mov	r1, r3
 8005b8c:	f7ff faa2 	bl	80050d4 <FPEC_DirectWriteByte>
 8005b90:	4603      	mov	r3, r0
 8005b92:	76fb      	strb	r3, [r7, #27]

			if(flashState != FPEC_NO_ERRORS)
 8005b94:	7efb      	ldrb	r3, [r7, #27]
 8005b96:	2b02      	cmp	r3, #2
 8005b98:	d003      	beq.n	8005ba2 <updateImg+0x14e>
			{
				txFrame.data[0] = ECU_NAK;
 8005b9a:	234e      	movs	r3, #78	; 0x4e
 8005b9c:	73fb      	strb	r3, [r7, #15]
				return FALSE;
 8005b9e:	2300      	movs	r3, #0
 8005ba0:	e00f      	b.n	8005bc2 <updateImg+0x16e>
		for(u8 i = 4; i < rxFrame.DLC; i++)
 8005ba2:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
 8005ba6:	3301      	adds	r3, #1
 8005ba8:	f887 3022 	strb.w	r3, [r7, #34]	; 0x22
 8005bac:	4b07      	ldr	r3, [pc, #28]	; (8005bcc <updateImg+0x178>)
 8005bae:	799b      	ldrb	r3, [r3, #6]
 8005bb0:	f897 2022 	ldrb.w	r2, [r7, #34]	; 0x22
 8005bb4:	429a      	cmp	r2, r3
 8005bb6:	d3e0      	bcc.n	8005b7a <updateImg+0x126>
	while(isFileEnded == FALSE)
 8005bb8:	f897 3020 	ldrb.w	r3, [r7, #32]
 8005bbc:	2b00      	cmp	r3, #0
 8005bbe:	d082      	beq.n	8005ac6 <updateImg+0x72>
			}
		}
	}


	return TRUE;
 8005bc0:	2301      	movs	r3, #1
}
 8005bc2:	4618      	mov	r0, r3
 8005bc4:	3728      	adds	r7, #40	; 0x28
 8005bc6:	46bd      	mov	sp, r7
 8005bc8:	bd80      	pop	{r7, pc}
 8005bca:	bf00      	nop
 8005bcc:	20000030 	.word	0x20000030

08005bd0 <Reset_Handler>:
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
 8005bd0:	480c      	ldr	r0, [pc, #48]	; (8005c04 <LoopFillZerobss+0x12>)
  ldr r1, =_edata
 8005bd2:	490d      	ldr	r1, [pc, #52]	; (8005c08 <LoopFillZerobss+0x16>)
  ldr r2, =_sidata
 8005bd4:	4a0d      	ldr	r2, [pc, #52]	; (8005c0c <LoopFillZerobss+0x1a>)
  movs r3, #0
 8005bd6:	2300      	movs	r3, #0
  b LoopCopyDataInit
 8005bd8:	e002      	b.n	8005be0 <LoopCopyDataInit>

08005bda <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 8005bda:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 8005bdc:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 8005bde:	3304      	adds	r3, #4

08005be0 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 8005be0:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 8005be2:	428c      	cmp	r4, r1
  bcc CopyDataInit
 8005be4:	d3f9      	bcc.n	8005bda <CopyDataInit>
  
/* Zero fill the bss segment. */
  ldr r2, =_sbss
 8005be6:	4a0a      	ldr	r2, [pc, #40]	; (8005c10 <LoopFillZerobss+0x1e>)
  ldr r4, =_ebss
 8005be8:	4c0a      	ldr	r4, [pc, #40]	; (8005c14 <LoopFillZerobss+0x22>)
  movs r3, #0
 8005bea:	2300      	movs	r3, #0
  b LoopFillZerobss
 8005bec:	e001      	b.n	8005bf2 <LoopFillZerobss>

08005bee <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 8005bee:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 8005bf0:	3204      	adds	r2, #4

08005bf2 <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 8005bf2:	42a2      	cmp	r2, r4
  bcc FillZerobss
 8005bf4:	d3fb      	bcc.n	8005bee <FillZerobss>

/* Call the clock system intitialization function.*/
    bl  SystemInit
 8005bf6:	f7ff febb 	bl	8005970 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 8005bfa:	f000 f821 	bl	8005c40 <__libc_init_array>
/* Call the application's entry point.*/
  bl main
 8005bfe:	f7ff fe4d 	bl	800589c <main>
  bx lr
 8005c02:	4770      	bx	lr
  ldr r0, =_sdata
 8005c04:	20000000 	.word	0x20000000
  ldr r1, =_edata
 8005c08:	20000010 	.word	0x20000010
  ldr r2, =_sidata
 8005c0c:	08005cc8 	.word	0x08005cc8
  ldr r2, =_sbss
 8005c10:	20000010 	.word	0x20000010
  ldr r4, =_ebss
 8005c14:	2000004c 	.word	0x2000004c

08005c18 <ADC1_2_IRQHandler>:
 * @retval : None
*/
    .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
 8005c18:	e7fe      	b.n	8005c18 <ADC1_2_IRQHandler>
	...

08005c1c <HAL_IncTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
 8005c1c:	b480      	push	{r7}
 8005c1e:	af00      	add	r7, sp, #0
  uwTick += uwTickFreq;
 8005c20:	4b05      	ldr	r3, [pc, #20]	; (8005c38 <HAL_IncTick+0x1c>)
 8005c22:	781b      	ldrb	r3, [r3, #0]
 8005c24:	461a      	mov	r2, r3
 8005c26:	4b05      	ldr	r3, [pc, #20]	; (8005c3c <HAL_IncTick+0x20>)
 8005c28:	681b      	ldr	r3, [r3, #0]
 8005c2a:	4413      	add	r3, r2
 8005c2c:	4a03      	ldr	r2, [pc, #12]	; (8005c3c <HAL_IncTick+0x20>)
 8005c2e:	6013      	str	r3, [r2, #0]
}
 8005c30:	bf00      	nop
 8005c32:	46bd      	mov	sp, r7
 8005c34:	bc80      	pop	{r7}
 8005c36:	4770      	bx	lr
 8005c38:	2000000c 	.word	0x2000000c
 8005c3c:	20000048 	.word	0x20000048

08005c40 <__libc_init_array>:
 8005c40:	b570      	push	{r4, r5, r6, lr}
 8005c42:	2500      	movs	r5, #0
 8005c44:	4e0c      	ldr	r6, [pc, #48]	; (8005c78 <__libc_init_array+0x38>)
 8005c46:	4c0d      	ldr	r4, [pc, #52]	; (8005c7c <__libc_init_array+0x3c>)
 8005c48:	1ba4      	subs	r4, r4, r6
 8005c4a:	10a4      	asrs	r4, r4, #2
 8005c4c:	42a5      	cmp	r5, r4
 8005c4e:	d109      	bne.n	8005c64 <__libc_init_array+0x24>
 8005c50:	f000 f822 	bl	8005c98 <_init>
 8005c54:	2500      	movs	r5, #0
 8005c56:	4e0a      	ldr	r6, [pc, #40]	; (8005c80 <__libc_init_array+0x40>)
 8005c58:	4c0a      	ldr	r4, [pc, #40]	; (8005c84 <__libc_init_array+0x44>)
 8005c5a:	1ba4      	subs	r4, r4, r6
 8005c5c:	10a4      	asrs	r4, r4, #2
 8005c5e:	42a5      	cmp	r5, r4
 8005c60:	d105      	bne.n	8005c6e <__libc_init_array+0x2e>
 8005c62:	bd70      	pop	{r4, r5, r6, pc}
 8005c64:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 8005c68:	4798      	blx	r3
 8005c6a:	3501      	adds	r5, #1
 8005c6c:	e7ee      	b.n	8005c4c <__libc_init_array+0xc>
 8005c6e:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 8005c72:	4798      	blx	r3
 8005c74:	3501      	adds	r5, #1
 8005c76:	e7f2      	b.n	8005c5e <__libc_init_array+0x1e>
 8005c78:	08005cc0 	.word	0x08005cc0
 8005c7c:	08005cc0 	.word	0x08005cc0
 8005c80:	08005cc0 	.word	0x08005cc0
 8005c84:	08005cc4 	.word	0x08005cc4

08005c88 <memset>:
 8005c88:	4603      	mov	r3, r0
 8005c8a:	4402      	add	r2, r0
 8005c8c:	4293      	cmp	r3, r2
 8005c8e:	d100      	bne.n	8005c92 <memset+0xa>
 8005c90:	4770      	bx	lr
 8005c92:	f803 1b01 	strb.w	r1, [r3], #1
 8005c96:	e7f9      	b.n	8005c8c <memset+0x4>

08005c98 <_init>:
 8005c98:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8005c9a:	bf00      	nop
 8005c9c:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8005c9e:	bc08      	pop	{r3}
 8005ca0:	469e      	mov	lr, r3
 8005ca2:	4770      	bx	lr

08005ca4 <_fini>:
 8005ca4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8005ca6:	bf00      	nop
 8005ca8:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8005caa:	bc08      	pop	{r3}
 8005cac:	469e      	mov	lr, r3
 8005cae:	4770      	bx	lr
